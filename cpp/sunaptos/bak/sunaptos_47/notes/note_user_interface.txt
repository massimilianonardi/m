USER INTERFACE...
ci sono tre tipi di device: solo input, solo output, sia input che output...
una user interface ha bisogno di una o più device in grado complessivamente di fornire sia input che output...
una user interface deve fornire (anche filtrato) un completo feedback dell'input sull'output, ovvero ad ogni input 
deve corrispondere un output...in realtà non è così stretta...meglio: per ogni device di input deve esistere almeno 
un segnale che abbia un feedback in almeno un device di output...questa è la definizione corretta!!! il che vuol dire 
che se ho un mouse del quale non so niente, non fa parte della user interface...mentre, se ho un mouse che risponde 
attraverso a video solo al click di un pulsante oppure quando lo muovo di almeno una soglia...quello ne fa parte! 
...in realtà non è così, il feedback non è indispensabile poichè io potrei voler mandare dei comandi segnali 
"nascosti"!!! o comunque in generale non serve il costraint...

una delle prime cose è individuare delle interfacce raw sia per l'input che per l'output per generalizzare il più 
possibile i vari device utilizzati o utilizzabili per la user interface...NB anche le cose più impensabili!!!

ad esempio posso astrarre diverse interfacce per l'output a seconda delle dimensioni (1D, 2D, 3D, 4D, ecc.) ma 
magari se riesco ad unificarle sarebbe un successone!!! ...comunque già bisogna verificare se è fattibile l'esempio 
di prima...

altra questione da tenere presente è lo "scope" degli input e degli output...ad esempio ho una ui composta da mouse 
e parte dello schermo, in tale situazione il mouse in generale va fuori lo "scope" della mia porzione facente parte 
della ui...posso anche permetterlo, ma devo prevedere comportamenti diversi configurabili, tipo: unmanaged, 
autofocus, capture/release, ecc.

altra questione riguarda le device non strettamente di "user interface" ovvero...mentre mouse, tastiera, e simili 
hanno una evidente connotazione di user interface, ci sono poi i device di input/output generico tipo la scheda di 
rete, hd sata ed usb, ecc. come li tratto questi? forse mi serve fare una distinzione tra "user interface" (mouse, 
tastiera e simili), "stream" (rete, video, audio, hdmi, ecc.) "storage" (hd, dvd, ecc.) o forse una distinzione 
ancora più specifica...

DUNQUE...
una ui è un qualcosa che riceve dei flussi di input in base ai quali vengono generati dei flussi di output in maniera 
costante (questa è la differenza tra ui e "funzione")...ora forse varrebbe la pena estendere il concetto di ui, 
poichè posso contemplare degli input ed output dove non ci sia lo zampino dello user, ma siano solo dati...quindi, 
diciamo stp (stream processor) anzichè ui...da pensare, per il momento continuiamo a dire ui per non fare confusione...
quindi tra i segnali di input, oltre a tastiera e mouse, possiamo trovare anche i dati che confluiscono nella gui...
cioè come un tasto è bindato al click del mouse nella sua area, una listbox può essere bindata ad una tab (seq di seq) 
trasmessa insieme agli altri segnali...bisogna solo fare attenzione a come gestire il binding di strutture non 
elementari come ad esempio la listbox dove può variare indipendentemente la lista ed il singolo elemento...verificare 
in relazione agli eventi di variazioni di sequenze complesse...

esempio di controverifica concettuale: la gui...gui è un stp che quando parte gli vengono automaticamente connessi 
mouse e tastiera come input e video ed audio come output...una volta avviata la gui elabora dei segnali che oltre a 
generare un feedback audio/video, generano anche dei comandi che possono dinamicamente connettere disconnettere altri 
input/output...es. se apro un file browser questo mi genera un comando di connessione di un stream da storage a gui 
dove parallelamente il file browser invia comandi allo storage che gli dice cosa inviare alla gui (da quale dir 
prendere la lista dei files), quindi gui+mouse+kb -> avvio app "file browser" -> si connette a gui come input 
(comandi gui + dati) e come output(riceve da gui comandi)...quindi è un po' diverso, ma è ok...
in pratica un'app fornisce a gui come input dati che si traducono in gui, ovvero struttura dell'app e gui come output 
genera comandi per l'app...per cui il tutto si riduce a trovare un modo uniforme per generare comandi (deriva gratis 
dalla struttura remota dei metodi e dei parametri) ed un modo uniforme ed astratto per definire le strutture delle 
apps cioè un modo per definire menu, bottoni e caselle di testo e distribuzione logica in maniera indipendente dal 
fatto che la ui abbia un output 1D, 2D, 3D, audio, video, ecc. poi le particolarizzazioni tipo le skin, il layout, 
ecc. vengono implementati come dei profili associati al raggruppamento <app=browser, ui=gui, user=admin, skin=...ecc.> 
in pratica applicazione è un algoritmo/metodologia/funzione/ecc. indipendente dalla user interface, ma dipendente solo 
dai dati che tratta specificamente

esempi...listbox ha associato una seq che rappresenta la lista e sotto di se come child ha dei sottocontrolli textbox 
che listbox binda a ciascuna sottoseq che rappresenta un elemento della lista, listbox lancia comandi a storage 
chiedendo la lista file di una cartella, i vari textbox possono lanciare comandi tipo rinomina, cancella, ecc., (NB i 
comandi implicano il memorizzare in una cache interna di selezione)...questo approccio non mi piace...proviamo così...
listbox è un oggetto che ascolta asincronamente (su comando e refresh esterno) una seq dati (lista) ed una seq 
id-comandi ed invia asincronamente una comando tra gli id disponibili ed una sottolista (selezione) su cui agire...
così mi piace: un elemento ui è un oggetto associabile ad un srv da cui riceve una seq id-comandi, una seq dati ed 
ed una seq config/params (del controllo ui) ed invia un id comando ed una sottoseq dati...tutto asincronamente...
NB seq comandi e dati sono forniti dal srv bindato, mentre config/params e comandi ui sono forniti da altri elementi 
ui...questo permette di astrarre e separare totalmente i srv dalle ui...poi è responsabilità dei progettisti ui fare 
in modo che i controlli ui supportino la completezza dei dati offerti dai srv e l'architettura dell'app...quindi una 
app è un'architettura dove (dinamicamente) raggruppo elementi ui e bindo srv ad alcuni di essi, mentre ad altri bindo 
altri elementi ui della stessa app (sia per motivi di sicurezza che per robustezza, non consento di controllare ui 
al di fuori della app)...ciò significa che alcuni controlli gestiscono la ui, che vuol dire che per loro il srv è in 
realtà un elemento ui...qui la cosa importante è che gli elementi ui offrano un'interfaccia uguale ai srv-ui...ciò 
significa che la iface ui_elem deriva dalla iface srv_ui, poi i controlli gui, remote-controller-ui, ecc. implementano 
la iface ui_elem, o altre iface da questa derivate (es. ui_list, ui_command, ui_menu, ui_tree, ui_tab, ui_layout, ecc.)
...cioè effettivamente astraggo tutte le ui...tutto sta nell'intelligenza con cui definisco le iface derivate da 
ui_elem...piccolo esempio progetto un'app per una gui con layout, list e tab...quando anzichè una gui gli associo una 
ui 1D, magari questa ui usa uno stesso controllo per layout e per tab...cioè in fondo entrambi mi servono per 
separare degli elementi solo che nella gui posso averne alcuni visibili contemporaneamente, in un ambiente 1D no!!!
ora rimane solo da progettare come definisco le app in tutta la loro dinamicità...non è difficile, ma solo un po' 
complicato dovrebbe bastare un file xml o simili...stesso file per ogni ui (sia gui, che remote-controller-ui, ecc.)
quindi lanciare un'app significa lanciare un srv ui con parametro la ui che si vuole lanciare...
es: <gui, file_browser>, <remote-controller-ui, file_browser> (NB notare che il "file" della ui è sempre lo stesso!!!)
NB la skin è una configurazione associata a <gui, app> (utente, profilo, ecc.) e non ad app in generale...in altre ui 
la stessa app avrà altre configurazioni analoghe alle skin per la gui...
Nota: un ui_elem per creare/distruggere un altro ui_elem invia comandi al relativo parent che supporti tali comandi 
come ad es un layout può creare/distruggere altri ui_elem child, un ui_button, no! cioè creare/distruggere altri 
ui_elem è semplicemente un particolare comando offerto da taluni ui_elem

altro possibile approccio (forse molto meglio)...tutti i controlli ecc. li riporto e racchiudo nella iface della ui, 
cioè anzichè avere una ui_elem ed altre da questa derivate (ui_list, ui_command, ui_menu, ui_tab, ui_layout, ecc.), 
ho solo la iface ui con metodi specifici per gestire gli ui_list, ui_command, ui_menu, ui_tab, ui_layout, ecc.
...NO! così è troppo rigido da espandere, cioè per aggiungere un controllo devo ricompilare tutta la ui!!!

al limite posso fare così: una ui con integrato/i uno o pochi controlli elementari (es. ui_textbutton, ui_layout) e 
poi gli altri controlli li derivo utilizzando i file di def delle app, cioè facendo si che le app possono essere 
considerati controlli e viceversa, per espandere i controlli mi basta un "file xml" o simile...la differenza rispetto 
alla prima soluzione è che prima i controlli essendo compilati possono (se progetto bene la gerarchia di ifaces) 
essere vincolati alla particolare implementazione della ui, nel terzo caso sicuramente no...quale scegliere??!!!

scelgo la terza soluzione!

rimane il problema che nelle app ho controlli che agiscono su altri elementi della ui e finchè sono parametri banali 
potrebbe anche andare bene, ma in generale sono parametri specifici di quella ui (ad es un bottone per il testo 
giustificato)...in realtà è solo un problema di usabilità perchè per come ho definito gli ui_elem, non entro nello 
specifico di cosa vado a controllare, cioè in una app dico solo che in un punto c'è il controllo x che controlla il 
controllo y e basta poi in gui magari x agisce sulla giustificazione del testo in y, in una aui magari controlla la 
velocità della voce che parla...risolto così...

ora come gestire il binding tra input e comandi_ui accettati dagli ui_elem? ad es gli ui_elem possono supportare i 
comandi highlight (mouse hover), execute/select (mouse click), clear selection (middle cick), context command menu 
(right click) (comandi del srv bindato), ecc. tale binding fa parte della config della ui e grazie al profiling lo 
posso specializzare e differenziare anche a livello di app e/o controllo (ad es. in generale uso il mouse, ma per 
taluni controlli di una certa app uso il telecomando...)

controllo UI:
- oggetto che supporta comandi ui
- oggetto che può controllare se stesso ed altri controlli in base al binding tra "eventi" rilevati da uno o più 
  stream e comandi ui (la variabilità sta nel destinari/o del comando e dai parametri)
- oggetto che gestisce dati provenienti da stream connessi
- oggetto che può inviare comandi ad uno o più stream connessi (i quali a loro volta possono essere connessi a dei srv)
- oggetto che può essere creato o distrutto in base ad eventi su dati provenienti da stream connessi alla ui

in pratica ci sono stream connessi dinamicamente in base a comandi inviati alla ui (es capture mouse/kb, editing della 
catena di elaborazione segnali, ecc.), stream generalmente connessi alla ui (user input classico) che questa traduce 
in comandi inviati ai vari controlli ui sulla base delle varie configurazioni/profili (ui, app, controlli, eser, ecc.) 
stream dati connessi direttamente ad un controllo (es statusbar) NB poi ci sono degli operatori sugli stream che 
possono fare diverse cose (splitters, triggers, event detectors, ecc.) come ad esempio splittare una seq, generare 
degli eventi di creazione/distruzione controlli in base al num di elementi nella seq...in pratica...connettendo ad uno 
stream un seq processor che genera eventi sulla base della seq (num elems, elem, subseq, ecc.) e questi eventi li 
bindo a comandi ui di uno specifico controllo...il problema è che questa configurazione dovrebbe far parte della ui...

un controllo accetta comandi ui in base ai quali:
- cambia il suo stato
- crea/distrugge controlli child (per i non child invia comandi al parent e poi ci pensa lui...)
- invia altri comandi ui ad altri controlli (pensare se conviene ricondurlo al caso successivo...NO separare la ui!!!)
- comandi a srv

lo stato di un controllo dipende da:
- risorse esterne (testo e immagini) particolari per l'app date da <skin, lang> riferite tramite id e fornite tramite 
  stream dati dalla ui al controllo che le memorizza come seq asincrone (quindi possono essere cambiate in real time)
- dati derivanti da srv (testo, immagini e stream video)
- config del controllo (definita nel file app) giustificazione testo, adattamento immagine e video (no audio)
- il controllo base può avere un qualunque numero di stati (pure zero?)

NB il primo caso è una particolarizzazione del secondo dove il srv è la ui, ma li tengo separati proprio per 
evidenziare ciò che è legato alla ui e ciò che è applicazione...NB posso anche usare solo gli stream dati anche per 
le risorse, ma avrei la controindicazione che quando cambio ui, l'app usa ancora quelle risorse e potrebbe non avere 
molto senso...sarebbe cioè un uso improprio, ma mi consentirebbe la massima flessibilità qualora ne avessi bisogno...
riepilogando, in ogni caso è meglio permettere la separazione tra dati ui e dati app...

ora lasciamo perdere i casi complicati che ricordano ad es applicazioni flash (transizioni di stato, ecc.) che 
prenderò in esame con ui più avanzate

quindi in questo caso un controllo è definito dal numero di stati e per ogni stato ho un "link" ad un dato associato...
questo "link" è un'associazione o ad un id risorsa o ad un srv -> <ui_id, ui_type, <states>, <srv>, <data_actions>, ...> 
state=<bind_type, <res>> in realtà <states> sta fuori dall'app, fa parte di skin+lang...al suo posto ci metto 
"n_states" che mi dice quanti stati ha (a ciascuno dei quali corrisponde un comando ui) poi mi serve il binding coi 
dati ed il binding con i comandi...NB anche per skin+lang basta n_states...quindi...
<ui_id, ui_type, n_states, <state_actions>, <srv>, <data_actions>, <commands>>
con data_actions = <on_null, on_not_null, elems_action, seq_action, index_actions_seq> 
NB azioni basate su struct dati non sul contenuto, inoltre le ui così pensate si fermano al primo livello di struttura 
a meno di non pensare di avere azioni che reiterano il data_actions...
le azioni...possono essere sulla ui (cambia stato = esegui comando, crea, distruggi) o sui srv (esegui comando)...il 
problema sono i parametri (da e come li prendo, come li estrapolo da elaborazioni)

rielaboriamo:
<ui_id, ui_type, n_states, <ui_commands>, <srv>, <data_actions>, <commands>>
ui_command: <actions> paramteri o non parametri?
srv: specifiche per ottenere dal loader i srv-command i cui out stream vengono bindati
data_action: <on_null, on_not_null, elems_action, seq_action, index_actions_seq> azioni per ciascuno stream
command: comandi offerti dal controllo senza parametri che vengono poi tradotti in comandi per i srv con parametri

NB sembra che command ed ui_command siano ridondanti, ma potrebbe essere sempre utile mantenere la separazione tra ui 
ed app...

parametri: i parametri con cui vengono chiamati i srv-command, vengono generati a partire da: la combinazione degli 
stream provenienti dai vari srv-command, dagli user input stream e dalle variabili interne al controllo (es. selezione)

quindi rimane da progettare le azioni, le variabili interne al controllo e le regole di combinazione dei parametri...
in pratica un controllo è una composizione di srv-command, quindi è un metalinguaggio di programmazione data-driven, 
con l'aggiunta della parte ui...pensare se mi conviene ridurre tutto ad un srv...

semplificazione: riduco tutto ad un srv (che sarà un srv di comodo per le ui e che racchiude tutta la logica) dove lui 
manda una seq asincronamente e riceve comandi con unico parametro l'index complesso riferito alla seq ultima che ha 
fornito (attenzione alla sicronizzazione!!!)...es. addselection(index), clearselection(), increasecounter(), ecc...
in pratica ongi metodo (comando) è bindabile quasi direttamente ad eventi ui...questi index è facile ottenerli perchè 
(ancora devo ragionare come) vengono specificati nelle data action per generare dei sottocontrolli ed associarli a 
questi, poi questi invieranno comandi al parent il quale ha la mappa <sottocontrollo, index>...un controllo espone 
comandi (con index complesso) e questi vengono mappati (da config nell'app) nei comandi del srv oppure a comandi ad 
altri controlli...quindi:
<ui_id, ui_type, n_states, <ui_command>, <srv>, <data_action>>
ui_command: <ui_id, command, param> se ui_id = -1 allora è riferito a srv..."command" se è un comando ui allora è uno 
dei comandi supportati dai controlli (create/destroy/change_state/etc.) e param va pensato bene...
srv: specifiche per ottenere dal loader i srv-command il cui out stream viene bindato
data_action: <on_null, on_not_null, elems_action, seq_action, index_actions_seq> azioni ui per ciascuno stream
questo va pensato bene...in pratica sono descrizioni di comandi parametrici dove il parametro implicito è l'index 
complesso e gli altri parametri sono la descrizione dei controlli...cioè action può essere "crea child" o "distruggi 
tutti i child" (sugli eventi dati permetto solo il destroy all altrimenti è troppo complicato...magari se serve, lo 
espando in una futura versione)...posso permettere un "update"? seq_action può essere uguale ad una data_action e così 
ricorsivamente

iface UI:
- start (forse superfluo)
- stop (forse superfluo)
- getParameters: per questi due metodi va usato lo standard dettato dalla iface config
- setParameters
- setIOConnection: dis/connette uno stream in input o output compatibili con la particolare implementazione della ui
- loadUI: accetta come argomento la seq che rappresenta la ui (app, controllo, ecc.) da eseguire...da dove arrivi 
tale seq non interessa la ui...può arrivare da un db, da un file serializzato, un file di testo, dalla rete...
cioè caricare i file non è più cura delle app, ma se ne occupa l'utente dall'esterno creando un flusso di stream...
cioè uniformando tutto il os con le seq il flusso di dove arrivano/vanno i dati è estremamente flessibile!!!
la seq ha una struttura tutta relativa a come progetterò la iface ui fatta eccezione ai srv da bindare: per questi 
viene specificato il nome da richiedere al loader, la iface è per tutti la iface "command" che ha un unico metodo 
"execute" per cui "params" è fatta così: id-command ed una seq params
insieme alla iface si definisce il formato di ui_seq e gli ui_type consentiti
ui_type: ui_layout (solo lui può avere dei child), ui_data (se data=1elem, allora rappresenta numero, se data=seq, 
allora rappresenta testo, se data=seq-complessa, allora può essere immagine, audio, ecc.)

NB pensata così ui può uniformare tutte le possibili ui, quindi un unico srv implementerà ui...gui, aui, ecc. 
deriveranno semplicemente da come connetto input ed output alla ui, ma è molto complicato adesso e bisognerebbe 
astrarre molto bene gli input e gli output (1D, 2D, ecc.) per il momento lasciamo perdere ed implemento una ui 
come gui richiedendo obbligatoriamente un output 2D più uno o due facoltativi 1D (audio)

rimane da definire il formato della ui_seq:
- struct_seq: seq di id_obj, se c' una subseq allora tutti gli obj riferiti in questa sono child dell'elem che 
  precede la subseq
- obj_seq: seq di seq rappresentanti gli oggetti (sia srv che controlli) usati NB index=id_obj
  - obj: seq <ui_type, binded_type, ui_id/ui_name/command_srv_name, actions_seq> NB obj_params sono specifici della ui 
    e per lo stesso obj che è presente più volte nella stessa app, possono essere diversi (due file browser con 
    dimensioni e visualizzazione diverse)...riguardo al binded_type io posso bindare altri ui_elem presenti nella 
    stessa app, posso richiamare delle app come ui_elem tramite ui_name ed infine dei command_srv tramite nome...ora, 
    mentre richiamare i srv tramite nome mi può (mi deve) andare bene, per le app lo posso accettare? per il momento 
    si, ma poi mi devo slegare dal particolare storage (il file system in questo caso)
NB come prevedere la creazione/distruzione dinamica (dipendente dai dati) degli ui_elem?
casistiche: partendo da una seq posso fare le seguenti distinzioni: azioni omogenee per tutti gli elem ed altre azioni 
per tutte le seq, oppure azioni distinte per index, poi posso avere azioni per seq null ed azioni per seq not-null
actions_seq: <on_null, on_not_null, elems_action, seq_action, index_actions_seq> dove ognuno di questi è un'azione 
eccetto index_actions_seq che è una sequenza di coppie <index, action> NB per tutti gli elem/seq non presenti nella 
index_actions_seq, vengono eseguite le actions elems_action e seq_action rispettivamente...
rimane da definire action e poi le action da bindare agli input

dunque, da una parte c'è il "device manager" o "iom" (i/o manager) che è un srv ad istanza unica che gestisce 
tutto l'hw di input/output dall'altra c'è il "uim" (user interface manager) che gestisce l'i/o di interfaccia utente, 
ovvero mouse, tastiera, video, audio, ecc. che astrae dal particolare hw gli basta solo che gli hw a cui viene 
associato abbiano determinate iface...in pratica uim si occupa solo di sw cioè non fa altro che fare conversioni, 
filtraggi, trattamenti di dati e dispatching di i/o da/per apps/srvs...anzi rivediamo così i nomi: "dem" (device 
manager), "iom" (gestisce l'i/o di uim + tutto il resto del i/o) iom oltre a fare i servizi specifici di uim, 
gestisce tutto l'i/o accedendo direttamente alle iface del hw potendo quindi sfruttare le eventuali capacità hw come 
ad es. se devo fare un resize di uno stream video posso vedere se la destinazione dello stream è verso una scheda 
grafica che supporta questo tipo di funzione via hw...naturalmente il discorso è più generale: iom elabora, rimappa e 
dispaccia segnali avvalendosi di tutto l'hw a disposizione per ottimizzare ed accelerare tali operazioni anche quando 
l'hw in questione non è direttamente coinvolto...questa possibilità di iom deriva direttamente dall'accedere 
direttamente alle iface del hw al contrario de uim come avevo ipotizzato inizialmente...naturalmente la possibilità 
di sfruttare l'accelerazione hw è consentita potenzialmente ad ogni srv tramite l'accesso alle iface hw...
in pratica il dem include i driver hw con i quali offre diverse iface hw ai srv richiedenti...queste iface devono 
avere un alto grado di astrazione tipo "parallel stream" (hdmi, rete), "parallel sequence" (mouse, tastiera, 
telecomando, ecc.), "finite storage" (hd sata/usb, sdhc, cd/dvd/bd, ecc.) per il momento anche se non piace diciamo 
che in linea di principio sono consentiti hw compositi (tipo sceda grafica con audio incorporato)...in ogni caso, 
ogni hw (anche semplice) può offrire più di una iface hw (ad es rete può offrire sia parallel stream che parallel 
sequence), inoltre da una iface hw posso richiedere l'hw associato cioè il srv specifico di quel particolare hw 
tramite il quale posso accedere alle funzionalità di accelerazione o impostare delle proprietà specifiche...

NB ritorna il problema di ritornare oggetti (iface, srv) anzichè solo sequence...potrei pensare di utilizzare il 
loader ed usare degli id ritornati nelle sequence, ma sarebbe una soluzione intrinsecamente lenta in ogni situazione 
per cui devo pensare ad una soluzione integrata in CommandListener ed IPC/IPCServer/IPCClient...

RIEPILOGANDO...
IOI (Input/Output Interface): ifaces di alto livello che astraggono l'input e l'output sia da/per hw che da/per 
apps/srvs...

DEM (DEvice Manager): gestisce ogni hardware e fornisce dei iface-srv-driver che accedono alle funzionalità ed alle 
proprietà/configurazione, tali iface devono essere pensate per raggruppare tipologie di hw omogenee, poi le config 
sono specifiche del particolare hw. alcuni di questi hw possono fornire delle iface di i/o di alto livello (ioi) che 
consentano di effettuare i/o da/per l'hw in modo generico ed efficiente...

IOM (I/O Manager): è il srv a cui chiedere le ioi, quando chiedo una ioi al loader questo la ritorna/istanzia 
tramite iom...NB in base alle policy di sistema (cioè come gestire le istanziazioni di loader) loader ritornerà una 
certa ioi, ma indipendentemente da ciò a runtime posso modificarle/rimapparle/ecc. (naturalmente in base alle policy)
NB ripensare bene a iom, loader e policy...

UI (User Interface): una ui è un srv che utilizza alcune ioi tramite le quali inviare comandi a determinate 
apps/srvs...

IOS (I/O Signal): è una sequenza con particolari formati, ovvero uno stream parallelo di più sequenze elementari...
qui non mi interessa il wiring/channel/ecc. ma il multiplexing e/o encoding...in pratica un ios è una sequenza che 
racchiude un "qualunque" numero di segnali con una "qualunque" possibile codifica in modo molto simile (ma più 
avanzato) del hdmi, la cosa importante è che il formato di impacchettamento/multiplexing di ios sia agevole e 
flessibile in merito ai wiring/channel fisici possibili ovvero rispetto al trasporto fisico (cavo hdmi, fibra ottica, 
radiofrequenza, infrarosso, ecc.)...quindi...
ios rappresenta dei segnali nel tempo potenzialmente campionati a diverse frequenze non multiple tra di loro...ios 
deve consentire una base tempo variabile a seconda delle esigenze dei segnali che trasporta...quindi le proprietà:
- num canali: num segnali distinti
  per ogni canale:
  - freq o intervallo di campionamento
  - dimensione del singolo campione in bit
  - standard di codifica utilizzato

NB nel singolo campione ci metterò generalemente tutto quello che riguarda quel flusso, ad es. nei segnali video ci 
metterò 3*8 bit relativi ai tre sottocanali rgb...potrei metterci anche l'audio a patto di definire uno standard di 
codifica audio/video, in realtà in genere l'audio lo metterò a parte...multichannel ovviamente, poi penserò anche 
a dei segnali "di campo" cioè audio e video "3d" cioè che consentono di ricreare il campo 3d audio/video...

NB ricordiamoci che fin dall'inizio dei discorsi teorici abbiamo deciso di fissarci sul mondo digitale ed anche qui 
sebbene trattare segnali puramente analogici avrebbe senso, lasciamo stare perchè nella pratica ormai ogni segnale 
viene digitalizzato!!! ...in futuro pensando a futuri device avanzati ed analogici o fuzzy il tutto dovrà essere 
rivisto...ma finchè non ci saranno elaboratori analogici o fuzzy, non ha senso (praticamente)...

ora rimane da decidere come comunicare le "info" dello stream...con un altro canale (il primo) ma bisogna 
dimensionarlo staticamente a priori o può essere dinamico? ...cioè fisso a priori un range di valori per le info o 
massima generalità?

il problema ora si sposta a come le sequenze e gli stream si correlano tra loro, in quanto i segnali sono stream...
e qui viene il bello poichè anche dei comandi possono essere considerati impacchettati in stream da cui è nata l'idea 
di rendere le chiamate di metodi (comandi) standardizzate e decentralizzate...ora il trasporto fisico può essere 
qualunque (seriale o parallelo), io devo cercare di astrarne e pensare allo stream come una sequenza infinita nella 
quale siano state muxate altre sequenze...così il problema si riduce a come entrare in synch con lo stream nel caso 
più generale possibile...

riepilogando:
ios deve permettere una comunicazione asincrona nel qual caso i pacchetti così come arrivano vengono processati, oltre 
ad una comunicazione sincrona dove ogni pacchetto arriva asincronamente ma con le info di "sincronizzazione" che li 
collocano in un punto preciso...sarà poi il gestore che li scarterà, li metterà in coda o li processa subito in base 
alle sue policy (se arrivati tardi allora scarta o introduci un delay, ecc.)...
NB questa synch è diversa dal synch del canale (vediamo dopo)!!!
ogni pacchetto afferisce ad un canale diverso così ogni canale può avere una base tempo qualunque e anche non 
correlata con gli altri canali...
ATTENZIONE!!! la velocità di trasferimento dello stream deve essere scelta tale da consentire che tutti i canali 
vengano trasmessi almeno alla propria velocità ed inoltre deve consentire un mux che anche se dinamico quando i 
canali hanno velocità non multiple tra loro, che in ogni momento non metta in competizione due canali (ad es se 
alcuni canali hanno campioni con un gran numero di bit potrebbe facilmente capitare che se metto un pacchetto di 
un certo canale poi un altro canale arriva in ritardo o viceversa), inoltre la velocità di trasferimento implica 
anche il delay minimo che impone il primo campione...
ios quindi dovrebbe essere legato al trasporto fisico il quale deve poter garantire una velocità minima, una certezza 
ed una correttezza del trasferimento...attualmente nei pc non esiste tutto ciò...è tutto asincrono e si spera che 
arrivi in tempo...per questo nacquero gli os real-time...ora è vero che io non posso garantire niente perchè in genere 
non starò su os real-time, ma lo gestisco lo stesso perchè sarà una parte importante che si riflette sul hw e sulle 
semplificazioni e standardizzazioni che implicherebbe in hw compliant con gli standard sunaptos...

quindi...
ios è una iface che connette uno o più srv che riceve o trasmette pacchetti tramite dei metodi appositi e viene 
gestita (velocità ecc.) con altri metodi...i pacchetti poi hanno le info specifiche al loro interno...NB ios può 
avere un buffer interno...
è chiaro che il modello è simile alle socket...va bene così!
il passo successivo è il networking di ios (nios)...cioè, ios rimane un flusso ma da dove arriva ed dove va, lo decido 
io trasparentemente...però devo considerare a più basso livello un qualcosa che può contenere diversi ios, cioè il 
trasporto (cavo, socket, rf, ecc.) ciò presuppone l'aggiunta in rx e tx di demux/mux per inserire pacchetti di diversi 
ios qui adotto una soluzione diversa dalle socket le quali sono caratterizzate da start-endpoint se invece do il 
nome al ios e poi decido indipendentemente chi possono essere connessi ho maggiore grado di libertà...cioè in tx/rx 
assegno degli ios-id locali a quel nios poi in rx/tx è il nios che associa agli id i corretti start-endpoint...simile 
al nat...NB un nios è anche un ios...il che significa che posso unire diversi nios in una nios di nios...questo 
permette delle reti grandi quanto mi pare, non c'è il limite del numero di indirizzi ip, ci sono solo i limiti del 
singolo trasporto fisico o virtuale che per sua natura potrà permettere solo un tot di ios contemporanei...ovviamente 
i nios prima di rimetterli in altri nios vanno spacchettati...qualcosa non torna nei nios di nios...verificare...
no torna tutto semplicemente nel passaggio da un nios ad un altro chi gestisce ciò rimappa gli id bilateralmente...
è ovvio che ad ogni start-endpoint ci sono dei controller hw o virtuali...l'unico vero problema è che questi id in 
genere dovrebbero essere riutilizzati quindi potenzialmente se i gestori non si comunicano correttamente sempre 
potrebbero esserci dei flussi indirizzati a destinatari sbagliati!!! ...risolvere...

signal o stream: flusso di dati unidirezionale asincrono o sincrono con caratteristiche (temporizzazione, dimensione 
campione e codifica) prefissate sul quale viaggiano sia pacchetti dati che pacchetti info su richiesta (???) o 
temporizzati...per i segnali sincroni serve la freq di campionamento mentre per i segnali asincroni il max-delay 
accettabile...lo stream si occupa di impacchettare e ricostruire l'informazione durante la trasmissione (tipo il tcp) 
ovvero che i pacchetti arrivino nell'ordine giusto (quando richiesto), mentre nel caso asincrono (oggetti di 
dimensioni anche molto variabili) è sicuramente richiesto che i pacchetti siano riordinati quando un oggetto è 
suddiviso in più pacchetti...
in pratica sullo stream passano "oggetti" che possono venire o meno raggruppati ed ordinati ogni oggetto viene 
impacchettato (anche se un oggetto entra in un pacchetto, mentre se ad un oggetto corrispondono più pacchetti il 
raggruppamento ed ordinamento è obbligato!) l'header del pacchetto contiene info sul pacchetto indispensabili allo 
spacchettamento, una volta spacchettato l'oggetto ha come header la codifica (cioè che cosa è, e come è memorizzato...
ad es. campione video rgb, campione audio pcm16, buffer di sequenza complessa, ecc.)...
NB queste codifiche devono essere più generiche possibile...pensare bene!!! ...ad esempio potrebbero essere: sequenza 
(ovvero ogni tipo di oggetto), update di substruttura di sequenza (ovvero pezzo di sequenza che è cambiato con 
associato un id per sapere a quale root seq fa riferimento...), campione completo di un flusso continuo (sincrono o 
asincrono es. audio/video/mouse/tastiera/ecc.) questo non è altro che una seq con dentro anche la codifica del 
campione...

ios: flusso di signal eventualmente bufferizzato generalmente full-duplex (i/o) dove ci possono essere più 
trasmittenti e più ricevitori connessi con mux e demux gestiti tali da consentire connessioni multi-tx vs multi-rx...
NB un ios è pronto così com'è per essere messo su un trasporto fisico tramite opportuni adc/dac senza alcuna 
gestione a livello fisico tranne per il transfer-rate/banda-passante che devono essere uguali o multipli del più 
veloce segnale che viaggia su ios (cioè il più veloce tra campionamento più rapido dei segnali sincroni ed il minimo 
tra i max-delay consentiti per i segnali asincroni...

un rx o tx può essere un nodo di una rete...in tal caso da una parte fa il demux e ogni signal lo muxa in altri ios...
quindi al di fuori ci sarà qualcuno che gli dice come fare queste mappature...un insieme di mappature costituisce un 
ios-path o instradamento o routing è chiaro che se qualcuno di questi ios ha come destinatario un nodo questo può 
servire a controllare il nodo cioè la rete viene utilizzata per gestire se stessa...ad es mi connetto al primo nodo 
e gli dico come conettersi ad altri nodi contigui, ora mi posso connettere a ciscuno di questi e così via...va 
solo pensato bene come fare per la sicurezza...



GUI
ho uno stream 2D in output (fornisco asincronamente dei frame completi eventualmente di risoluzioni variabili, ma 
l'update delle singole regioni viene gestito internamente, esternamente io fornisco il frame completo), come input 
posso connettere diversi stream derivanti da hw (mouse, tastiera, ecc.) oppure da qualsiasi altra fonte opportunamente 
filtrata con dei stream filters...i dati sono sempre degli input connessi dall'esterno o generati internamente dalla 
gui tracciando lo user input, oppure lanciando internamente dei srv.

un'app è una struttura che definisce degli input, degli output e dei comandi variabili dal contesto.

una gui è una mappatura degli in-out-commands di una app da/verso degli stream

definire una gui statica è facile...layouts, dimensioni percentuali, assolute, skin/css, ecc. il difficile è averla 
dinamica...come primo passo prevedo che il srv gui offra i metodi "destroy child x", "destroy all children of x" e 
"create gui_control/layout" così anche nello startup la creazione statica è solo un caso particolare di quella 
dinamica con la seq di comandi di creazione, poi nelle prop dei controlli creati allo start ci saranno specificate 
delle azioni su eventi che possono essere comandi su srv esterni oppure sull'istanza del srv gui che sta eseguendo 
la gui corrente (cioè è un caso particolare del caso generale di comandi su srv esterni...)

nella prima implementazione l'output è facile...lo si nasconde usando direttamentele api di sistema, più in la 
vedrò l'out come lo voglio io, perchè se non è integrato con l'hw/drivers o se non viene rivisto, potrebbe essere 
pesante aggiornare un frame intero ad ogni modifica.
per l'input è difficile perchè lo dovrei gestire io e non il sistema (come lo scroll e la rotellina del mouse sulla 
finestra attiva), ma per il momento faccio un mix e piano piano migro verso una soluzione migliore.

internamente istanzio degli oggetti dell'app o mi connetto a srv esterni già attivi e richiamando i loro metodi 
ottengo delle seq da utilizzare nella gui...i problemi sono due: (1) specificare i params da passare ai metodi 
e (2) come specificare i metodi da richiamare...perchè la gui è un file di testo, mentre le chiamate ai metodi si 
fanno da codice compilato...utilizzare i srv_stubs sarebbe una soluzione, ma non mi piace, un'altra soluzione 
è quella di utilizzare solo srv che implementano l'iface "command" e quindi il nome del metodo è un parametro 
del metodo "executeCommand". riguardo i params il problema è che posso dover utilizzare dei parametri statici 
e ritorna lo stesso problema, ma qui potrei specificare delle regole di parsing per i numeri e testo...

un layout è una proprietà di ogni controllo e l'ordine con cui vengono creati i suoi children, fa si che questi 
vengono mappati negli "slot" del particolare layout usato.
NB layout nelle successive versioni invece sarà distaccato come una proprietà della skin...però dovrò pensare 
a come gestire il disaccoppiamento in merito agli eventi cioè come i cambiamenti di stato/contesto si 
riflettono nelle skin...

una gui è solo una sequenza di comandi:
- define gui_control
- create gui_control
- execute srv_command
- connect srv_command
- destroy srv
- destroy gui_control
- destroy cildren of gui_control

il cuore di tutto è quindi la definizione di controllo con le sue proprietà (skin/layout/ecc...almeno nella prima 
release) i comandi accettati e la lista di comandi (vedi sopra) che esegue in base ai comandi richiamati o agli 
eventi verificatisi.

rivisitazione:
- gcontrol-def
- gcontrol-create
- gcontrol-destroy
- gcontrol-destroy-children
- gcontrol-input-map (gestisce il focus, ma permette anche di indirizzare diversi input a controlli diversi)
- gcontrol-update (senza params aggiorna tutti cioè impone la rilettura del content, altrimenti si può specificare 
il(i controllo/i o la var che i controlli usano come content...NB internamente gui tiene una lista di controlli 
associati a ciascuna var creata così ogni volta che ad ogni var cambia un valore (sia per assegnazione diretta che 
tramite metodi), è possibile direttamente aggiornare i controlli interessati...ma è comunque facoltativo perchè 
non è detto che voglio aggiornare tutti i controlli...NB per fare una cosa selettiva posso usare una var doppione)
- var-seq-set (declares a var if not existent and fill with a value...text to be parsed to create a seq at runtime)
- srv-load (load in the same process space, load in external or connect to external)
- srv-unload
- srv-execute (stores result in a defined variable, params are taken from defined variable)

NB le seq devono poter essere manipolate per adattare gli output dei vari srv alle esigenze della app...per 
far questo uso un srv esterno e non lo implemento in gui proprio per disaccoppiare le funzionalità e semplificare.
un giorno si useranno le tform e tutte le funzionalità proprie delle seq per la manipolazione (quando saranno 
implementate...)

NB le seq che ottengo dai srv sono statiche e non si aggiornano da sole (devo richiamare il metodo per ottenere la 
seq aggiornata) e questo è "by design" per il momento...se un giorno implementerò le seq che si connettono ed 
aggiornano da sole, allora poi rivedrò il tutto, ma in realtà le seq autoaggiornanti sono più problematiche da 
gestire e non portano reali benefici (meglio implementare gli event listener per i srv e cioè una connessione 
bilaterale) senza considerare che per creare queste seq dovrei progettare delle connessioni astratte e robuste 
per ogni tipo di trasporto...ma è una debolezza troppo forte per tutto il sistema perchè perdo il controllo sui 
dati e la certezza dei dati!!!

proposta di implementazione (vediamo se regge!)...i controlli non gestiscono eventi, ma offrono solo comandi...
gli eventi (mouse, tastiera, notifiche da srv presso cui si è registrati come listener, ecc.) vengono gestiti 
dal srv gui principale...una gui può essere usata come controllo all'interno di un'altra gui, pertanto ne 
deve avere tutte le caratteristiche...
un controllo fa il rendering di seq che possono essere interpretate come testo, numeri o immagini...NB tutti e 
tre vengono trasformati in immagini raw dalle api di conversione fornite da gui, per sorgenti complesse 
basta richiamare lo specifico renderer che chi ha definito la struttura complessa deve offrire...
NB per il momento non sono previsti esplicitamente i video che vanno gestiti internamente come seq di immagini. 
in futuro dovrò implementare la gestione degli stream (sia video che dati) nei quali posso racchiudere anche 
le seq autoaggiornanti che così hanno senso (cioè come stream asincrono)

gcontrol-def: la seq "content" viene passata come parametro alla creazione e se è una seq>1 allora crea un vettore 
di controlli uguali dove ogni sottoseq è il content di ogni controllo del vettore
- class name: button, listbox, ecc.
- size
- content type: num, text, image
- content style: dipende dal particolare controllo...può essere anche molto complesso! in futuro va disaccoppiato!
- commands num: numero dei comandi offerti
- commands: per ogni comando:
  - name
  - code: sequenza di comandi gui
NB notare l'assenza di logica econtrollo di flusso che risiede all'interno dei srv utilizzati, in gui l'unica 
variante di flusso sono gli eventi generati dallo user input!!!

il srv gui sia come sua config, che anche come app profile per override, definisce la mappatura degli input sui 
controlli o classi di controlli

altra rivisitazione totale...
una ui ha dati statici al suo interno e riceve dati dinamici come risposta dai metodi dei vari srv e dati 
dinamici dalla ui frutto dello user input (pensare se conviene ricondurlo a caso particolare del precedente). 
un controllo specifica il srv a cui deve essere associato (name=-1->srv del parent, name=0->nessun srv). 
un controllo offre diversi comandi a ciascuno dei quali viene associato un solo metodo del srv associato e 
diversi comandi per la ui...questo per tenere la logica nel codice dei srv ed usare le ui appunto solo come 
ui e non piene di codice!
i dati ottenuti dal metodo richiamato vanno eventualmente associati ad un altro controllo per il rendering.
per capire se tutto ciò funziona bisogna vedere come gestire il rendering dei dati dei srv e dell'input e 
come preparare i parametri da passare ai metodi.
ogni controllo ha una seq di comandi per l'evento "new data" ed una per "data update" (pensare bene...forse 
per il momento mi limito a new) 
(cfr. riga 223)
casistiche: partendo da una seq posso fare le seguenti distinzioni: azioni omogenee per tutti gli elem ed altre azioni 
per tutte le seq, oppure azioni distinte per index, poi posso avere azioni per seq null ed azioni per seq not-null
actions_seq: <on_null, on_not_null, elems_action, seq_action, index_actions_seq> dove ognuno di questi è un'azione 
eccetto index_actions_seq che è una sequenza di coppie <index, action> NB per tutti gli elem/seq non presenti nella 
index_actions_seq, vengono eseguite le actions elems_action e seq_action rispettivamente...
rimane da definire action e poi le action da bindare agli input

USER INTERFACE (rivisitazione totale):
- srv ui accetta come parametro una seq (ui_seq) che specifica la ui/applicazione
- ui_seq è composta di blocchi (seq) di definizioni di controlli (ui_elem) dove il primo viene creato automaticamente 
(ad es. come le finestre principali delle app...che NB può anche essere "invisibile" e fungere da "main"...)
- ui_elem è una seq che specifica:
  - class_name: nome univoco per tutta la ui (ogni istanza si diversifica per i dati e le skin assegnati)
  - data_events: seq di seq di comandi da eseguire per ogni evento sui dati di input (set-data, update-data, clear)
  (tra cui l'eventuale richiesta al srv ui di usare un determinato renderer sul dato x o sulla risorsa y...
  cioè gli posso chiedere il rendering di un testo, numero, immagine, video, suono, ecc. che provengono dai dati 
  o che provengono dalle risorse di "skinning"...)
  (NB chiedo cosa renderizzare, non come o dove!!! il come o dove dipendono dal srv di rendering utilizzato 
  e a quale output invia il rendering...questo mi offre quello che ho sempre voluto e cioè avendo definito 
  astrattamente un'app ui poi in automatico la posso usare su una gui 2D a video o su stream di rete, o su una 
  ui solo audio su casse o su stream di rete...)
  (NB la skin è diversa per ogni renderer, ma indipendente dal output)
  - srv_connection: none, lib, srv, use parent, use this ui instance (per gestire lo user input textbox ecc.)
  - srv_name
  - srv_commands: seq che binda i comandi offerti dal ui_elem a metodi del srv 
  (NB un solo metodo invocato per comando ui...per forzare il disaccoppiamento tra ui e codice!!!)
  - ui_commands: seq di seq di comandi ui da eseguire per ogni comando invocato
  (create, destroy, destroy-children, set-data (NB per l'update serve uno standard per le seq differenziali...
  ovvero le seq con dentro solo le differenze rispetto ad una precedente))
  - ui_commands_error: seq di seq di comandi ui da eseguire per ogni comando invocato quando il srv ritorna errore 
  (pensare se lo posso ricondurre al caso precedente, o se mi basta un solo comando per gestire l'errore...)
  - ui_properties: seq di prorietà (dimensioni, colore, layout, ecc...in realtà da spostare nelle skin)
NB rimane da capire come filtrare i dati per i data_events, per comporre i params per i metodi del srv e per 
estrapolare i dati da passare ad altri controlli...

riflessioni dopo un lungo periodo senza pensarci...
- al srv ui si passa la seq che definisce la ui (ui_seq), la ui_input e la ui_output e la ui_properties 
  (il fatto che alcuni device possano essere sia in che out, si astraggono separando le due cose)
- ui_seq contiene solo la logica, cioè come gli ui_elem interagiscono con l'i/o e come a loro volta gli ui_elem 
  interagiscono con i srv/comandi associati
- la ui_input mappa comandi di input in comandi ui (es. mouse_left_click -> ui_elem_select) e ad esempio qui 
  si implementa il multitapping. la ui_input specifica il srv di mapping e la conf da passargli. ui_input è 
  facoltativa e se non viene fornita, viene richiamata la ui_input di default per il sistema
- la ui_output mappa comandi ui in output (es. render_text -> console_type_text oppure audio_speech_text). 
  la ui_output specifica il srv di rendering e la conf da passargli. ui_output è facoltativa e se non viene 
  fornita, viene richiamata quella di default del sistema
- ui_properties specifica per un'intera classe di ui_elem o per uno specifico ui_elem proprietà utilizzate 
  dal renderer di output specificato. in pratica customizza il layout/skinning/lang dell'app...in pratica ui_seq 
  definisce la struttura (ed implicitamente il layout) che vengono renderizzare dai renderer con parametri di 
  default rispetto alle numerose possibilità offerte dal particolare renderer/output...NB ui_properties 
  non dovrebbe far parte di ui_output perchè le properties sono strettamente legate alla app mentre un 
  mapping dell'output può essere utilizzato da molte app
NB relativamente agli ui_elem bisogna tener presente che bisogna definire a priori (proprio come specifica della 
   iface) quali sono i comandi di input e di output poichè tali comandi sono utilizzati dai srv di input ed output
NB i comandi scambiati tra ui_elem ed i srv associati, dipendono dal particolare srv ed infatti la natura degli 
   ui_elem è proprio quella di mappare comandi di input in comandi verso srv ed output dai srv verso comandi 
   di output
NB classi ui_elem definite a priori sempre per l'output...riflettere se è necessario o se vanno considerati tutti 
   come elementi astratti e poi i comandi di rendering li differenziano...propendo per quest'ultima...
NB tutto questo disacoppiamento non mi deve far perdere di generalità, cioè devo sempre poter scrivere un srv 
   che fa il rendering direttamente, si gestisce i suoi eventi a basso livello ecc. così come le app odierne 
   tipo windows che gestisce gli eventi wm_paint ecc...in realtà non me ne frega niente!!!
quindi bisogna definire le cose di cui sopra e poi la ui_seq viene quasi automaticamente...

comandi di output generici:
- render_text
- render number

comandi di output specifici per alcuni output:
- render_image: può anche essere mappato come suono anche se non è pratico
- render_sound: può anche essere mappato come immagine anche se non è pratico
- render_video: può splittato e mappato su due device diversi (stereo e monitor) o intero (tv)
- render_3D_video: come sopra (3D->2D), o può essere mandato ad un generatore di ologrammi (3D->3D)
NB in generale per l'output andrebbero considerati i 5 sensi umani, poichè essendo l'utente un umano 
   i device out servono proprio per dare feedback all'utente quindi possono essere implementati anche 
   render_taste e render_smell...NB per il tatto c'è già il 3D al quale vanno aggiunte tutte le variabili 
   tattili non grafiche come ad esempio temperatura, umidità, vento, ecc.
NB andrebbero considerate anche pressione, gravità ecc. e qualunque cosa il corpo umano possa percepire...
NB viceversa input mappa i 5 sensi e qualunque cosa nell'universo in text/number
NB i comandi render_text/number/image/sound/video/3D vanno usati solo quando rappresentano i dati per il resto si 
usano le properties cioè si separano i dati dalla presentazione (skin). la differenziazione deriva dal fatto che 
le skin sono date a priori e fanno parte dell'app (anche se se ne possono scaricare altre, ecc.) mentre i 
dati derivano dai srv utilizzati. infatti il compito degli ui_elem è proprio quello di splittare output complessi 
derivanti dai srv e mapparli nei 5 sensi, cioè ui è la mappatura: user_interface = sequence -> human_senses
cioè la ui contestualizza i dati astratti conferendogli una particolare semantica
NB per i text/number va considerato che sono dati astratti che possono essere mappati teoricamente in ognuno dei 
5 sensi, quindi più i dati hanno senso come text/number e meglio è perchè mi lasciano libertà di scelta su 
come rappresentarli, quando invece voglio mappare text/number in uno dei 5 sensi per una migliore percezione 
(come ad es una percentuale in una barra di completamento, istogramma ecc.), questo va contemplato nelle 
properties proprio perchè mantenendo questo disaccoppiamento totale tra dati e presentazione, io comunque ho 
la massima portabilità dell'app su ogni output (a meno dei dati che per loro natura non sono text/number), 
scrivere le app è estremamente semplice e non richiede di scrivere la ui perchè viene automatica dalla 
logica della app e poi possono essere definite varie configurazioni di output che perfezionano l'esperienza 
di interazione (ad es usando audio/video come out, creo una skin multimediale che trasforma una semplice gui 
con solo controlli e bottoni con testo in un'app strabiliante)

NB per i comandi di input si presuppone che la ui permetta di accedere a tutti i dati gestiti dall'app per 
poterli de/selezionare, sempre la ui deve permettere di accedere a controlli che eseguano comandi sui dati 
selezionati, quindi un solo comando execute (senza parametri perchè cosa esguire e dato dal binding verso un srv) 
e comandi di de/selezione

comandi di input:
- execute: esegue il comando correntemente preparato e parametrizzato con le var interne del ui_elem
- select: seleziona il ui_elem
- deselect: deseleziona il ui_elem
- clear_selection:
- invert_selection:
- edit:
- clear:
- save_edit:
- cancel_edit:
- focus:
- highlight:
- create:
- destroy:
- show:
- hide:
- axis_??: coordinata percentuale (definire i valori standard...)
- character_??: "carattere" che può essere ascii, unicode ecc.
- value: numero
NB sono solo un esempio di tutti quelli che mi vengono in mente, le idee più chiare me le posso fare solo poi

ui_elem:
- contiene i dati (sequence)
- memorizza il suo stato (enabled, focused, editing, selected, ecc.)
- contiene il binding verso un srv/comando
- elabora i params per il srv/comando
- reagisce agli ui_input
- reagisce ai dati ritornati dal srv/comando

NB esempi per ribadire che non si perde in flessibilità o potenzialità:
- un image viewer come xnview che cacha l'immagine successiva e che renderizza progressivamente in 
alta qualità è fattibile così: per la cache renderizzo l'immagine successiva in un controllo 
doppione settato come hidden, poi quando vado avanti swappo la visibilità dei due controlli e 
sull'altro cacho; per la progressiva hq, è analogo in uno ingrandisco fast e sull'altro dopo un timer 
renderizzo hq...NB qui emerge il tema del timing/sincronizzazione/real-time/ecc. che deve essere gestito 
dalla user_interface o dai srv sottostanti? ...pensare!!!
- altro esempio è un player video: posso mandare i frames decodificati dal srv, oppure mando lo stream 
h264 al renderer il quale a sua volta lo manda alla scheda grafica per la decodifica hardware...
anche qui ci sono due controlli (e due output renderer) distinti e qui la logica del disaccoppiamento 
comincia a venire un po' meno perchè la configurazione di decoding nel secondo caso sta nel renderer 
e non nel srv player che ora fa solo da dispacciatore dello stream preso dal file, oppure ancora posso 
fornire al renderer l'id di connessione al srv di storage ed il renderer prende lo stream da solo...
insomma l'accesso alle funzionalità o accelerazioni hardware avanzate creano problemi in questo contesto, 
devo solo assicurarmi di non precludermi la possibilità di utilizzarle pur mantenendo un alto (se non totale) 
disaccoppiamento

NB il concetto di fondo è che ogni cosa può essere un input od un output che di solito vengono utilizzati dai 
vari srv nei loro formati standardizzati...però ogni input/output generico può essere collegato ad una ui a 
patto di avere un opportuno srv di mappatura che converta input/output da/per comandi ui (render, select, 
ecc.)

NB problema: l'interazione utente avviene tramite lo specifico output utilizzato, quindi non 
posso considerare che l'input arrivi direttamente alla struttura "ui_seq", ma deve essere tradotto 
dal modulo di uscita utilizzato, cioè anzichè in->ui->out => in->out->ui perchè l'utilizzo delle 
caratterestiche dello specifico out fanno parte dell'esperienza di interfaccia e non della logica che 
sta letteralmente "sotto" cioè vi si arriva dopo tutti i filtri!

quindi: gli ui_elem sono unità logiche di in e/o di out ("rendering"); quelli "out" sono definiti da una 
query sui dati forniti da un srv/comando; quelli "in" richiamano srv/comandi, controllano altre parti della 
ui e modificano delle variabili interne usate per comporre i parametri da inviare ai srv/comandi

piccolo riepilogo:
- ogni classe di output ha un predefinito set di comandi che accetta in ingresso (es. mouse_move, ecc.)
- ogni classe di input ha un predefinito set di comandi che invia in uscita (es. vk_esc, mouse_click, ecc.)
- si usa un srv mapper per tradurre i comandi input in comandi output (es. multitapping, joy2mouse, ecc.)
- nelle properties di output (skin) non si definiscono strutture o riferimenti a srv, ma ci sono solo 
definizioni di oggetti generalmente bindati ad id di ui_elem, ma possono esserci anche oggetti in più 
che controllano solo la ui e non hanno niente a che fare con la logica dell'app...quindi l'ui ha dei 
controlli strettamente legati a cosa fa l'app, mentre l'out può aggiungere dei controlli fini al 
controllo del contesto di output (es. i bottoni maximize/minimize o i bordi per ridimensionare)

NB quella che nel gergo comune chiamano ui per me è il modulo di output; dragndrop, mouse gestures, ecc. 
sono cose peculiari di alcuni specifici input/output e che esistono confinati nei rispettivi moduli

status e ui_elem:
nel caso di comandi è semplice: un elem richiama un srv/comando che ritorna un risultato che viene 
bindato ad un altro elem.
in generale nelle app non ci interessa un "log" di cosa è accaduto (come l'esempio precedente), ma un 
monitoring dello status di operazioni lunghe in corso EEEEEE interruzioni di operazioni per chiedere 
all'utente cosa fare in determinate casi (es. il file X è di sola lettura, cancellare? si/no/cancel)...
quindi ho due "problemi" da risolvere: "status monitoring" (status) e "user intervention" (uiv)...
entrambi i problemi implicano che il chiamante (ui_elem) sia in ascolto dal srv chiamato; ciò è vero 
particolarmente per uiv perchè per status potrei pensare anche ad una scheduled call. 
il chiamante-listener non mi piace come soluzione perchè implica un notevole incremento di complessità 
del codice del chiamante e la gestione bidirezionale delle connessioni tra srv e conseguentemente 
anche maggiore complessità del modello di sicurezza.
per lo status è semplice perchè lancio il srv che ritorna subito e subito dopo richiamo il 
comando bloccante del srv in loop per aggiornamenti sullo status...ma NB io posso mettere la 
rihiesta di uiv nello status (con associato un id)...il srv può essere progettato con uiv bloccanti 
e quindi rimane una solo uiv in sospeso che blocca tutto, oppure le uiv posso essere messe in coda 
ed intanto si prosegue con il resto...in realtà quello che mi serve è solo un paradigma in c++ per 
semplificare ed irrobustire il codice nel srv poichè deve gestire thread e sincronizzazione.

NB la soluzione di cui sopra per evitare la connessione bidirezionale complica il codice del chiamante 
e del srv ed è potenzialmente più lenta (per via dello status e uiv nello stesso loop del chiamante, 
ma se li splitto in due thread o elem, la cosa è risolta), ma implica anche una gestione avanzata delle 
uiv...in realtà con un buon paradigma risolvo tutto perchè "monitorare uno status" implica comunque in 
ogni soluzione l'esistenza di un apposito thread, per cui rendendo autonomo uiv rispetto a status 
rimane solo il loop di uiv...NB è importante evitare che il srv abbia una connessione o un puntatore al 
chiamante perchè se il srv fosse malevolo dal puntatore tramite dynamic_cast può risalire alla classe 
totale e rubare informazioni o fare danni, tramite connessione inversa può intrufolarsi anche in maniera 
più pericolosa aggirando la sicurezza...per cui niente connessioni bilaterali!!!

riepilogando "status monitoring" (status) e "user intervention" (uiv):
- il chiamante richiama lo start di un srv che ritorna subito
- il chiamante tramite paradigma lancia il metodo/thread di "status monitoring"
- il chiamante fa un loop sul metodo bloccante del srv per rispondere ad uiv in sospeso
- alternativamente il chiamante tramite paradigma può far partire un metodo/thread per la gestione 
real-time della coda delle uiv (nel caso il srv sia abilitato alle uiv non bloccanti)

NB quanto sopra si mappa semplicemente negli ui_elem

problemi da affrontare ora:
- creazione dinamica di ui_elem in base ad uno status dalla struttura non costante
- input utente text/number
- input raw?
- creazione di params per lanciare i srv
- diversi focus per diversi ui_elem in base ad una classificazione logica non legata ad "input"

considerazioni:
- un elem contiene o un pezzo di status o un qualcosa ricevuto in input
- ui deve avere un linguaggio per splittare seq (vedi sopra) e per comporre seq (per comporre params)
- i dati di input non utente (file, streams, ecc.) vengono gestiti direttamente dal srv non passano 
per la ui a meno che non serva una rappresentazione di essi (es. audio editor) replicati come status
- il piping input/output tra vari srv per creare una catena di elaborazione viene configurata 
tramite ui, ma è realizzata tramite appositi srv di streaming/storage/seq-composing

riepilogando:
- alcuni ui_elem eseguono comandi ui (es un bottone per creare una nuova tab vuota -> il ui_elem "tab" 
alla sua creazione invoca il srv per creare un nuovo documento vuoto e lo binda alla tab)
- alcuni ui_elem immagazzinano dati immessi dall'utente
- un ui_elem genera dei params componendo i dati immessi insieme ad altri predefiniti
- un ui_elem chiama lo start di un srv passandogli i params di cui sopra e crea i due ui_elem qui sotto
- un ui_elem che loopa sullo status
- un ui_elem (eventualmente avviato hidden) che si attiva se ci sono uiv
- ci sono uiv invocate dai srv, ma ci sono pure uiv relative alla ui (ad es. chiudo un doc e chiedo 
se salvare i cambiamenti)
- analogamente c'è uno status della ui (es. dati editati e non salvati, il ui_elem ??? nascosto, ecc.)

quindi:
- diversi ui_elem per raccogliere dati utente da utilizzare per uno o più srv contemporaneamente
- tanti ui_elem quanti sono i comandi di un srv da esporre all'utente che si occupano anche di 
comporre i params relativi e che bindano il relativo risultato (res) ad un ui_elem che si occuperà 
di trattarlo come fosse uno status
- per ogni srv un ui_elem per lo status ed un ui_elem per la uiv

NB idea per semplificare la composizione dei params: gli ui_elem utente per ogni srv a cui devono 
dare i dati, hanno una seq (quindi seq di seq) che dice a quale ui_elem (di tipo comando) mandare i 
dati e le coordinate nella seq params...il ui_elem_comando quando li immette nella seq params (che 
come ogni seq inizializza a zero laddove manchi la struttura per arrivare alle coord specificate...
verificare che funzioni! latrimenti devo specificare come inizializzare la struttura di params)

NB un ui_elem utente può anche essere un render di un pezzo di status/res (es. file name in un 
file browser, se lo edito è un input per il rename, in generale mostra il res del comando dir)
...no è meglio separare gli in da out

facciamo il punto:
- nella ui si comincia con una seq per ogni srv utilizzato:
  - nome srv, tipo connessione ecc. (conf della connessione)
  - per ogni cmd esposto il bind: id_cmd -> ui_elem_cmd_id + ui_elem_uiv_id + ui_elem_status_id
    (es. 01 -> main.toolbar.rename + main.uiv.rename + main.status.rename)
- poi ci sono le def degli ui_elem per lo user input
- poi la struttura

NB i nomi/id così fatti creano un struttura logica che implica che il default output renderer, 
metterà prima la toolbar, poi gli uiv e poi gli status

...non quadra, ripensare bene...
allora le varie seq params inizializzate con i valori di default ed i parametri costanti non 
accessibili all'utente o alla config per scelta dell'app,vengono serializzati in file ed in 
ui indico il nome del file da caricare che genera tutta la struttura necessaria per params

gli ui_elem_utente hanno associati il tipo number/text ed il "wide" del valore (forse non 
serve...non ricordo bene come ho implementato le seq)

rivediamo:
ui è una seq di funzioni di cui solo la prima viene eseguita in automatico ed alla cui fine si 
mette il comando wait_events. ogni funzione è una seq di istruzioni. la ricchezza e complessità 
del set di istruzioni disponibile, permette di evolvere ui dall'implementazione più semplice 
fino alla più complessa, gradualmente. in ui si creano/distruggono/gestiscono gli oggetti 
ui_elem che interagiscono col modulo output

gli ui_elem associano ai comandi ui_input delle funzioni (definite nel ui_elem alla sua creazione)

forse la cosa migliore è cominiciare con un solo srv/app e poi cercare di generalizzare...
quindi:
- una ui per un solo srv (che racciude tutta l'app)
- per ogni comando esposto, si specificano gli ui_execute, ui_status e uiv (ed il file params 
  con i valori non esposti nominato in un modo standard univoco, quindi non serve specificarlo)
- ui_execute non richiede ulteriori specifiche
- ui_status ed uiv sono definiti con un liguaggio specifico

NB ideona!!! per ovviare al problema del rendering hw tipo videoplayer, ecc. invece di creare un 
controllo e gli dico di prendere l'out del srv, io tra i params del srv gli specifico come 
pipe di output quella di ui_out...così si sfrutta pure l'accelerazione hw senza troppi 
problemi...verificare che il ragionamento fili...

il piping in-out tra srv è il fulcro di tutto il sistema, il fatto che poi un certo in-out li 
uso nell'ambito di una ui è un caso particolare...quindi in una ui out viene usato come ui ed 
anche come pipe-out per sfruttare l'accelerazione

NB forse devo passare ad una diversa concezione, forse veramente mi serve la comunicazione bilaterale 
perchè un srv fornisce i dati appena ce li ha disponibili, non è che li deve immagazzinare finchè 
qualcuno si degna di prenderli...quindi torniamo al concetto di stream per tutto, anche lo status...
però così forza il chiamante a dover gestire tutto l'out...pensare meglio! ...magari tutte e due le 
possibilità...

params sono cose abbastanza fisse, possono anche avere struttura variabile, ma fondamentalmente 
sono "un insieme finito" e mi serve unicamente per configurare il srv e vanno inviati una sola 
volta, mentre l'input è una cosa estremamente variabile, "non prevedibile", continua e potenzialmente 
infinita, cioè uno "stream" e rappresentano concettualmente "dati"...
quindi:
- params: limited-one-time-data, determinano come elaborare l'input ai params non corrisponde un output
- input/output: unlimited-continous-streaming-data, vengono elaborati (secondo i params) per 
produrre un output

cioè out=f(in) e f=g(params), con f=stream_function e g=point_function

differenza tra funzione e stream-processor è che per le funzioni c'è una corrispondenza sincrona tra 
input ed output, mentre per gli stream io fornisco input asincronamente e poi asincronamente e se 
voglio prendo gli output...NB se serve sincronia per gli stream questa deve essere contemplata 
all'interno dello stream, oppure previsto da timers nello stream processor (con almeno un delay 
tra in e out), ma in ogni caso non c'è la corrispondenza come nella chiamata di funzioni.

lo user input viene tradotto dalla ui in uno input stream di comandi per uno specifico srv.

riflessioni: un srv prende passivamente uno stream in e fornisce un stream out, fornisce lo 
status, chiede user intervention (uiv), accetta parametri, accetta comandi, offre funzioni, 
interagisce con altri srv...
...da quanto sopra, si evincono le seguenti similitudini: params/config sono inseribili come 
comandi, i comandi sono assimilabili ad un stream di input...aggregare tutto insieme crea solo 
casino ed overhead inutile, bisogna separare con criterio ed intelligenza...probabilmente così: 
config/params iniziali presi internamente da srv dallo storage di sistema per la config, 
un metodo per passare comandi tra cui "set params" e "set config" ed a parte un metodo per lo 
streaming di dati in input...NB è corretto perchè ai comandi non corrisponde un output, bensì 
agiscono internamente al srv variandone lo stato e quindi come viene elaborato l'input...NB non 
sono comandi in senso classico infatti a quelli in genere corrisponde un output! infatti sono 
più assimilabili allo user input

riflessioni:
- se l'input passato e l'output associato sono scorrelati da tutti gli altri in ed out allora 
il modello da utilizzare è la chiamata di funzione
- se l'input passato è un pezzo di un input più grande e l'output pure viene fornito a pezzi e 
l'out complessivo dipende da tutto l'in complessivo (es. codifica video a doppia passata) allora 
il modello da utilizzare è quello delle streamed read/write indipendenti
- in entrambi i casi servono altri thread per gestire status, uiv ed anche comandi (anche per la 
chiamata di funzione che può chiedere sia intervento all'utente, che impiegare molto tempo e quindi 
va monitorata con lo status, oppure va inviato un comando di interrupt)
- il vero problema è che uno stream processor proprio per sua natura implica un buffering di in ed 
out e quindi la gestione di tali buffer che devono garantire (entro certi limiti) la non perdita 
di pacchetti in o out, il buffering è necessario perchè in una catena di stream processors, il più 
lento non è sempre lo stesso ma è variabile a causa degli input istantanei che possono richiedere 
più o meno potenza di calcolo (NB la velocità di una catena è data dal processore più lento!), 
quindi se non ci fosse buffering tutti i processor starebbero sempre in attesa del più lento, 
mentre col buffering hanno sempre dati da processare...NB il tutto va considerato in "clouding", 
cioè i processors possono stare su pc distribuiti in rete, o sullo stesso pc ma diversi core, ecc.
- io vorrei che il buffering non fosse gestito dallo specifico srv, ma da backends messi prima e 
dopo, ma non sono sicuro sia fattibile...o almeno è facile bufferizzare l'input dall'esterno, 
ma l'output? ...dovrei prevedere un buffer veloce e il processor dovrebbe bloccarsi se c'è un 
pacchetto in out non ancora preso...forse così regge...
- in ogni caso il srv, anche nel caso "funzione", ha al suo interno "molta" sincronizzazione 
(semafori, wait, ecc.) che per sua natura è "pericolosa"...l'alternativa implica la comunicazione 
bidirezionale e quindi un'interfaccia ulteriore che deve implementare il chiamante, oltre al 
puntatore che va passato al srv o al suo stub e gestito da lui in sua vece...tutto ciò implica 
però anche che l'affidabilità del srv dipende anche dal suo chiamante...pessima cosa! ...e poi 
almeno le read andrebbero sincronizzate, per cui mi conviene usare il modello unidirezionale 
sincronizzato e progettare bene la classe base dei srv con tutta la sincronizzazione al suo 
interno...
- un srv ha metodi singoli per ogni cosa...cioè un solo metodo read, un solo write ed un solo 
"function"...cioè per mettere a disposizione molte funzioni queste sono un parametro del metodo 
function...questo perchè in c++ non posso sapere a runtime quanti metodi, quali e che nome hanno 
e non avrei un'interfaccia unica...stessa cosa per read/write: il srv può implementare più di 
un processore di stream, per accedervi basta scrivere nel canale corispondente...cioè read e 
write trattano in e out multicanale, dove ogni canale può anche essere processato diversamente...
- per i comandi invece potrei fare così: quelli generici e di sicura utilità possono essere 
esplicitati dall'interfaccia come metodi a se e poi un metodo unico per i comandi specifici del 
srv...
- stabilito tutto ciò, per la ui il tutto si riduce a due problemi: come comporre parametri da 
inviare ai metodi e come splittare e trattare ciò che i metodi restituiscono...ovviamente il 
tutto va specializzato a seconda del metodo...ovviamente quelli problematici sono read/write e 
function perchè le strutture dati sono estremamente variabili...



-------------------
punti fermi:
- una ui serve per interfacciare l'utente con un srv ed i suoi comandi, quindi:
  - una ui riceve dall'utente dei parametri per un srv-cmd
  - una ui riceve dall'utente lo start del srv-cmd di cui sopra con i params impostati
  - una ui fornisce prima (pronto), durante (in corso %) e dopo (finito) lo status del cmd
  - una ui fornisce notifica della necessità di ulteriore input utente e lo recepisce
  - una ui riorganizza l'output in modo da facilitarne la fruizione
- una ui interfaccia verso uno ed un solo srv
- il piping tra più srv viene ottenuto tramite scripting/compiling ed in ogni caso il risultato 
  è esso stesso riconducibile ad un srv...questo poi può essere usato in una ui...cioè ho 
  ulteriormente disaccoppiato i problemi...questo layering non dovrebbe inficiare il riutilizzo 
  di piccoli moduli di ui (es. listbox per i file, il open file dialog, ecc.), ma bisogna pensarci
- per i srv va creato un paradigma dove per ogni comando offerto ci sono i seguenti metodi:
  - start: ritorna subito dopo l'inizializzazione e l'avvio del thread
  - start: ritorna solo dopo l'interruzione del thread
  - status: ritorna la seq complessa con tutto lo status o solo gli update (a scelta) 
    può funzionare da "result" nel caso sia bloccante durante tutta l'esecuzione 
    (a richiesta può essere: bloccante fino alla prima modifica, 
    ritorna subito con tutto lo status, 
    o timed cioè ritorna dopo un timer...comodo per il chiamante, per il srv è gestito dal paradigma)
  - user_choice (uiv): con le modalità bloccante/subito/timed fornisce le eventuali domande ed eventuali 
    vincoli di risposta (internazionalizzati! quindi sia domanda che possibili risposte sono id 
    che vengono tradotti nel linguaggio selezionato dal modulo di skinning)
  - stream_in: accetta i pacchetti dello stream in ingresso da processare
  - stream_out: ritorna i pacchetti dello stream in uscita processato
- una ui è composta così: ui_in -> ui_out <-> ui_srv
- ui_srv:
  - riceve ui_cmd da ui_out generati dall'input utente elaborato da ui_in e poi da ui_out
  - definisce un albero logico di layout dove vengono distribuiti i vari srv-cmd, status, uiv e 
    ui_elem
  - la struttura è dinamica sia per comandi ui di determinati ui_elem, sia per status e uiv
- ui_in: traduce gli input (implementando, tra le altre cose, gestures, hotkeys, multitapping, ecc.)
- ui_out:
  - usa molti ui_input che filtra per l'utilizzo avanzato dei controlli che offre
  - genera ui_cmd verso ui_srv
  - genera la ui con impostazioni di default
-------------------



srv prototype:
- constructor
- destructor
- stream_in_put: accepts multichannel data packet to process 
  (rules and checks to avoid buffer overruns, blocked until output is taken)
- stream_out_get: returns multichannel data packet processed 
  (blocked until data available, double buffered?)
- stream_cmd o meglio solo cmd: executes a stream command (set config, reset, start, stop, etc.)
- function: executes a function specified in params and returns the function result
- status: returns the status or part of it by means of how specified by params
- user_intervention: returns choices the user has to take in order to complete the execution 
of a function or the processing of a stream packet

NB così ho creato un prototipo uguale per ogni srv, quindi gli stub sono universali!!! 
questo è un risultato notevole in quanto ad ottimizzazione ed elimina le interfacce a livello 
di compilatore...il che aumenta la flessibilità, ma responsabilizza totalmente il loader...
a livello di codice la garanzia che uno sviluppatore implementi correttamente un'interfaccia, 
non c'è mai! ...quindi da questo punto di vista, non si perde nulla...pur rimanendo un problema 
vero che probabilmente si risolve solo con il feedback degli utenti in base al quale i srv che 
non rispettano le interfacce implementate, vengono blacklistati!!!

rimangono da definire le seguenti cose:
- linguaggio di de/composizione delle strutture dati
- binding di strutture dati con controlli ui (testo, numeri, immagini, ecc.)
- modularizzazione delle ui...

NB le strutture dati utilizzate dai controlli ui dipendono da cosa accetta il controllo, quindi 
ad es. un'immagine basta che la decompongo da tutto il resto dell'output che mi è arrivato (altri 
canali, metadati, ecc.) e mando tutto e solo il buffer che rappresenta l'immagine al controllo 
che accetta immagini...ovviamente il buffer deve essere codificato secondo uno standard riconoscibile 
dal controllo...

NB per la modularizzazione delle ui ogni modulo deve avere degli in e degli out, ma qui si apre un 
mondo...ed NB la modularizzazione delle ui è antagonista del linguaggio di scripting per creare 
un nuovo srv dalla composizione di più srv, perchè implica che la ui va sempre riscritta tutta!!! 
e questo lo devo evitare, quindi devo pensare alla modularizzazione della ui...
ma è un discorso che posso rimandare in una certa misura e per ora mi concentro sul uno a uno...

NB le ui possono istanziare loro dei srv (applicazioni classiche) o possono connettersi a srv già 
in esecuzione (ui per servizi classici)

linguaggio di de/composizione:
- le seq primarie si chiamano: p1, r1, p2, r2, p3, r3, ... , p9, r9 (max 9 metodi...vedi dopo...)
  dove il numero ordinale indica il metodo del srv (1=stream_in_put, ecc.) e p indica che è la 
  seq di params, r che è quella risultato
- i numeri e le seq contenuti in esse si indicano a partire da quelle principali indicando le 
  coordinate e specificando se si tratta di seq o number
- i numeri e le seq secondari possono essere utilizzati per esteso oppure possono essere assegnati 
  a delle variabili (forse non è necessario l'uso delle variabili...)
- la sintassi per le cose di cui sopra è la seguente:
  + seq secondarie: p1:1,20,5;n.   r2:3,9,11;s.
  + dichiarazione variabili: s myseqname.   n mynumbername.
  + assegnazione: 
    mynumbername<r1:1,20,5;n.
    myseqname<r2:3,9,11;s.
    p3:6,9,12<myuielemname;s.
    p3:5,16<myuielemname:2,5;n.
  + alias: mynumbername=p1:1,20,5;n.   myseqname=r2:3,9,11;s.

...in realtà il linguaggio è da rivedere nell'ottica completa...

- il srv è un codice che fa delle cose e viene usato da altro codice
- ui è un codice che interfaccia in modo generico un srv in modo da renderlo più usabile
- xui è un codice che interfaccia in maniera estesa e specifica per gli in out (grafica, audio, ecc.) 
  una ui/srv con l'interazione utente
NB in pratica: srv=codice, ui=astrazione, xui=implementazione
una volta definita una ui, posso anche generare automaticamente delle xui specifiche che poi posso 
personalizzare o migliorare...
quindi con ui implemento l'usabilità semplificando l'accesso al srv e con xui miglioro l'usabilità 
sfruttando le potenzialità derivanti dalla spefica interfaccia utilizzata (grafica, audio, gestures, ecc.)

NB in ui devo mettere le cose astratte (active, unactive, order, create, ecc.) in xui quelle specifiche 
(highlight, z-order, focus, keyb-focus, mouse-focus, ecc.)

NB la creazione dei params avviene con controlli predefiniti per la parte fissa e con controlli generati 
da altri controlli (tipo "add element") per la parte dinamica...quindi assegnazioni predefinite, più 
iterazione in un container di controlli

NB la gestione dei result avviene con binding verso controlli predefiniti per la parte fissa più una 
iterazione complessa per la parte variabile, dove la struttura e/o il contenuto generano/distruggono 
controlli...

NB ui definisce l'interazione col srv e la struttura dei controlli con relativo binding, MA i controlli 
non possono modificare i dati bindati da ui (che non è un'implementazione è solo una definizione!), è 
xui responsabile di completare il quadro permettendo con la sua implementazione di modificare i dati

NB ui definisce le classi di controlli (es listbox_filename, execute_button, ecc.), ma è xui che li 
istanzia e nella sua specificità applica delle proprietà aggiuntive (es colore, dimensioni, editabile, ecc.)

ui:
- lista dei srv utilizzabili
- lista delle classi di controlli utilizzabili
- funzione main (lista di azioni in startup)
- funzioni definite dall'utente

azioni possibili:
- chiamata di funzione con argomento (parte di seq, classe/nome/id di controlli, ecc.)
- creazione controllo (anche come child di un altro che fa da container): classe, nome, id-ordinale (seq di controlli)
- distruzione controllo (e relativi children)
- istanziazione srv
- distruzione srv
- chiamata metodo srv ed assegnazione result
- istanziazione seq
- distruzione seq
- assegnazione seq/number->controllo (dove seq/number sono riferiti tramite sintassi "seqname:1,20,5;n.")
- assegnazione controllo->seq/number
- iterazioni su una seq (da definire!!!) o controlli

xui:
- lista xui utilizzabili
- associazione classi controlli ui a specifici renderer delle xui utilizzate
- specificare eventi xui ed azioni xui associate

IDEONA!!! ma anzichè creare un linguaggi di scripting che poi devo interpretare o compilare con un mio 
codice, basta che definisco una interfaccia c++ che ui deve rispettare...e la compilo in c++!!!

un compito di ui è quello di ristrutturare tutti gli output di srv in una seq di seq dove ci sono solo i dati 
che si vogliono offrire all'utente (senza tutte le info "inutili" che il srv produce per completezza) più 
un typing/format per dire ogni dato come va rappresentato (numero, testo, immagine, video, percentuale, data, ecc.) 
...quindi: srv-out(status, stream, func, uiv, ecc.) -> filtro dati + ristrutturazione + typing/format = ui-out

srv=codice e dati di basso livello (engineering, developer)
ui=codice e dati di medio livello (experienced user, sunday developer)
xui=codice e dati di alto livello (dumb user, graphic designer)

domanda: e lo status della ui (selected, focused, ecc.)? e l'input?
una possibile soluzione sarebbe di far si che ogni specifica ui offre queste cose come comandi accessibili da xui 
tramite il metodo "cmd" di quella ui...in pratica ogni ui offre quello che gli pare...poi col tempo vedrò se 
posso generalizzare ed uniformare...insieme al fatto delle ui compilate mi sembra un buon compromesso per andare avanti...

quindi ui offre lo status ristrutturando e filtrando lo status di srv, con cmd/function offre i suoi comandi specifici 
(move_up, select, ecc.) tra cui "get_typing_and_format" che ritorna la stessa struttura di status/uiv/ecc ma con 
il "type/format" anzichè i dati...NB xui generalmente richiede ad ui una sottoparte dello status (quella che gli 
interessa in quel dato momento), ma per il typing/format credo che convenga dare sempre tutto (che lo si chiede solo 
all'avvio della xui), ma posso anche prevedere di chiederne solo una sottoparte (magari per xui immense, il typing 
può da solo occupare più memoria di quella disponibile)...ovviamente ritorna tutta la struttura con puntatori nulli 
nei rami che non serve approfondire perchè il nodo iniziale deve essere sempre lo stesso!!!
ui ritorna lo stesso uiv del srv ovviamente...

fin qui è tutto molto bello...ma ancora non ho definito come avviene l'input di dati "veri"...in realtà non mi 
conviene complicarmi troppo la vita perchè se ci penso bene basta usare i comandi, non perdo di generalità e non 
limito in alcun modo le funzionalità almeno rispetto alle gui delle app tradizionali...

NB i metodi cmd e function dell'interfaccia srv è meglio accorparli ed usare solo "function" (o cambiargli nome) 
principalmente perchè è ridondante e poi se cmd non ritorna niente avrei l'incongruenza di dover usare cmd per 
impostare la config e function per leggerla...sarebbe confusionario!!!

-------------------

srv prototype:
- constructor
- destructor
- stream_in_put
- stream_out_get
- function
- status
- user_intervention

-------------------

ui:
- constructor
- destructor
- stream_in_put (not used)
- stream_out_get (not used)
- function: comandi specifici della ui + almeno "get_types" (sia di status che di uiv)
- status: può essere lo stesso del srv interfacciato o una sua ristrutturazione
- user_intervention: lo stesso del srv interfacciato

NB uiv è uno scambio di id che fanno riferimento a significati specificati dalla doc del srv...questi id 
vengono tradotti in messaggi verso l'utente dalla specifica xui utilizzata tramite le risorse specificate 
nella "skin"...cioè: per la xui grafica ci saranno stringhe (una skin per ogni linguaggio messo a disposizione) 
ed immagini associate a ciascun id, per la xui audio ci saranno stringhe e file audio associati a ciascun id...
ovviamente xui e poi ui rispondono alle uiv con id associati alle scelta fatta dall'utente, quindi al srv 
arriva solo l'id...cioè tutta la semantica del linguaggio utilizzato e tutta la specificità dell'interazione 
utente viene astratta con id e rimane fuori dai srv...QUINDI NEI SRV NON ESISTERANNO MAI PIù STRINGHE!!! 
questa è una vera rivoluzione!!! ...nei srv solo codice (in c++) universale!!!

-------------------

xui:
ogni xui di uno specifico srv si deve occupare della skin, dell'internazionalizzazione, ecc. che in generale 
sono specifici di quel srv, poi si può prevedere che alcune "resources" siano prese da un repository 
generico...ad es. immagini e messaggi utilizzati di frequente è stupido replicarli ogni volta!
in pratica stringhe, immagini, suoni, ecc. sono risorse di quella app per quella xui, quindi ad es. per una 
gui l'internazionalizzazione è fatta con stringhe, per una xui audio con file audio...quindi il linguaggio è 
una risorsa della specifica xui anche se il contenuto deriva dal srv che si utilizza...

xui ha un'interfaccia unica per gli input, ma per gli output dipende dal tipo...cioè ogni xui ha un suo standard 
output...NB mentre ogni ui è specifica del srv che interfaccia, di srv che implementano l'interfaccia xui ce ne 
sono diverse classi (differenziate dallo standard di output) scelta una classe di xui, poi si scrive il config 
file che implementa l'app di un certa coppia di srv+ui...

il "main" di una xui comincia definendo la ui da caricare e poi una serie di comandi xui...ora tutto sta nel 
definire i possibili comandi xui (almeno per la xui grafica)...anche qui potrei usare l'escamotage di non 
definire un metalinguaggio, ma utilizzare direttamente codice c++...quello che potrei fare è creare una o più 
funzioni/classi che offrano dei controlli basilari astraendo dal os utilizzato e poi da questi creare tutti i 
controlli possibili ed immaginabili, partendo ovviamente da quelli minimali richiesti da una xui...così facendo 
posso sfruttare al massimo le potenzialità degli out perchè la parte xui sarebbe ancora terra selvaggia (solo 
ui e srv sono universali, ordinati e perfetti), infatti ad esempio nella xui grafica posso aggiungere un 
controllo opengl 3d anche se con i controlli base non lo avrei potuto ottenere...così il mondo xui sarebbe 
selvaggio ma confinato da tutto il resto...questo per il momento mi potrebbe bastare...

-------------------

srv + ui + xui, senza metalinguaggi e compilati in c++...ecco cosa ho ottenuto:
- codice srv completamente disaccoppiato, universale, senza stringhe, linguaggio umano, ecc.
- ui e xui possono essere implementate subito senza compromettere in alcun modo gli intenti di partenza
- ui e xui rimangono ognuna confinate nel loro mondo selvaggio, ma garantiscono il disaccoppiamento 
  grazie all'interfaccia e pure se i comandi sono selvaggi, un giorno potrò standardizzare tutto!
- ui si occupa di ristrutturare dati ed input utente E NAVIGARE TRA I DATI, SELEZIONI, COMANDI E FUNZIONI!
- xui si occupa di renderizzare nel modo più opportuno, "cool", funzionale ed ergonomico  dati, input ed output 
  e di tradurre lo user input in comandi e dati da passare alla ui
- il rendering di xui astrae dallo specifico device, per cui il suo out è uno stream di cui è solo definito il formato
- gli input di xui astraggono dallo specifica device, ma gli arrivano in input da streams specificamente formattati
- si possono creare innumerevoli srv di input con diversi formati sia associati a device di input che ad input virtuali
- serve poi un srv che permetta di tradurre gli input di una tipologia ad un'altra (es 2 assi analogici -> 4 freccie)

-------------------

per implementare status ed uiv in service posso stabilire a priori degli id (es 0, 1, oppure 1001, 1002) e trattarle come dei 
metodi ordinari (cioè richiamati tramite srv->f(id, params)). tali metodi possono così essere facoltativi...non è la soluzione 
ottimale, bisogna trovare un modello migliore.

