loader è un srv come gli altri tranne per il fatto che è l'unico che può interfacciarsi interamente 
con il os che l'ha lanciato e quindi l'unico che può lanciare altri processi.

anzi no, anche altri srv di sistema sono ad accesso full come loader (storage, config, log, etc.)
per ciascuno di questi si crea un exe specifico e con un md5 diverso e con nome diverso, in modo 
che tramite os (linux, mac, windows) posso dare a questi i diritti necessari e 
negare tutto a "client.exe" che genera tutti i srv "normali"

gli altri srv possono caricare solo le lib di sunaptos e nient'altro -> nb l'uso della rete è implicitamente 
concesso (purtroppo) perchè è necessaria a "client.exe" (che ha lanciato srv) per fornire la ipc

kernelloader (o remoteloader) al suo avvio lancia tutti i srv a lui funzionali come config, storage, ecc. 
poi lancia bootloader. in particolare config è importante perchè dice le regole con le quali decidere se 
i nuovi srv devono essere servizi o libs ad es. config deve essere un servizio, storage "non è necessario"...

TODO: pensare ed implementare l'architettura a supporto dei servizi in senso stretto, 
la gestione delle eccezioni ed errori attraverso le chiamate tra srv sia via ipc che tramite chiamata diretta

forse per implementare i servizi potrebbe bastare (o comunque può essere il primo passo) fare sì che 
per una stessa istanza di un srv vengano istanziati diversi canali ipc per ogni richiedente e poi è il 
particolare srv che gestisce le cose come un servizio...poi magari questo comportamento viene pensato come 
formalizzarlo ed implementarlo nell'architettura

pensare bene le interfacce degli streams, in particolare "size" bos/eos in relazione agli stream indeterminati 
come le socket: serve un metodo "available"? size se viene definito anche per gli indeterminati, cosa deve ritornare?

ogni metodo accetta un solo parametro (tramite puntatore) e ritorna un solo parametro (tramite puntatore) di 
tipo "Data" (finora) ma secondo me è meglio rinominalro "Stream" (o "Grid") e definirlo come interfaccia e non classe. 
così facendo separo il problema di impacchettare/spacchettare i dati quando devono usati al di fuori del 
processo, mentre all'interno del processo mantengo il massimo dell'efficenza (con solo l'appesantimento di un 
dynamic_cast) passando puntatori che non vengono serializzati, poichè la de/serializzazione viene effettuata 
invisibilmente solo all'interno dei wrappers cli/srv degli objs.
il "DataTree" che è la cosa difficile e che ancora devo definire, dovrà essere la struttura dati "perfetta" 
che implementerà "Stream" così come ogni suo sottoclasse...tale struttura deve essere pensata considerando: 
- un bel nome
- un'implementazione che massimizzi l'efficenza della de/serializzazione
- un'implementazione che massimizzi l'efficenza d'uso corrente
- un'implementazione che tenga conto dei possibili problemi di allocazione di memoria 
  (segmentazione, out of memory, ecc.)
- un'implementazione che ottimizzi il compromesso dynamic-typing-exceptions/compile-time-check 
  (probabilmente già trovato con l'utilizzo di dynamic_cast e l'interfaccia Stream come classe base di dati)
- un'implementazione che permetta l'utilizzo di sottoinsiemi aggregati di una struttura più grande, mantenendo 
  al suo interno comunque l'indirizzo/riferimento/path all'interno della struttura madre
- un'implementazione che possibilmente permetta agevolmente il calcolo distribuito 
  (cloud/grid-computing) facendo attenzione alla ricorsività intrinseca dal grafo connesso/ciclico (media priorità)
- un'implementazione che possibilmente permetta agevolmente il calcolo parallelo (bassa priorità)
- un'implementazione che possibilmente permetta agevolmente il calcolo real-time (bassa priorità)
- un'implementazione che possibilmente agevoli la persistenza (memorizzazione in uno "storage" persistente)

le esigenze della serializzazione finalizzata all'ipc sono: 
- l'operazione di riempimento (creazione/riassegnazione) di un oggetto deve essere completata affinchè l'oggetto 
  sia valido...in futuro si potrebbe anche pensare che l'interruzione generi comunque un oggetto validato, anche 
  se troncato (comunque generando l'exception)
- la trasmissione può avvenire in pacchetti di qualsiasi dimensione sia minore che maggiore della lunghezza dell'obj
- supporto alla write protection (con una chiave)
- supporto alla read protection (con una chiave)
- supporto all'accesso random (specificando un puntatore relativo)
- supporto all'accesso sequenziale (tracciando internamente un puntatore relativo)
- supporto all'accesso ad un numero variabile di bytes restituendo il numero di bytes effettivamente letti/scritti
- supporto al monitoraggio eof/bof (anzi eos/bos)
- supporto all'accesso dichiaratamente singolo o multiplo (ad es. posso solo leggere sequenzialmente una volta)

per il momento lascio la classe Data, ma la ristrutturo mentre penso a tutto quanto sopra e comincio a ripensare 
a come cambiare ipcs e ipcc che sono coloro che de/serializzano per capire come cambiare Data/Stream:
- creo l'interfaccia Stream
- a Data gli faccio implementare l'interfaccia stream
- sistemo ipcs ipcc in modo che utilizzino i metodi dell'interfaccia stream

gli oggetti data (ed ogni altro tipo per cui serva) vengono creati non con un "new" ma con due metodi: 
uno "persistent" che fa la stessa cosa di new ed uno "scoped" che viene memorizzato internamente in modo che 
quando viene chiamato il distruttore, questo fa il "delete" su tutti i puntatori scoped...in pratica fa una 
semplice "garbage collection" e cerca di evitare i più comuni casini fatti con i puntatori gestiti a mano

gli oggetti Data restituiti da chiamate a srv (anche processi separati, o remoti) potrebbero (pensare se non è un 
casino) essere aggiornabili automaticamente, cioè il srv che li ha generati li aggiorna automaticamente e 
trasparentemente a chiunque lo ha dato...è un casino!!! cioè servirebbe comunque un evento, allora tanto vale 
l'uso del pattern "listener"

data ha una componente di definizione struttura "dstruct" (hashata per fare i check) ed una componente di buffer 
virtuale "vbuffer" che gestisce trasparentemente l'allocazione (ram, disco, ecc.), la segmentazione, ecc.

vbuffer è costituito da un campo int per la versione che definisce la struttura successiva

buffer v01 prosegue con un campo long per la lunghezza in bytes (del campo dati), un campo int per il tipo di 
hash/checksum, un campo di lunghezza dipendente dal tipo di hash, un campo int per il tipo di crittografia, 
uno o più campi di lunghezza dipendente dal tipo di crittografia contenente eventuali chiavi o info accessorie, 
infine il campo data

dstruct  è costituito da un campo int per la versione che definisce la struttura successiva

dstruct v01 prosegue  con un campo long per la lunghezza in bytes (del campo struttura), un campo int per il tipo di 
hash/checksum, un campo di lunghezza dipendente dal tipo di hash, un campo int per il tipo di crittografia, 
uno o più campi di lunghezza dipendente dal tipo di crittografia contenente eventuali chiavi o info accessorie, 
infine il campo struttura...in pratica dstruct è un vbuffer con un particolare campo dati (=struttura) fatto così: 
una sequenza di campi che definiscono la struttura...da pensare come, ad es. tipo xml, tipo struct c, ecc.

tipi di dati: 
(elementari, lunghezza fissa)
long
long long
float
double

(elementari, lunghezza variabile)
string (variable size)
void (variable size) (custom and complex type, like image formats, ecc.)

(complessi->lunghezza variabile)
record<type1, type2, ecc.> (ordered, unamed (no field names), not homogeneus)
map<recordtype1, type1> (a multimap is a map with several types as keys)
  a map can accept any possible values as recordkey, or only within a set of recordkeys
  or within any possible combination of sets of fields (es field1:<1,2,3,4,5>, field2:<aa, ab, ac>)
  es. an array of 5 elements is a map with keys as a recordset of int of values 1,2,3,4,5
multimatrix<dims, <size1,..., sizeNdims>, recordtype1> as convenience (map will create too much overhead) is a 
  multidimensional array of record (es. matrix=multimatrix<2,<5,9>,long>)

NB set is implemented as array of void* and not directly supported in vbuffer-dstruct



(containers) (omo-etero, ord-unord, named-unamed, num-of-dimensions, size-of-each-dimension)
es. 
array: omo, ord, unamed, 1-dim, size=num of elements
matrix: omo, ord, unamed, 2-dim, size=m*n (num of rows, cols)
record: etero, ord, named, 1-dim, size=num  of fields
map: omo, ord, unamed, 1-dim, size=undefined/unlimited/irrational (between two elements can fit any element)
set: etero, unord, unamed, 1-dim, size=undef

array/vector<type> (homogeneus)
set (container of any mixed type)
record<type1, type2, ecc.> (ordered and named, not homogeneus)
matrix (multidimensional) is it a particular map (map<int, int, int, ecc.>(typeX))?
map (multidimensional) (map==matrix???)

data element: object containing type (long, float, char*, void), size and stored value (buffer) -> <t,s,b>
record: array (ordered) of de (types are inside each de)
map: 2 arrays, one of recordtype1 or de (keys), one of recordtype2 or de (values), both of same size (must)
multiarray: array of arrays-of-same-size of arrays-of-same-size...etc. of recordtype1 or de
-> any aggregation can be represented by an aggregation of an array (of arrays or de) and its size where 
   any particularity is mapped onto checking the size and type of each array element 
   eg a record is an array of arr/de of any size/type, map is an array of size 2 where 
   elems are type arr each of any same size, matrix is an arr of arr-of-any-same-size of any arr/de of any size/type
-> probably array should be considered a data element as well

per me i tipi di dato basilari sono: Number, Text, Vector
io uso le mie codifiche ma supporto quelle migliori tipo unicode, ieee floating point, ecc.
anche per i numeri definisco la mia codifica che deve venire utilizzata per la de/serializzazione (streaming)

un servizio può partire come:
- remote loader -> solo iface-stub, service-loop, no loader-ipc-key, no caller-ipc-key
- applicazione/comando standalone -> no stub, no service-loop, solo loader-ipc-key
- servizio -> se c'è già un'istanza, viene avviato solo lo stub con caller-key, altrimenti avvio con service-loop
- libreria -> caricato direttamente (NB attenzione che ai srv nati come servizi, non deve in genere essere consentito)
- libreria remota -> servizio
- come iface...

interfaccia ipc
client lancia il srv wrapper solo se richiesto da linea di comando
ipc prevede un sottosistema di ipc (altro canale o indirizzo, ecc.) dove inviare ricevere richieste di srv-wrappers
così si implementa il sistema dei servizi
implementare anche i "listener" cioè ipc bilaterale
fare interfacce per ipcclient ed ipcserver, poi implementare ipc via stream così lo riutilizzo per tutto
ripensare però alle interfacce stream compatibilmente con i socket o simili dove non si torna indietro
quindi o si astrae un comportamento generale che prevede il rewind, altrimenti 2 tipi di stream 
ad es. composti da due interfacce come streaminput+positionablestream (in contrasto ai limited-size-full-access-stream)
i socket potrebbero essere associati a degli stream che in realtà sono dei buffer dinamici dove ad ogni read vengono 
rimossi i dati letti dalla testa del buffer e dove la fine del buffer coincide sempre con i dati ricevuti 
e non ancora letti

ipc, forse, lancia eventi on-connect, on-disconnect, on-data-change, ecc. per comunicare all'altro estremo 
del canale quello che succede dall'altra

i parametri di ogni metodo di interfaccia solo ora accettano e ritornano Data*, in futuro accettano e ritornano 
qualunque numero di argomenti (completa c++ compliance) con la sola condizione che derivino tutti da Data. 
così facendo garantisco la ipc, ma anche la completa verifica type safe a compile-time. in pratica ogni struttura 
dati è riconducibile ad un'opportuna combinazione di Number, Text, Vector dove quindi nella classe derivata ci sono 
solo dei metodi che fanno da wrapper verso getnum, gettext, getvec, ma avere dei singoli metodi garantisce la 
correttezza semantica e di tipo del dato richiesto

nella massima astrazione anche Number e Text sono riconducibili and un vettore di interi (char, int, long, long long)
NB anche gli operatori!!! ovviamente rivisitandone il significato standard

per i number definisco la mia codifica consentendo: interi, decimali, virgola mobile, razionali, irrazionali, 
complessi, n-vettori, ecc. insomma tutti i tipi matematicamente necessari...ovviamente, tenendo presente che 
alcune codifiche devono avere requisiti matematici puri per le necessità strettamente matematiche, altre invece, 
devono avere dei requisiti di performance (codifiche di default) in base al hw sottostante

le codifiche sono astratte e generali nel senso che definiscono implicitamente sia il tipo di dato, che la sua 
rappresentazione...ciò vuol dire che un numero esadecimale lo posso mettere in un oggetto Number (forse...verificare!). 
in particolare significa che la codifica astrae dal significato (numero/testo)...la distinzione tra i concetti 
"quantità" e "qualità", è definita dagli esseri umani...in realtà il concetto di quantità può essere ricondotto 
al concetto di qualità (un po' tipo i numeri romani)...analogamente al raffronto tra lingue con alfabeto e lingue 
con ideogrammi

considerato anche che numeri e testo sono la stessa cosa, che la codifica indica il tipo/rappresentazione, 
per i numeri/testi non è automatica la relazione di uguaglianza (=, !=, <, >, <=, >=), così come le operazioni 
basilari...quindi in puro stile matematico, le relazioni e gli operatori standard non sono a priori definiti, 
ma possono essere cambiati dinamicamente...ad es l'ordinamento del testo può essere in base al codice ascii, 
oppure in base al contesto a<b<c<... ed i numeri vengono comparati coe numeri e non come stringhe, oppure possono 
esserci altre relazioni di ordinamento arbitrarie (per specifiche esigenze...ad es un'analisi di contesto che 
interpreta anche i numeri romani, le formule matematiche, ecc.)

quindi posso pensare di definire tutti gli operatori standard del c++ che wrappano su delle generiche interfacce 
operatore/relazione (nel senso matematico), definendo degli operatori/relazioni standard che abbiano come subset 
almeno i principali operatori c++.
in generale operatori/relazioni vengono definiti tramite metodi e non mai tramite gli operatori c++ che vengono usati 
solo come wrapper per le cose più comuni, ma che sarebbe bene anche farne a meno.
a tal proposito ritorna ancora più evidente l'utilizzo dei vettori come container generale e come oggetto di 
passaggio parametri/risultato, superando quindi le limitazioni del c++ (e la maggiorparte dei linguaggi).
per i vettori (ma anche numeri/testi) ha senso invece l'utilizzo degli operatori []
una implementazione (lenta) degli op/rel potrebbe essere quella con un unico metodo "op(params)" dove in params 
codifico quale op/rel richiamo, altrimenti dovrei definire degli operatori/rel singleton (e non classi statiche 
perchè altrimenti non posso avere il puntatore) i cui puntatori li memorizzo negli oggetti num/txt.
NB op/rel agiscono in genere in maniera astratta sul singolo "carattere" se poi l'azione sul carattere/vettore 
opera nel contesto numerico o testuale o se tiene conto o non della codifica (solo codifiche testo e specializzata 
alla particolare codifica, oppure tutte le codifiche o solo un subset particolare, ecc.)

la differenza tra testo e numero è che il testo ammette un unico set di valori in qualunque posizione e la dimensione 
dell'oggetto è variabile, mentre il numero ammette diversi set di valori in determinate posizioni (assolute/relative). 
quindi per il momento li tratto diversamente per efficienza computazionale

nella de/serializzazione di chi deve essere la resposabilità di serializzare type, size, wide? idealmente dovrebbe 
essere l'oggetto stesso, ma poi vector come potrebbe fare correttamente la deserializzazione senza sapere in 
anticipo quale oggetto costruire sul quale poi fare il read? ...provare con il polimorfismo, cioè Streamable legge 
type, size, wide e demanda il resto ad un oggetto in base a type...non torna...
soluzione ridondare il tipo così: vector de/serializza anteponendo il tipo rtti cioè un id per la classe giusta 
per il tipo di dato => l'interfaccia Streamable deve supportare la rtti magari con metodi statici...pensare bene!!!
ma se io ho detto che tutto è riconducibile a vactor, number, text, allora basta fare come ora tipo=1,2,3

cercare c++ reflection...

- concetto filosofico discreto di carattere e linguaggio e altri concetti correlati:
un "carattere" è un elemento (uno stato) appartenente ad un insieme finito, dal punto di vista fisico un carattere 
è uno stato di un'entità fisica o fenomeno appartenete ad un sottoinsieme finito degli stati possibili (che 
potrebbero essere infiniti...). ciò significa che se un alieno comunica variando gli spin atomici o gli stati 
energetici dell'atomo, fotoni, muoni, orbita gravitazionale, ecc. insomma con questa definizione possiamo 
accomunare il suo linguaggio al nostro e prevedere delle regole di traduzione già definibili intrinsecamente 
in questa "matematica del linguaggio"...in pratica ogni fenomeno fisico o metafisico, ogni concetto astratto 
può essere utilizato per comunicare...NB anche tra umani incoscientemente la comunicazione avviene anche 
tramite linguaggi "non verbali" definirli o recepirli o interpretarli "matematicamente" è possibile con la 
"matematica del linguaggio" qui definita (pensare agli autistici, gli animali, le piante, gli alieni ed ogni 
altra forma di vita...anzi può essere definito anche il linguaggio delle entità non viventi o addirittura 
dell'universo o degli universi...che non è altro (quasi) che il linguaggio fisico che viene cercato di tradurre 
il più fedelmente possibile dagli umani tramite il linguaggio matematico).
NB la definizione di carattere fondamentale andrebbe associata ad un fenomeno fisico reale per avere senso 
chiamarlo "fondamentale"...
nella pratica quotidiana invece definisco "fondamentale" ciò che mi fa più comodo (come nelle migliori famiglie 
matematiche)

- concetto filosofico continuo di carattere e linguaggio e altri concetti correlati:
è possibile definire la "matematica del linguaggio" anche tramite concetti "fuzzy", ovvero il carattere non come 
"stato distinto" ma come "punto continuo" cioè come stato reale continuo cioè non più come stato orbitale 
di un atomo, ma ad es. come lunghezza d'onda di un fotone o una radiazione qualsiasi o suono...chiaramente il 
"linguaggio continuo" (o fuzzy) è poco pratico nella realtà umana odierna e troppo sforzo rispetto alla mia 
utilità, perciò per il momento mi focalizzo sul linguaggio discreto...

- esempio di carattere discreto fondamentale: valore di un byte...potrebbe essere anche il bit, ma la scelta sarebbe 
ottimale per le cpu ed un linguaggio macchina, per il c++ e linguaggi di alto livello ha più senso scegliere 
come carattere fondamentale il valore di un byte ovvero il valore di un tipo di dato "unsigned char". il tipo 
di dato "unsigned char" rappresenta l'insieme degli stati possibili ovvero dei caratteri possibili
"alfabeto" = tutti i possibili valori ammessi per un carattere, ovvero l'insieme degli stati considerati

- linguaggio discreto:
"carattere fondamentale": valore appartenente ad un unsigned char (typedef unsigned char charf)
"carattere complesso": valore appartenente all'insieme di tutte le combinazioni possibili di più caratteri fondamentali
(cioè "c" appartentente all'insieme dei valori possibili di charf[d] dove d è la dimensione "wide" del car.compl.)
es. unicode_character -> charf[2], ascii_character -> charf, o charf[1]
"complessità" (o larghezza o wideness): numero di caratteri fondamentali che compongono il carattere complesso
NB non utilizzare mai charf da solo, bensì charf[d] anche se d=1 per non perdere di generalità, cioè filosoficamente 
significa che l'elemento fondamentale viene considerato "teorico" o "mistico" e passare dal trattare lo stato 
"mistico" di limitata utilità pratica (cioè non serviva tutta 'sta manfrina se rimanevo chiuso in 8 fottutissimi bit) 
allo stato "complesso" cioè nello spazio dei caratteri complessi, dove complessità 1 è un caso come gli altri...
NB carattere complesso significa l'aver implicitamente introdotto il concetto di "insieme finito ed ordinato di 
elementi"...diamogli un nome!!!
"insieme finito ed ordinato di elementi (caratteri fondamentali)": sequenza finita (cioè sequence == charf[])
sequenza finita: ha un inizio ed una fine (stringa -> non mi piace come nome)
sequenza infinita (semi-infinita): ha un inizio ma non una fine (stream -> non mi piace questa ambiguità)
sequenza bi-infinita (infinita): non ha inizio e non ha una fine (stream -> non mi piace questa ambiguità)
rete (net): generalizzazione delle sequenze
rete finita: ha un nodo di inizio ed ogni possibile path termina (con una foglia)
rete infinita: ha un nodo di inizio ed ha almeno un path infinito
rete bi-infinita: rete infinita dove non esiste nemmeno il nodo iniziale, ovvero ogni path è una sequenza bi-infinita

cosa faccio definisco stream come sequence? oppure? ...

class Character represents complex characters finite sequences -> depending of the context it may represent
a text string or a number (bool, int, float, etc.).
Text and Number classes inherit this class to provide specific contextual functionalities and facilities.
Paradox: defining a language means using a predefined language for definition (tautology).
we assume the predefined languages to be c++ language and basic "numeric" language with "character" alphabet.
we don't care what happens inside methods, only the interface is important to behave as theory wants.
numeric language is not required, quantities (wideness, ordinal position) are conceptually "characters"
the important thing is to guarrantee to have enough "states" (size of number) to represent dynamically
any complexity.
complex characters are defined on behalf of fundamental characters.
we defined the fundamental character
we define an intermediate complex character to behave as a big enough number useful to easily define
complexier characters

ambito testo ed ambito numerico: se ho del testo unicode, ho 16bit per rappresentare caratteri che non hanno 
significato numerico per cui all'interno del testo uso alcuni caratteri (0-9) per rappresentare dei numeri... 
altrimenti dovrei cambiare contesto e passare dalla codifica unicode alla codifica "int16" e mi basterebbe 
un solo carattere per rapresentare in numero 32000, anzichè 5 caratteri 16bit in unicode...questa è traduzione 
alfabetica, cioè il mappare un alfabeto in un altro.
tale questione è di non poca rilevanza perchè mi pone delle domande su come trattare testo e numeri, considerando 
anche che vorrei utilizzare per entrambi le sequenze e che bisogna tenere presenti i problemi di allineamento 
di memoria.
credo di non avere problemi ad usare le sequenze per entrambi facendo attenzione all'alineamento affinchè possa 
tradurre da/verso i basic data types / sequenze tramite dei semplici c-cast dei puntatori alle sequenze/numeri. 
l'altro problema dovrebbe risolversi in parte (ma è un semplice rimandare il problema) memorizzando nella sequenza 
la codifica utilizzata...il che mi permette di sapere che cosa ho nella sequenza (testo ascii, numeri puri, ecc.)

che cosa posso fare con i caratteri da soli? niente (pensare a controindicazioni)
tutto quello che voglio fare lo devo fare sulle sequenze (eventualmente sequenze monocarattere)
come sto usando Character nella definizione di CharacterSequence, in pratica è come se fosse un numero altrimenti 
dovrei ricadere nel paradosso di usare CharacterSequence per definire CharacterSequence, l'alternativa sarebbe 
utilizzare i basic data types per definire CharacterSequence.
oppure potrei usare Character semanticamente come numero definendo in esso la sola relazione ordinale e nessuna 
operazione, quindi ai soli fini di ordinamento ed implicitamente di dimensionamento (cioè attribuire delle grandezze). 
CharacterSequence invece la uso per definire i numeri come li conosciamo noi, ovvero con le operaioni ed il resto.
NB mi devo interrogare sul perchè voglio veramente i numeri come sequenze anzichè come caratteri perchè la naturale 
associazione sarebbe Character = numeri, CharacterSequence = testo...ma io voglio uniformare soprattutto ai fini 
dello streaming/serializzazione, ma in realtà anche per un altro motivo: con le sequenze posso definire teoricamente 
numeri infiniti e le operazioni rimangono nello stesso spazio (delle sequenze semifinite) altrimenti n+m=k dove 
k ha complessità +1 rispetto ad n,m.
potrei prendere due piccioni con una fava così (pensare bene): uso Character come numeri veri cioè uniformo non più 
numeri con stringhe, ma numeri con caratteri e nello streaming uso le sequenze (generiche). in pratica devo memorizzare 
l'encoding nel singolo carattere (waste of memory for strings), le sequenze sono nient'altro che un wrapper...

devo definire classi diverse: "Sequence" come sostituto generale di "vector" e CharacterSequence come sostituto di 
testo e numeri. ciò vuol dire che anche se concettualmente simili, si utilizzano in modo diverso ovvero Sequence 
è un conteiner di oggetti Streamable, o un container per "net"? o altro? ...pensare...

cosa devo poter fare con le sequenze di caratteri:
- tipiche operazioni sulle stringhe (append, substring, ecc.) e sui numeri (+,-,*,/,%)
- relazioni generiche (unarie, binarie, n-arie, ecc.)
- operazioni generiche
- funzionali vari
- passare a spazi diversi (cambiare wideness) gestendo anche il passaggio di codifica
- passsare da una codifica all'altra nello stesso spazio

ho deciso:
- basic char: float
- big char?: se si allora è un double...intanto lo definisco, cerco di non utilizzarlo (deprecato) però se serve, c'è!
- complex chars: NO ARRAYS (character[])! se servono caratteri grossi allora uso la classe Character con tutte le 
operazioni definite tali e quali alle op definite dal c++ sui float/double...NB pensare bene ad un'implementazione 
veloce per la MIA rappresentazione floating point sui multicaratteri...NB definire una rappresentazione "numerica" 
significa definire la famosa relazione ordinale in base alla quale sono poi automaticamente definite le operazioni 
numeriche standard. per il momento implemento il minimo indispensabile, magari vedo se posso fare la furbata di 
definire Character come typedef di double...tutto dipende da come utilizzo Character in CharacterSequence...
- char seq: in pratica è l'estensione per le stringhe con caratteri di ampiezza qualunque...per il momento mappo 
tutto in puntatori a character[w][s] dove w=1 per tutti i casi pratici NB w=1character=sizeof(float)=word=4bytes...
più del necessario ma si guadagna in velocità "portabile" perchè tanto per allineamento anche char prende 4bytes 
e quando non lo fa, fa perdere velocità...perciò la mia decisione è giusta così.
ora devo decidere se char seq rispetto alle operazioni si deve comportare come stringa o come Character (cioè 
come un numero)...e qui è che si apre il mondo perchè se devo poter usare sia character che Character che 
CharacterSequence come numeri ci deve essere un senso...ed in effetti c'è: l'esistenza della relazione ordinale!
inoltre c'è anche un altro motivo: concettualmente caratteri complessi e sequenze di caratteri sono la stessa cosa, 
ma sono solo ambiti (spazi) diversi...perciò definisco le operazioni sulle seq di caratteri in base alla relazione 
ordinale..ergo devo prima definire bene la relazione ordinale STANDARD (poi altre custom le posso mettere comunque) 
magari in futuro per fare le cose fiche definisco l'interfaccia "relazione ordinale" di cui la rel.ord.standard è 
un'implementazione, poi definsco le op standard tramite l'interfaccia rel.ord.

problema: float o double? l'ideale per le performance, il range e l'utilizzo sarebbe double, ma sprecare 8bytes per 
un carattere quando di solito ne basta 1, è un po' troppo...a meno che...furbatona...uso le dimensioni frazionali!!! 
e perchè no? tanto i numeri possono essere con la virgola (double) (NB attenzione alla precisione e gli arrotondamenti 
dei numeri in virgola mobile...) avere sequenze di un alfabeto sottospazio aumenta anche la generalità...quindi, 
tutti contenti!!! deve solo essere arrotondato ad 1byte
...a questo punto potrei anche abbandonare Character (o rinominare character in Character) ed usare esclusivamente 
le sequenze sia come caratteri-complessi/grandi-numeri che come stringhe...dovrei solo fare attenzione a non 
incappare nuovamente nella dipendenza ciclica di una classe da se stessa...
domandona: ma che senso ha usare caratteri complessi quando il linguaggio prevede allocazioni di dimensione massima 
pari al maxvalue-of-size_t? -> devo definire un oggetto Memory (singleton) che alloca dealloca memoria di qualunque 
dimensione e ciò grazie all'uso dei caratteri complessi o sequenze come parametri...avere limitazioni dentro Memory 
ha molto senso perchè è un'interfaccia verso l'hardware disponibile che ha i suoi limiti fisici e quindi tutto va 
bene se non fosse per il fatto che Memory dovrebbe essere un srv? per il momento me ne frego ed uso Memory come 
un semplice componente della core library, ma poi dovrò pensare a come si deve interfacciare l'hardware con i 
srv e come gestire l'accesso simultaneo...per le periferiche secondarie/lente non è un problema, la cosa difficile 
è gestire componenti basilari come cpu/memoria soprattutto se voglio supportare ad es "memoria hot-plug"...

Character non ha encoding all'interno perchè per descrivere l'encoding mi servirebbe un Character (o sequenza) 
ma sarebbe una dipendenza ciclica, in realtà un carattere è uno stato che da solo non significa niente, l'encoding 
poi è una mappatura ad un altro alfabeto

relazione ordinale: per le sequenze (sia Character che CharacterSequence) a sinistra c'è il carattere meno 
significativo (cioè il contrario dei numeri), le sequenze più lunghe sono "maggiori di" (così come 20 è maggiore 
di 3) quindi da destra a sinistra è maggiore la sequenza col primo carattere (da destra) che sia "maggiore di", 
si arriva quindi alla comparazione tra carattere complessi che in genere hanno larghezza diversa e per i quali 
la comparazione si fa con lo stesso procedimento (in pratica sono array di double, dove quello di sinistra è 
"il meno significativo"...e rappresenta una cifra come se fosse il sistema arabico al contrario), si arriva 
quindi al carattere fondamentale che ha il suo ordinamento definito a priori.
operazioni fondamentali: da quanto sopra la somma si fa carattere a carattere da sinistra a destra con il riporto...
e l'equivalente dei numeri decimali? ...mi servono le sequenze ad indice negativo e quindi i numeri con indici 
negativi sono l'equivalente dei numeri dopo la virgola...mi sembra perfetto!!!
con questa estensione (seq negative), bisogna espandere anche "append": append left, right, centre; dove 
appleft mette la seq di sinistra alla estremità sinistra di quella di destra (es "asd.asd" al "qwe.qwe" = 
"asdasdqwe.qwe"), appright analogamente (es "asd.asdqweqwe"), appcentre pure (es "asdasd.qweqwe")

pensare se voglio le sequenze fast (anche se grosse) e le sequenze generali o solo quelle generali

nuove decisioni:
- utilizzo fast tramite "character" sia come carattere che soprattutto come numero (double) => massime performances 
(almeno su architetture 64bit, su 32bit sono al max doppie dei float...in ogni caso è inutile guardare al passato 
per ottimizzare, col passato al massimo si mantiene la compatibilità, ma solo se non compromette il futuro -> 
principio di carattere generale)
- rimane il problema che non posso rendere "character" intrinsecamente streamable, per cui potrei pensare 
al contrario, ovvero non rendere gli oggetti streamable, ma gli stream capaci di serializzare determinati 
oggetti...però questo vuol dire perdere di generalità...ma potrebbe essere anche un bene perchè così vincolo cosa 
può essere serializzato
- utilizzo di sequenze con il max della generalità, ma con il limite di essere finite <=> sono numerabili tramite 
character...matematicamente: <S,C,A> è uno spazio finito <=> l'insieme delle sequenze S e l'insieme dei caratteri C 
hanno cardinalità inferiore o uguale alla cardinalità di A, cioè <=> dato n il numero di elementi di A, le sequenze 
hanno al massimo n caratteri ed il numero degli elementi di C (caratteri) è al massimo n
NB A è un sottoinsieme di N
- in pratica fisso lo spazio massimo accettabile <S,C,A> pari a <S,double,double> (NB ascii=<S,char,double>)
dove per "double" intendo la parte intera del double
- le sequenze infinite sono matematicamente un'altra cosa, nella realtà non è detto che esistano, quindi 
è accettabile escluderle, ma devo comunque considerare delle cardinalità arbitrariamente grandi
- astraggo i limiti fisici tramite l'utilizzo di una classe "Memory", ma rimane il problema della cardinalità
- attualmente i limi me li impone il compilatore con i basic data type (double) perchè anche se astraggo con 
una classe (perdendo molta velocità) i limiti rimangono implicitamente dall'uso dei basic data types all'interno 
della classe (il problema è ricorsivo...alla fine arrivo sempre a double/long-long) anche se uso gli array e 
anche se uso i puntatori...per allocare la memoria arrivo sempre a funzioni o elementi del linguaggio che 
richiedono l'uso di basic data types...che fare? l'unica soluzione sembra l'utilizzo della ricorsione e dei 
puntatori (es tipo le liste) cioè gestisco blocchi con i bdt al massimo delle possibilità, poi i puntatori 
a tali blocchi li metto in un blocco...i puntatori a tali blocchi li metto in altri blocchi, ecc. insomma 
mi si viene a creare una struttura ad albero arbitrariamente ricorsiva che mi nasconde i limiti della memoria fisica. 
ci sarebbe il problema dell'accesso (indirizzamento) che può essere altresì risolto con la ricorsione (es 
root->getblockpointer()->getelempointertoblock(i)->getelempointertoblock(j)->getelempointertoblock(k)->...) 
in pratica un albero "arbitrariamente finito" che è l'esatto equivalente matematico che voglio ottenere...ora 
devo capire come renderlo pratico...uso Memory come albero che mi permette di avere un'allocazione di memoria 
arbitrariamente lunga (NB andrebbe ugualmente bene (o addirittura meglio?) utilizzare una classe Array), devo solo 
studiare l'interfaccia adatta che mi consenta di: sapere la dimensione lineare accedere ad un blocco tramite 
un'indirizzo ricorsivo e di lunghezza ricorsiva specificata, cioè del tipo 
"Memory* Memory::getBlock(Recursive address, Recursive size)" fregandosene ampiamente della sincronizzazione, 
thread safety ecc. un'interfaccia di quel tipo può rappresentare la base per array multidimensionali (tra le 
altre cose) di arbitrario numero di dimensioni e di arbitrarie dimensioni dove NB "Recursive" non può essere 
banalmente "Memory*" poichè concettualmente sono due cose diverse ed infatti le interfacce devono essere diverse. 
Recursive ha praticamente il significato di un carattere (o numero) arbitrariamente grande (NB al posto di 
size dovrei usare address2 per evitare di introdurre i concetto di numero che mi riporterebbe ricorsivamente 
ai problemi iniziali, quindi Recursive rappresentano "indirizzi" astratti/virtuali di memoria lineare, vabbè è 
inutile, si può lasciare size che sarebbe lìindirizzo virtuale (rispetto a se stesso) massimo che il sottoblocco 
avrebbe) Recursive in pratica è un carattere complesso (cioè Character) ovvero un array arbitrariamente lungo di 
caratteri base (character)...quindi dopo tutte queste considerazioni emerge che posso definire una classe 
CharacterSequence che lavora in due modalità: una fast con tutte le interfacce basate su character, quindi 
opero nell'ambito di una "foglia concettuale", l'altra modalità ricorsiva dove ci sono interfacce basate su 
Character per il quale vale lo stesso discorso...internamente sia CharacterSequence che Character usano Memory 
per il quale vale lo stesso discorso opera su character finchè può, poi passa a Recursive che però è un Character 
quindi ritorna il problema di ciclicità a meno che seppur concettualemente identici distinguo Character da 
indirizzi e dimensione utilizzando il concetto di ordinamento...insomma tutto sto casino per decidere che alla 
fine non è vero che tutto è un carattere ma tutto è un numero! ...è già, perchè posso pure dire che l'ordinamento 
è un concetto astratto e che lo costruisco ricorsivamente così come i caratteri, ma dietro il concetto di 
ordinamento ci sono i numeri che guardacaso si costruiscono ricorsivamente e quindi??!!! facciamo finta di niente 
definisco un altro nome che non sia "carattere" o "numero" ad es tipo "ordinalem/ordem/ore/etc." (ordinal element) 
così astraggo ulteriormente dicendo che un linguaggio deriva dalla definizione di una relazione base su un insieme 
(finito, infinito, discreto, continuo) di stati...ora bisogna capire se questa relazione deve essere per forza 
di ordinamento e/o che caratteristiche deve avere. sulla base di un linguaggio base posso definire delle regole 
ricorsive di espansione del linguaggio per incrementarne (e daje co' 'sti numeri) le possibilità.
NB comunicare vulo dire sparare sequenze di caratteri...sequenze appunto, quindi l'ordinamento lineare è 
il prerequisito per la definizione di un linguaggio.

alla fine sono troppe pippe mentali per il momento e forse è meglio continuare con number=double e text=wstring, 
oppure pensare di espandere text in modo che sia anche considerabile come sequenza di "number"...
a questo punto c'è il problema dei vettori/data: gli array/vettori sono insiemi ordinati che abbiamo stabilito 
essere alla base di qualunque cosa (linguaggi, numeri, caratteri), cioè l'ordinamento genera le sequenze/vettori 
le quali generano un linguaggio.
quindi partiamo dall'ordinamento implicito nei "double del c++" definito a priori, su questo definiamo le 
sequenze (generiche sia per caratteri, oggetti, ecc.), qui c'è un solo problema: sequenze omogenee ok, eterogenee 
non banali per via del fatto che non sono direttamente supportate dal linguaggio posso utilizzare i puntatori e 
l'allocazione dinamica, ma non so cosa c'è dentro, per le sequenze generiche forse mi può andare bene ma non 
sono streamable...
ecco la paraculata: number è l'elemento base, tutto il resto è una sequenza di number e sequenze (implica un gran 
spreco sulle stringhe a parte che posso rimappare l'array...) quindi è la sequenza che si occupa di serializzare 
i double, le sequenze richiama i loro read/write...rimane il problema di come faccio a sapere se in una posizione 
della sequenza c'è un double o un'altra sequenza (NB queste sequenze sono in realtà delle reti...)...posso imporre 
di passare al concetto di rete e tenere due liste distinte una per i double, una per i puntatori ad altre sequenze 
(NB nel concetto originario, avevo considerato i record al posto dell'array di double, o un solo elemento...ma 
qui siamo andati oltre astraendo da tutto abbiamo ricondotto tutto ai numeri) così ho definito delle sequenze 
semiomogenee sulle quali posso derivare un'altra classe per implementare il concetto generale delle sequenze 
eterogenee base semplicemente introducendo una sequenza di indirizzi dove mischio puntatori a double e puntatori 
ad altre sequenze nell'ordine che preferisco in pratica una mappatura! se poi voglio introdurre dei tipi complessi 
come i record, le matrici, le mappe, ecc. basta che riconduco tutto a double e sequenze e creo una classe wrapper 
che offre i metodi per offrire le funzionalità tipiche di quel tipo complesso. ovviamente le sequenze devono 
implementare tutte le operazioni e funzionalità che si possono inventare sulle sequenze (considerando anche che 
ho un due array in ogni sequenza)

il risultato di quanto sopra è l'avere una base che mi permette di generare qualunque cosa e che basilarmente mi 
offre le funzionalità richieste dalla mia infrastruttura, ovvero la serializzazione ed in futuro chissà cosa...

problema: ownership dei dati e puntatori contenuti nelle sequenze ad es se deleto un nodo, deleto in cascata 
tutti i path? se fosse un grafo ciclico sarebbe l'autodistruzione perchè cancellare un nodo, cacellerebbe tutto 
il grafo...probabilmente lo lascio come opzione di creazione del root node e come metodo richiamabile, gli altri 
nodi possono essere creati sono tramite il nodo padre...pensare anche se sembra ok così...

riorganizzare: template base uguale a std::vector con le mie funzionalità e basta, poi sequence implementa 
Streamable ed offre solo due metodi: miovector<number>* getnumbers() e miovector<Sequence*>* getsequences() 
così evito di duplicare i metodi e le implementazioni ed è molto più razionale

riorganizzare: template base uguale a std::vector con le mie funzionalità + l'accesso raw tramite puntatore al 
array per consentire di memorizzare il puntatore ed avere poi l'accesso alla massima velocità e basta. quindi 
ora ho una classe per manipolare le sequenze omogenee ma anche un accesso velocissimo ed una manipolazione 
diretta dei dati senza overhead. il limite è la memoria contigua, cosa di cui me ne frego perchè se ho una 
quantità spropositata di dati e l'hardware è pietoso, non è un mio problema! casomai è un problema del compilatore 
...ma nemmeno!
dunque, a me servono le sequenze di sequenze, le sequenze di number e le sequenze raw di ampiezza che decido io 
e cioè sequenze di ascii, sequenze di unicode, ecc. il problema è che usando i template non posso definire 
direttamente le seq di seq perchè devo specificare il tipo, quindi potrei usare le seq di streamable ma non 
va bene perchè dovrei fare i dycast, l'alternativa sarebbe le seq mutevoli cioè come i template, ma a runtime!
NB approfondire come il c++ gestisce l'accesso agli array multidimensionali (se fa somme, moltiplicazioni, ecc. 
con i puntatori, indici ecc.)
potrei usare dei metodi reshapeas... che cambiano l'ampiezza del singolo elemento dell'array, quindi il raw deve 
essere void* ed uso i metodi get... per avere il tipo voluto, questo implica che non posso più usare l'operatore [].

ho una seq dentro ci posso mettere puntatori ad altre seq, oppure elementi number, oppure elementi generici di 
ampiezza (in bytes) non definita a priori, oppure definite le sottodimensioni di number, ovvero num8-16-32-64. 
in questi sottotipi ci posso mettere quello che mi pare numeri piccoli, interi, float, stringhe ascii, stringhe 
unicode, ecc. cioè number è il tipo naturale che mi consente tutto alla max velocità, gli altri sono tipi di 
ampiezze esatte e predefinite per particolari esigenze (spazio, interfacciamento, ecc.) mettendo la velocità 
in secondo piano, fare il reshape è deprecabile perchè altero il tipo originale che ci ho messo dentro, quindi 
è preferibile usare i templates, perchè tanto alla fine devo sempre gestire i diversi tipi suddetti. quindi 
ho 5 tipi ed una seq template che mi genera altrettante 5 seq, poi ho una seq di puntatori che mi ritorna seq
dei vari tipi (5+1) il problema è che la seq di seq non la posso fare...o faccio la seq di streamable e poi 
l'utente fa il dycast, oppure faccio una derivata di questa ed aggiungo dei metodi che wrappano il dycast. 
l'uso del template mi serve anche per mantenere il raw array del tipo specificato.

faccio seq tale che nel costruttore decido cosa conterrà (no templates) ha metodi che ritornano tutti i tipi 
previsti (seq, number, num8-16-32) che lanciano un eccezione se il tipo non è corrretto
---
Sequence& s;

char8seq c8s = s.get(0);
number n = s.get(1).get(0);
c8s.append("asd");

Sequence s1; // sequence of sequences
Sequence s2((number) 2); // sequence of char16
Sequence s3(0); // sequence of numbers

number n = s3[0];
s3[s3.size()] = 0;
Sequence s = s1[0]; // reference

non è possibile perchè l'operatore [] ritorna lo stesso tipo, si potrebbe fare solo con i templates...quindi diventa:
number n = s3.getnumber(0); // reference
s3.getnumber(s3.size()) = 0; // reference
Sequence s = s1.getsequence(0); // reference
s3.subsequence(6, 9); // tipo in base alla costruzione

s.number().get(0); s fa un dycast di se stessa a seq di numbers

+++

come ottenere ciò?:
number[] n = s.get(0);
text t = s.get(1);
sequence* sq = s.get(2);

tengo un void* (in realtà char o num8) usando realloc che mantiene il contenuto che posso castare ad array di 
qualunque cosa (number, num8-16-32, seq, ecc.) devo fare attenzione ai num16-32 perchè sono array e devo vedere 
che succedo se li casto a int, long ecc. 
che operazioni consentire? resize (basato su num bytes == realloc), le assegnazioni le faccio tramite array ottenuto 
da get(). 
in realtà potrei memorizzare qualunque dato come se fosse una struct immaginaria dove l'utente accede specificando 
indice (numero di byte) e tipo da ritornare (number, num8-16-32, void* pointer) dove gli indici potrebbero anche 
essere dei define per esplicitare una singola struct immaginaria. 
potrei anche pensare le seq come seq di number assicurandomi che sizeof(number) possa contenere i puntatori (cioè 
puntatori a sequence*), ma come gestisco il problema dei sottotipi?
allora creo diversi get che mi ritornano array del tipo che mi serve (reshaping) ed internamente impostano il wide 
appropriato così tutte le successive operazioni si basano su questo, cioè il get fa il reshaping implicito, oppure 
prevedo il reshape esplicito e se uso il get sbagliato lancia un'eccezione. posso anche imporre il wide in fase di 
costruzione ed impedire il reshape...
in pratica i number li accedo direttamente il testo e le seq no lo uso implicitamente e ci faccio operazioni sopra... 

numeri, sequenze di dati (numeri, testo, ecc.), sequenze di puntatori a sequenze. 
posso decidere che le sequenze siano omogenee, il che significa che i dati (numeri) sono solo sulle foglie, altrimenti 
ho sequenze di numeri in ogni nodo, mi sembra più ragionevole la prima ipotesi...
usando i templates avrei data=seq<streamable*> per cui poi dovrei fare un dycast da streamable* a seq<number>

number n = dynamic_cast<numseq>(params.get()[0])[0]; // un vero casino
sequence s = dynamic_cast<sequence>(params.get(0));
numseq sn = dynamic_cast<sequence>(s.get(0));

ritorniamo al discorso che data=params=seqseq dove get ritorna numseq o seqseq, quindi seq potrebbe avere un array 
di puntatori a sequenze di vario tipo quindi se seq è numseq allora avrà un array di un elemento che punta ad array di 
numeri se 

number[] n = s.get(0).raw();
sequence* sn = s.get(0);
number m = sn.raw()[0];
text t = s.get(1);
sequence* sq = s.get(2);

number n = (number) p.buf[0]; // multimatrix
string s = (num8) p.buf[0];
sequence sq = dynamic_cast<sequence>(p.buf[0]);
number n = (number) sq.buf[0];
number n = p.getseq
number n = (number) p.buf[0][0];

pensiamo tutto in termini di seqseq...è impossibile in termini di template, solo classe! così facendo si arriva a delle 
seq che in realtà non contengono altre seq, ma dati, qui posso fare il raw, ottengo un num8* (num8[]) che posso castare 
a number* o number[] o num16* (num16[])

sequence s = p.get(0);
string str = p.get(1).raw();
wstring ws = (num16) p.get(2).raw();
number[] n = (number*) p.get(3).raw();

i puntatori DEVONO essere trattati diversamente perchè nello streaming non devono comparire ma essere rimpiazzati dagli 
oggetti a cui puntano...per cui forse devo riprendere i discorsi teorici e fare il passaggio da seq a net. 

---


UNIVERSO:
partiamo dall'inizio...
esistente: concetto assiomatico primario e non definibile. 

universo: è l'insieme dell'esistente (o degli universi nella comune accezione) per il quale è sempre valida la legge 
di causa-effetto.

legge di causa-effetto: transizione/trasformazione/funzione continua dell'esistente da uno stato x ad uno stato 
x+dx sulla linea del tempo.

tempo: particolare linea a cui è stato attribuito questo nome sulla quale sembra basarsi ogni transizione/fenomeno 
dell'esistente comunemente chiamato multiverso (NB multiverso è sottoinsieme dell'universo definito da me).

NB <esistente, trasformazione/funzione, linea> sono i concetti assiomatici primari e non definibili che consistono 
nella massima astrazione umanamente possibile della realtà esistente confidando che permetta eventuali ulteriori 
astrazioni nel caso se ne dimostri la possibilità...

universo: <esistente, causa-effetto, tempo>

sequenza: ...

NB la sequenza eterogenea è il concetto più naturale basato sui concetti assiomatici...
NB sequenza è un concetto anche più astratto del concetto di universo

vediamo quindi di ricondurre il concetto di rete, grafo, ipergrafo al concetto di sequenza...
ipergrafo è un insieme di sottoinsiemi di elementi di un insieme X = sequenza di sequenze di elementi di X... dove 
l'ordinamento delle sequenze è teoricamente matematicamente superfluo, ma nella pratica è alla fine il concetto 
che permette l'accesso agli elementi...visto dal punto di vista del principio di heisenberg, sebbene esista la 
indeterminazione tra una coppia di variabili canoniche (non dipendenti) comunque ogni sottoinsieme dell'esistente 
ha un luogo ed un tempo ben preciso anche se non precisamente misurabile, anche per oggetti appartenenti allo stesso 
tempo io per accedervi o farvi riferimento, ho bisogno di coordinate, che per l'indeterminazione non posso conoscere 
e quindi usare nella pratica devo (o comunque posso) operare un'astratta mappatura di coordinate, per cui per la 
massima semplicità mappo le coordinate universali (non identificabili) nel più semplice sistema di coordinate...quello 
lineare...quindi se sono riuscito a mappare il concetto di ipergrafo (il più astratto) a sequenze, ho raggiunto il mio 
scopo! ...quindi devo usare solo sequenze!

elemento: porzione spazio-tempo dell'universo. NB qui ritorna l'indeterminazione perchè oltre al utilizzare 
concetti primitivi come "porzione", "sottoinsieme", ecc. porzione -> volume -> insieme di punti -> insieme denso di 
coordinate universali -> sequenza di coordinate universali -> sequenza di punti

ora un problema è che se considero una seq eterogenea che a sua volta può contenere altre sequenze, in teoria sarebbe 
un oggetto molto grosso, io invece devo usare i puntatori per le seq (cioè coordinata lineare consecutiva per gli 
elementi non seq e riferimenti per le seq), cioè internamente due sistemi di coordinate, che devo nascondere. 
poi c'è un altro problema che sarebbe quello che a priori dovrei (in teoria) poter accedere a qualunque tipo di 
oggetto

---

sequence params;
number n = params(0);
num8 n8 = params(1);
sequence* seq = params(2);
potrei fare che op() ritorna una sequence e poi uso "op number()" per fare il cast implicito
se penso sequence come "omogeneussequence<streamable*>" op() ritorna il cast di uno streamable* a 
omogeneussequence<streamable*>

number n << params(0);
potrei fare che seq ritorna void* e ci metto dentro qualunque cosa, poi io che mi sono costruito il tipo X mi creo 
l'operatore <<(X, void*) che mi fa il cast trasparentemente...forse al posto dovrei usare Streamable*, ma poi non ci 
posso mettere gli integral types, oppure per i tipi integral forzo la conversione (reinterpret_cast) a void* e poi al 
tipo richiesto...NB non serve dichiarare "friend" gli op globali dentro seq (la quale non ne sa proprio l'esistenza) 
perchè non devo accedere ai dati interni faccio solo casting...

quindi:
sequence = omogeneussequence<streamable*>
sequence* sequence::operator()(number n);
number& operator<<(number& n, streamable*);

oppure:
sequence = omogeneussequence<streamable*>:sequencestreamable:streamable
omogeneussequence::operator[](int i); // trovare un sostituto all'operatore [] perchè mi impone int
sequence* sequence::operator()(number n);
T* omogeneussequence<T*>::operator()(number n);
numseq = omogeneussequence<number>
number& operator<<(number& n, streamable*);
numseq& operator<<(numseq& n, streamable*);

cioè:
number n = (ns << params(0))[0]; // quasi accettabile

anzi:
numseq ns << params(0);
number n = ns(0);
num8seq n8 << params(1);
string s = (char*) n8.raw();

così facendo le seq di streamable possono accettare puntatori di ogni tipo e posso convertire implicitamente a tutti i 
tipi...

---

problema: risolvere il problema dello streaming di sequenze quando il contenuto non è integral, cioè puntatori ed 
oggetti...posso accettare elementi integral, oggetti sequenze e puntatori a sequenze e ciò mi risolve il problema 
di sapere a priori il tipo di oggetto da leggere (Sequence è una classe Streamable non astratta e non template), ma 
devo ancora saper distinguere fra i tre casi...

forse la cosa migliore è limitarsi a tipi integral e puntatori a sequenze, sia per semplicità di allocazione di memoria 
che per flessibilità, che per evitare problemi di blocchi troppo grandi, ecc. tanto posso wrappare qualche metodo ed 
operatore per gestire come input/output sia i puntatori che gli oggetti (reference ad oggetti) nella de/serializzazione 
invece includo tutto ricorsivamente, sia perchè è più semplice da gestire, sia perchè è più naturale...

problemi: inserire/prendere elementi nelle/dalle sequenze, upcastare una sequence a numseq, num8seq, ecc.
upcast: ho un oggetto sequence e mi serve un operatore/funzione e specificare il tipo a cui upcastare...per far ciò 
mi serve anche un oggetto d'arrivo col tipo richiesto (ad es numseq), ma tutto questo ha un prezzo che consiste 
nell'avere una variabile ed un'assegnazione in più e complica inutilmente le cose, forse è meglio abolire le
sequenceomogeneus<T> ed utilizzare solo le sequence con l'aggiunta di funzioni template per inserire/prendere elementi 
dalla seq già castati così mi risparmio molti passaggi tra cui la definizione di ulteriori tipi (numseq, ecc.) e se 
definisco bene ed in maniera non ambigua le funzioni template, non ho bisogno di specificare il tipo nella chiamata.

inserire:
seqseq params;
const char* text;
const wchar_t* wtext;
params << num8seq(text); // aggiunge una sequenza di caratteri
params << num16seq(wtext);
params << numseq(20); // aggiunge una sequenza di un numero
params << numseq({20, 30, 40}); // aggiunge una sequenza di tre numeri
quindi mi serve un costruttore che prende puntatori ad array e li inserisce nella sequenza (problema: come determino 
la lunghezza da leggere? catcho un'eccezione? null terminator? pensare...)

prendere:
seqseq res;
const char* text = res(0).raw(); // buffer della sequenza alla posizione 0 di res
num16seq wtext = res(1); // sequenza di caratteri unicode usando = definito da seqomo
wstring ws = (const wchar_t*) wtext.raw();
number n = *(number*) res(2)(0); // rischioso perchè op() di sequence mi ritorna il puntatore e poi è troppo casino
number n = (*res(2))(0); // funzione template overloading sul op*...probabilmente non funziona...
number n = res(2) | 0; T operator|(sequence seq, number num)
number n = dynamic_cast<numseq>(res(2))(0); // troppo casino se non aggiungo qualcosa che semplifichi
numseq ns = res(3); // sequenza di numeri usando = definito da seqomo
*((number*) res(3).raw() + i) con il check su width può essere un modo per le funztempl
il discorso è che seqseq ritorna oggetti seq, seq ritorna void*, quindi mi servono template (classi e funzioni) che 
mi permettano a partire da una seq o void* di ottenere oggetti di tipo T.

decisioni:
per inserire uso il template operator<< dentro la classe (non template) sequence il che vuol dire che posso fare: 
sequence seq << n << text; 
rimane poi da definire come si comporta...potrebbe inserire come puntatore (facendo new, store address, copy) 
comportandosi come una vera sequenza eterogenea al prezzo di un doppio consumo di memoria per i numeri ed ininfluente 
per le stringhe, ciò avrebbe senso solo se accompagnato da intelligenti seqomo...ok, allora facciamo così: quando 
ho seq << elem, se elem è un puntatore a seq o derivate, ne prendo il puntatore e memorizzo (copio), se elem è 
qualsiasi altra cosa, costruisco (new) una nuova seqomo, ci metto dentro elem e memorizzo il puntatore in seq. 
gestita intelligentemente seq avrebbe diverse seqomo (seqomo<num8>, seqomo<num16>, seqomo<number>), cioè tante 
seqomo quante sono le stringhe, più una seqomo per tutti i number, più una seomo di seq per tutte le strutture 
complesse (record, matrici, mappe, ecc.). 
per prendere la questione è più delicata perchè potrei definire dei miei integral types (number, num8, numseq, ecc.) e 
memorizzare dentro ogni sequence il tipo contenuto e scrivere esplicitamente operatori overloaded per ogni tipo 
integral e lanciare eccezioni se uso il tipo non corrispondente...altrimenti uso operatori o funzioni template e spero 
che chi li usa lo faccia con cognizione di causa. in ogni caso ho il problema che non posso overloadare sul return type 
per cui probabilmente dovrò usare il sistema di mettere il reference della variabile risultato tra gli argomenti 
del metodo/operatore.
in breve mi serve un sistema sicuro e controllato per prendere oggetti/puntatori/numeri.
se usassi un buffer interno dove serializzo più un buffer di indirizzi, tramite la differenza tra indirizzi contigui 
conosco la dimensione del tipo memorizzato e quindi risalire al integral memorizzato (num8, num16, number, ecc.) e 
dato che nella mia concezione tutto è un numero e il cosa c'è dentro dipende dal contesto che non è affar mio, il tutto 
mi quadra...

params << string1
params << string2
params << new sequence << number1 << number2 << ecc.

cioè con i puntatori a char e wchar creo automaticamente delle sequenze ed aggiungo queste, per i numeri no aggiungo 
i numeri castati a "number"

const char* string1 << params|0
const wchar_t* string2 << params|1
sequence seq << params|2
number1 << seq|0
number2 << seq|1

number1 << params|0|0
number2 << params|0|1

number3 << params|0|0|1|3(2)
string3 << params|0|0|1|3(0) // sempre 0 finale perchè è l'array di caratteri, oppure...
string3 << params|0|0|1|3 // con opportuno overload di << con una sequenza come rvalue e char* come lvalue
number3 << params-0-0-1-3+2 ...meglio di no!

cioè operator|(number) ritorna un reference a sequenze assumendo che la seq di ingresso contenga puntatori a seq, 
operator()(number) ritorna una copia del contenuto...poi rimane il problema dell'operatore template, quindi potrei 
usare un metodo, ad es number3 << params|0|0|1|3.get<number>(2) oppure op() non è template e ritorna un puntatore 
a num8* e << viene overloadato per ogni integral type prendendo il num8* lo traduce in number (no puntatore) e lo 
casta al tipo richiesto

string1 << seq1 | i;
non va bene per via della precedenza degli operatori quindi devo trovare un'alternativa per cui al posto di | ho un 
operatore con alta priorità ed al posto di << ho un operatore con bassa priorità, non è = perchè deve essere membro, 
non può essere <<= o simili perchè implicano l'assegnazione su oggetti già esistenti...cioè...
char* string1 <<= seq1 | 1; <=> string1 = string1 << seq1 | 1;
cioè sarebbe ricorsivo...

faccio che le seq con width  negativo, hanno width pari al maggiore tra il sizeof double e il sizeof void* così ho 
ottenuto le seq eterogenee perchè possono contenere sia puntatori ad altre seq, che numeri...se invece ho bisogno di 
dimensioni esatte (come per le stringhe) fisso il width, cioè se non specifico, sono eterogenee...

nel designer delle iface sarebbe bene fornire uno strumento nel quale definisci una struttura dati e lui ti fornisce 
il sample code per riempirla e per prenderla assegnando a variabili elementari...giusto per sopperire all'eliminazione 
del compile time type safe...che in ogni caso è il prezzo accettabile da pagare per ottenere un rpc/rmi universale e 
strutture dati dinamiche...è l'analogo degli xml o degli alberi dove la struttura dati non è definita a compile time...

definizione iface basilari:
StorageMemory: memoria lineare...tipo file, ram, ecc. NB il hd non è lineare, per cui un srv HDStorageMemory lo nasconde
StorageFileSystem: basato su StorageMemory, offre un basilare supporto ai "file"
Encryption: pensare una iface basata su input/output generici che vada bene per ogni tipo di storage, stream, ecc.
Storage: basato sui suddetti, offre "user access control", tab, alberi, grafi, ecc. strutture dati di altissimo livello
Log: basato su Storage e non su StorageFileSystem o StorageMemory perchè i log devono poter essere altamente strutturati
Configuration: basato su Storage e non su StorageFileSystem o StorageMemory
BootSequence: basato sui precedenti?
UserInput: basato sui driver di periferiche, offre segnali di alto livello discreti, fuzzy, multidimensionali, ecc.
UserInterface: basato su UserInterface e driver di periferiche offre generiche funzionalità per creare "applicazioni"
SecurityManager: basato su Configuration mappa le azioni o i parametri che gli utenti, srv, iface possono fare...

Log: data-ora (timestamp), luogo (classe, metodo, pc, os, città, ecc.), oggetti (nomi e valori delle variabili), tipo di 
informazione loggata (loglevel), azione e parametri, chi (user, system, service, ecc.), status (del contesto in cui il 
log esiste e non più ampio perchè eventualmente quelle info se servono si ottengono dal merging nel contesto di una 
log analisys) NB per "time" deve essere creato uno standard universale astratto (cfr discorso sul linguaggio...)...
la log analisys la si ottiene dalle feature avanzate di Storage o al limite da un iface "ReportAnalisys"...la cosa 
importante è che venga definito un standard universale di memorizzazione dei log in Storage...NB Log scrive soltanto!!!

Configuration: similarmente a Log, è un'interfaccia ad uno standard di memorizzazione dati in Storage, più delle 
classificazioni concettuali...config ha un nometipo univoco ed una versione che identificano la sua struttura 
immodificabile nel tempo (cioè se aggiungo o rimuovo o rinomino un campo, DEVO cambiare almeno versione). ogni config 
può avere diverse sottoconfig ad es fsconfig_v1=<fsc_v1, fsprefs_v2>, storageconfig_v1=<fsprefs_v2, userprofile_v1> 
cioè posso comporre sezioni di conf diverse per ottenere una nuova conf, oppure semplicemente per avere il profili, 
cioè imposto una sezione base con info relative al pc, e poi una sezione preferenze, così di volta in volta carico 
il profilo che l'utente desidera senza replicare le info comuni (cosa che potrebbe creare casino), altro vantaggio è 
che se il sistema di sicurezza lo consente, posso ottenere che le mie preferenze di una app si riflettono su ogni 
altra app collegata, cioè massima flessibilità...

come procedere:
- skippo StorageMemory
- definisco StorageFileSystem
- implemento un StorageFileSystem che wrappa sul file system locale mappando una sottodirectory
- veloce ragionamento su Encryption e definizione
- definizione Log
- definizione Storage (lavoro impegnativo!!!)
- implementazione semplice di Storage basato sul file system locale (lavoro lungo!!!) ed eventualmente sqlite
- implementazione di Log
- definizione di Configuration
- impementazione di Configuration
- definizione di UserInput
- definizione di UserInterface
- implementazione UserInput
- implementazione UserInterface (GUI)

NB IMPORTANTE!!! attualmente ogni metodo di ogni iface può ritornare solo oggetti Sequence, il che implica un framework 
di tipo C (con handle ecc.) nel contesto C++ cioè i metodi mi danno degli handle/id/ecc. tramite i quali mi riferisco 
a degli "oggetti" concettuali...in futuro si potrà ritornare degli oggetti ma solo quelli appartenenti ad una delle 
iface già definite dove i wrapper si occupano di creare degli opportuni wrapper degli oggetti ritornati...attenzione 
però!!! così l'architettura introduce notevoli e subdole complicazioni...deve essere pensata molto attentamente...anzi 
deve essere deciso se si vuole veramente andare in questa direzione...

NB modifica: nelle funzioni delle dll dei srv far si che la funzione "create" accetti anche un oggetto Sequence oltre 
che il puntatore a Loader, così posso passare dei parametri pure al costruttore dei srv...pensare se è possibile 
farlo! se non è possibile, vedere se si può introdurre un metodo init per tutti i srv che viene chiamato invisibilmente 
da tutti i vari loader...

dipendenze:
hw-bootsequence -> il bios gli dice da dove prendere il kernel da caricare in memoria ed eseguire (kernel è il loader)
kernel-bootsequence -> avvia storage sullo stesso device da quale il bios ha caricato il kernel
                    -> prende da storage il srv configuration, lo carica in memoria e lo esegue
                    -> prende da storage il srv securitymanager, lo carica in memoria e lo esegue
                       (securitymanager richiede ed usa configuration)
                    -> prende da storage il srv bootsequence, lo carica in memoria e lo esegue
NB il nome dei srv di storage, securitymanager, configuration e bootsequence sono hardcoded nel kernel e sono random 
e sono scelti/calcolati in fase di installazione come contromisura per i virus/cracker
bootsequence -> avvia un hardcoded configuration ed in base a questa decide se, cosa, in che ordine avviare e termina

NB la precedente sequenza di avvio funziona solo se storage non dipende da configuration, cioè storage deve poter 
essere operativo almeno a livello base anche senza config, poi magari attiva la modalità full che carica config, 
altrimenti bisogna far precedere storage da basicstorage e basicconfiguration e quindi storage dipende da 
basicconfiguration che non è il massimo...

quindi:
hwboot
kernelboot
  basicstorage
    bootsequence
      basicconfiguration
      storage
      configuration
      (start securitymanager and set secureloader as default)
=> quindi:
-hwboot
--kernelboot -> instantiate basicloader: last srv instantiated per each iface, become the defaul fot such iface...
---storagememory (ram) -> il kernel viene mappato in memoria con codice e dati, storage memory mappa la parte dati
---basicconfiguration (storagememory) -> "sequence"...c'è solo la config di storage...
---basicbootsequence
----storage (basicconfiguration) -> loader uses this srv as default
----configuration (storage) -> loader uses this srv as default
----bootsequence (configuration)

NB in storage è presente il sistema con i dati, le iface, i srv, ecc.
(storage > configuration > securitymanager > bootsequence > tutto)

StorageFileSystem:
- setstoragememory -> nome del particolare srv che implementa l'iface storagememory sul quale sfs va a gestire i file 
che sono a loro volta dei storagememory...NB nel caso che il particolare sfs faccia solo da wrapper verso il fs 
sottostante, questo metodo non fa nulla...anzi ritorna sempre errore (non eccezioni)
- filecreate
- filedelete
- filerename
- getfile -> ritorna un oggetto file/stream...il problema è che non può essere offerto con l'attuale architettura...
oppure inserisco qui le funzioni sul singolo file in stile c con gli handle...
- fileopen -> secondo me open/close vanno tolte perchè è roba da medioevo...al max serve una getid per avere l'handle...
- fileclose -> come sopra
- fileid -> ritorna la seq file a partire dal nome...
- filesize
- filesetposition -> no! la posizione DEVE essere fornita a read/write dal chiamante sempre ed è lui che ne deve 
tenere traccia...
- fileread
- filewrite
- listfiles
- openedfiles -> ritorna sia gli handle che i nomi
- closeall
NB anche se non è una soluzione pulitissima, io posso strutturare bene una seq params che vada bene per tutti i 
metodi sopra e che quindi è quasi come un oggetto file...
tutto ciò in realtà ha anche un senso visto che il device sul quale c'è il fs è lo stesso, quindi sia i primi tre 
metodi che gli altri operano sullo stesso hw, avere due oggetti non collegati implicherebbe problemi di 
sincronizzazione...

Storage:
consente di memorizzare qualunque tipo di struttura dati (record, file, tabelle, alberi, mappe, grafi, sequenze, ecc.) 
(che abbiamo stabilito derivare tutte da "sequence"), modificarle, crearle, cancellarle, interrogarle, importarle, 
esportarle...
ho due strade...o definire a priori le cose suddette nel tentativo di ottimizzare al massimo le performance, oppure 
permettere di definire dei nuovi tipi in base a composizioni di sequence e vincoli su di esse (cfr riflessioni a 
proposito)... la seconda strada mi piace molto di più e la mia prima impressione è che potrebbe avere comunque delle 
performance al top, ma è tutto da verificare...in ogni caso moltissimo dipende da come memorizzo le sequence in base 
ai vincoli di composizione...
- setstoragememory -> nome del srv che implementa l'iface storagememory sul quale storage va a gestire i dati
- createtype -> metodo semplice che opera su sequence e vincoli (va usato più volte per tipi complessi)
- deletetype -> controlla che i tipi non siano in uso o abbiano dipendenze
- modifytype -> controlla che i tipi non siano in uso o abbiano dipendenze
- copytype
- listtypes -> può essere inclusa in searchtypes
- searchtypes
- create -> crea un oggetto di un determinato tipo
- insert -> aggiunge un elemento di un certo tipo all'interno di una struttura
- get
- set
- delete
- modify
- copy
- search
il punto cruciale è definire un generico algoritmo di ricerca/parsing, cioè come navigare nei path, cioè devo 
specificare cosa fare ad ogni seq, es tabelle: ho una seq (tab) di seq di numeri (cols), il mio search devo specificare 
una seq di index che indica quali colonne prendere (se null le prendo tutte), poi per ogni index (col) specificato, 
do un insieme di criteri sul contenuto della seq-colonna...
in pratica: i criteri di search, si riconducono ad un agglomerato di seq-criteria, dove si distingue in base al 
contenuto che ci si aspetta, ovvero i criteri su oggetti possono essere gli indici da prendere, oppure il risultato 
di una delle relazioni definite su number o sequence. 
altra cosa importante è che in base al search, io individuo un sub-oggetto/sotto-grafo/ecc. ed una sottostruttura, 
quindi io DEVO POTER modificare un sub-oggetto oppure specificare una sottostruttura che riempio e poi dico a 
storage di sovrascriverla alla sottostruttura dell'oggetto specificato. siccome ho progettato BENE le sequenze (cioè 
realmente sequenziali), un sub-oggetto potrebbe essere rappresentato semplicemente dagli indici/sub-indici una volta 
che l'algoritmo di search ha individuato la sottostruttura corrispodente ai criteri (NB i criteri/relazioni potrebbero 
essere anche degli algoritmi molto complessi e quindi...lenti!). 
quindi tutto il problema delle performance risiede negli algoritmi relazionali su number/seq che potrebbero essere 
velocizzati con delle strutture aggiuntive di supporto che vengono calcolate una-tantum (all'inserimento, modifica, 
ecc.) e quindi si arriva anche alla crucialità del metodo di memorizzazione delle strutture dati...questi discorsi 
mi sembrano ulteriori indizi nel proseguire nella strada generica...
Nota: probabilmente una buona strategia di memorizzazione potrebbe essere che ogni sequenza la spacchetto in linked 
files, così quando apporto modifiche non devo riscrivere file molto grandi (file molto grande = colonna con 
tantissimi elementi)

ora veniamo al come implementare la prima e più semplice versione cercando di garantire che i classici file possano 
essere memorizzati come se stessi (a meno che io non voglia spacchettare gli stream come nel caso dei video...). 
nella soluzione finale dovrò sicuramente (forse) avere una storagememory basata su un device hw o similare ed al di 
sopra uno storagefilesystem (devo cambiare questi nomi) e sopra questo storage, ma ora implemento storage direttamente 
sul filesystem locale fornito dal sistema operativo...
nuovi nomi:
StorageSequence (storagememory) -> mappa una memoria lineare (ram, hd, file) in una sequenza e viceversa (iface molto 
  simile a sequence)
StorageSequenceSpace (storagefilesystem) -> mappa/memorizza diverse sequenze in uno StorageSequence, può farlo 
  automaticamente oppure può essere specificata la posizione...può essere importante...i nomi delle seq sono 
  degli id di tipo number, se voglio nomi, attributi, permissions, ecc. devo implementarlo con una iface derivata 
  che memorizzi queste info in seq apposite, per i miei propositi sono superflue, ma in generale è giusto così per 
  separare le funzionalità ed una maggiore flessibilità

rivediamo quindi l'iface di...
Storage:
storagesequencespace -> imposta e/o ritorna lo stoseqspc sul quale opera...NB è sss ad impostare storagesequence, 
  quindi se voglio cambiare device, devo chiedere al loader o chi per lui l'istanza di sss che sta usando il mio 
  storage e poi a quell'istanza gli dico quale storagesequence utilizzare...magari ci metto un metodo per semplicità...
storagesequence -> fa quello detto sopra...
create -> crea una struttura specificando i vincoli (di struttura e/o di contenuto) su di essa, in pratica crea due 
  strutture, una è la struttura dati e l'altra contiene i vincoli/criteri...poi se queste vengono messe insieme in una 
  seq di sue elementi, o se le seq dati le metto tutte da una parte e quelle vincoli da un altra, dipende 
  dall'implementazione, l'importante è che esista un collegamento che associ ad ogni struttura dati, la propria 
  struttura vincoli. questi vincoli sono controllati in fase di "set" ed "ins". NB una stessa struct vincoli può 
  essere utilizzata da più struct dati...
modify -> modifica la struttura vincoli SE possibile E rende consistente la struttura dati con i nuovi vincoli 
get -> ritorna una substruct a partire da una struct dati ed una struc vincoli/criteri di ricerca (NB in genere è 
  una struct con criteri più restrittivi dei vincoli associati alla struct dati all'atto della creazione). 
  NB come per i db i la ricerca ed i criteri possono fare riferimento a molte struct dati, cioè il campo non è 
  ristretto ad una struct, posso fare join, mix, union ecc. tutto e di più!!!
set -> a partire da una struct dati ed una vincoli che ne individui una substruct, rimpiazza i valori...in pratica 
  copia i valori di una struct in una struct/substruct (anche frutto di get) controllando i criteri di quest'ultima
ins -> simile a set, ma non individua una substruct, ma una "posizione" nel quale mettere i dati previo rispetto 
  della struttura e dei vincoli, spostando gli altri elementi...se la pos non è specificata, fa un add...
del -> cancella una struttura frutto di get (NB per cancellare una struct dati ED anche i vincoli, devo fare due del 
  a meno che non facciano parte di una stessa rootseq, ma come abbiamo detto questo dipende dall'implementazione...)

NB in realtà potrei astrarre ulteriormente la faccenda dei vincoli, ma potrebbe essere molto lungo e complicato o 
potrei perdere in sicurezza dei dati...rimandiamo il discorso ad una eventuale vers 2 della iface...

NB come criteri/vincoli devo supportare almeno le rel base <>=, più tutti i criteri supportati dai vari database per 
le ricerche, più quelle eventuali della teoria dei grafi, più le regular expressions...questa è tosta, ma va fatta! 
inoltre devo trovare unificante, potente e veloce (nel senso che è direttamente interpretabile dall'implementazione 
di storage e non come sql/regexp/xml/ecc. che mi obbligano a fare il parsing di testo...il mio equivalente sarà 
ovviamente un agglomerato di sequenze che poi posso rappresentare come testo, ma è solo una facility di 
import/export delle ricerche...)

StorageOSFS:
è il srv che implementa l'iface Storage basandosi sul file system fornito dal sistema operativo su cui gira. 
tenendo presente che il sss sottostante tiene l'elenco di tutte le seq memorizzate io devo definire una regola sugli 
id (nomi) per distinguere le seq di sistema da quelle user-created -> da 1 a 1.000.000 sono di sistema (mi sono tenuto 
basso perchè questa è un'implementazione che verrà superata da quella basata su sss e ss che a sua volta verrà 
migliorata col tempo ecc. per cui qui non vado troppo per il sottile...0 è not-used (potrebbe essere un utile valore 
di test per gli errori) da 1.000.001 a 2.000.000 sono per le struct vincoli, da 2.000.001 in poi sono per le struct 
dati. la seq 100 contiene gli id delle seq-struct-rules, la seq 200 contiene gli id delle seq-struct-data, la 
seq 300 (di lunghezza sempre pari alla 200) contiene gli id dei vincoli associati alle seq dati (anche qui vincoli?). 
le seq data potrebbero essere create senza vincoli associati (pericolose!!! potrebbero crescere a dismisura o creare 
casini!!!), però facciamo che se non viene specificato alcun vincolo, viene impostata una seq-struct-rules di default 
con id 1.000.001...ora emerge il problema delle seq eterogenee...tanto per cominciare esiste anche nelle seq 
implementate nella core library perchè teoricamente posso inserire un numero che casualmente coincide con il 
puntatore di una qualche sequenza...insomma il problema è come distinguere tra number e link a seq...in ogni caso il 
problema lo risolvo al momento solo qui in storage e poi con l'esperienza lo risolvo anche in core che comunque 
dovevo reimplementare perchè non mi piaceva la soluzione adottata...
consideriamo ad esempio che io voglia creare una tab con una lista di file ed associati dei flag booleani, allora 
faccio una seq di due seq (vincolo) di uguale lunghezza (vincolo) di cui la prima accetta solo 0/1 (vincolo) e la 
seconda accetta solo link (id) a sequenze esistenti...quindi devo poter esprimere i seguenti vincoli...

numero di elementi (esatto, range, set di possibili valori)
tipo di elementi (number/seq-id)
valori elementi (range/set/etc.)

NB ciascun vincolo può essere un valore predeterminato, ma può anche essere il risultato di una get (search)!!!

NB potrei anche fregarmene del tipo di elementi perchè in fondo i seq-id sono dei number...poi sono io che li 
interpreto come tali!!! il punto cruciale è che poi non avrei delle relazioni esplicite e quindi nessuna garanzia che 
gli id siano validi...insomma è la stessa differenza tra un db relazionale ed uno no...devo riflettere bene, anche 
se sono abbastanza convinto di imporre le relazioni...
allora se io prendo da storage posso scegliere se voglio gli id in chiaro oppure che le seq vengano mappate 
trasparentemente (modo naturale di procedere), ma se io faccio un set come faccio a specificare se una sub-seq deve 
sovrascrivere quella già esistente (se si è richiesto che mantenga lo stesso id?) o se ne creo una nuova e rimpiazzo 
solo l'id? diciamo che per il momento sono per il sovrascrivere perchè i link/id sono degli artifici implementativi 
in realtà, concettualmente parlando, una sub-seq sta dentro la struttura, poi il fatto che un stessa sub-seq possa 
essere condivisa da più struct, è un problema a parte e porta il discorso ai loop, ricorsioni, ecc. dei grafi oltre 
al discorso delle relazioni e relazioni inverse (se cancello una seq devo poter sapere dove è stata referenziata se 
voglio poter adottare contromisure, altrimenti mi ritrovo id relativi a seq non esistenti o peggio relativi a nuove 
seq che non hanno niente a che vedere con quelle cancellate e referenziate...)

come implementare ins...
pensando ad una tabella è come se io dessi una replica di una struct con solo alcuni elem (con valori diversi) 
i quali vanno ad inserirsi opportunamente...ins è molto complicato, meglio pensare prima a set...

come implementare set...
devo specificare una get che mi ritorna una substruct S e poi fornisco una struct O, le strutture devono essere 
identiche rispetto alle lunghezze, tipo del contenuto ed alla struttura in generale...ora basta un algoritmo 
di navigazione esaustiva e faccio il replace uno ad uno...il che mi rimanda a...

come implementare get...
a partire dalla seq radice, posso specificare un vincolo, questo mi ritorna una seq ridotta con possibili link ad altre 
subseq sulle quali applicare altri vincoli...la vera domanda è questa...devo sapere a priori come è fatta la seq 
ridotta per poter specificare ed applicare vincoli alle subseq, oppure posso limitarmi a specificare delle regole? 
sicuramente la seconda ipotesi mi può essere utilissima quando si arriva alle "foglie" o giù di lì, ma è molto 
complicato per cui per il momento mi limito al fatto che nelle ricerche per poter applicare dei sottovincoli 
devo necessariamente specificare con esattezza la seq ridotta che mi deve arrivare dal vincolo precedente...



piccolo riepilogo:

set è il più semplice di tutti, prende due struct uguali e sovrascrive una dentro l'altra, dopodichè salva 
quest'ultima che in realtà era un raggruppamento di link ad elementi di determinati file...

get parte da una struct vincoli/filtri ed una struct dati, applica a quest'ultima i filtri e ritorna dei 
link/puntatori ad elementi...da ciò si deduce che serve una classe analoga (forse derivata) a sequence, ma che 
internamente ha dei riferimenti/puntatori al file che la contiene...in pratica due passi, uno mappare una seq in un 
file distinguendo tra numeri e link ad altre sequenze/file, due una perfetta sincornizzazione e thread-safety 
magari mediante eventi, mutex, lock, transactions, ecc. insomma meccanismo di mappatura in real-time almeno per il 
read dei dati, eventualmente flush+trasactions per il write...forse basta un singleton per ogni file che supporti 
il lock/mutex in scrittura ed il flush su file è gestito internamente analogamente al journaling dei file systems 
cioè in pratica in base al compromesso safety/performances posso scrivere subito il file ( quello che farò nella 
prima implementazione) ad ogni scrittura nella classe, oppure ogni tot elementi cambiati e/o ogni tot secondi/minuti 
o secondo altri criteri...comunque bisogna tener conto che tutte le suddette modalità prevedono degli eventi, 
quindi conviene tenere presente che in futuro dovrò supportare gli eventi...
NB quanto detto sopra è pari pari quello che deve/dovrà fare l'iface StorageSequence, quindi è meglio che non uso 
gli stessi nomi per evitare problemi di compilazione, comunque mi ritroverò il grosso dell'implementazione...
ANZI NO!!! è fondamentalmente diverso, perchè StorageSequence fa rifarimento ad un device a se stante e la mappatura 
è riferita ad una sola seq...no link ad altre seq sullo stesso device!!! NB anche StorageSequenceSpace non 
prevede link tra seq, la relazione di linking tra seq è una peculiarità stretta di Storage e basta!!! per cui 
le classi che devo definire sono diverse...
mi serve una classe con interfaccia uguale a sequence più dei metodi per gestire la sincronizzazione con lo storage 
fisico, oppure posso inserire dentro un policy manager e poi di volta in volta specifico quale policy bisogna 
adottare...
la prima domanda è se posso trovare un modo semplice per rendere Sequence sufficientemente virtuale da permettermi di 
derivare la classe di cui sopra da seq...ma lo rimando, per ora la copio e basta...
NB una cosa importante, magari non immediatamente ma quasi, è la possibilità per le subseq di essere "inline" ovvero 
memorizzate insieme alla seq parent questo per evitare che le stringhe vengano memorizzate come file a parte...
ovviamente deve essere opzionale e consentito solo alle seq foglie? ...se lo imposto a delle subseq non foglie la 
cosa non si propaga automaticamente su tutte le seq child (ma devo prevedere un metodo per la propagazione ricorsiva). 

ins rimane il più complicato, pensare dopo...

Nota: espandere il Loader mettendo un metodo template che fa il dynamic_cast automaticamente...

Nota: implementare il lock in SequencePersistent in put e write (cioè non puoi inserire mentre scrive...) o forse 
devo implementare delle SequenceLockable in core...

ragionamenti per arrivare ai search...
per fare riferimento ad un elemento (numero) io scrivo così -> seq(2)(3)[4], questa espressione vuol dire che ho 
una sequenza seq a cui applico ricorsivamente gli indici 2,3,4...in pratica l'array {2,3,4} rappresenta le coordinate 
dell'elemento in seq, quindi per accedere ad ogni elem basta una sequenza di coordinate!!! ...per accedere 
a n elementi, mi serviranno quindi una sequenza di n subsequenze...potrei ottimizzare quensto discorso potrei 
vederlo "per righe" (approfondisco il livello per ogni elem contemporaneamente) anzichè "per colonne" (arrivo ad un 
elem per volta), ma fondamentalmente ci siamo per il caso più semplice, quindi devo trovare un metodo per mappare 
questo ragionamento in un algoritmo che mi ritorni una seq di puntatori ad elem...NB questo dettaglio è importante!!! 
perchè non solo devo avere una seq ridotta, ma le modifiche su questa DEVONO riversarsi in real-time sulla seq di 
partenza!!!
supponendo di fare un search che su una seq dice di prendere gli indici da 2 a 9, la seq risultante...è e deve essere 
una seq...ciò vuol dire che i criteri mi servono solo in fase di generazione della seq, ma il risultato è una "seq" 
la differenza sta nel fatto che le seq frutto di search apparentemente sono uguali all'origine (come se avessero 
tutti gli elementi), ma nella pratica hanno solo gli elem richiesti...per far ciò ho bisogno di una diversa classe 
derivata da sequence dove anzichè un solo buffer con i dati, ho due buffer uno con gli indici originali, uno con i 
puntatori agli oggetti nella seq di origine...ciò mi permette tre cose uno di accedervi tramite gli indici originali 
(anche se è molto più lento perchè faccio usa di una mappa e quindi l'indice è in realtà una chiave da cercare alla 
quale è associato un indice nel secondo buffer => triplo passaggio) due di accedere con i nuovi indici e tre di 
modificare direttamente l'origine...NB questa classe però mi deve fornire anche due possibilità uno di avere un 
oggetto copia (cioè ho ancora la possibilità di accedere con gli indici originali, ma le modifiche non si riflettono 
sull'originale) e due di esportare in una seq classica (cioè perdo ogni collegamento con l'origine)...
stabilito ciò...il get è immediato, il set diventa una semplice facility che effettua cicli e ricorsioni per copiare 
tutti i dati previa verifica della congruenza tra le due strutture...rimangono ins e del che sono i più complicati...
ins di un "record" fornisco una seq di seq-coordinates più una seq di elementi (le due seq devono essere lunghe 
uguali), ins di più "record" semplicemente la seconda seq diventa una seq di seq-record...
del ha la seq di coordinate più una seq di numeri che indicano quanti elem eliminare...

Nota: modificare sequence aggiungendo i metodi ins e del, facendo si che alla fine abbia get, set, ins, del, add...
creare una classe sequenceiterator o simile che contenga il riferimento (o puntatore) ad una sequence ed un indice 
valido per questa, più una serie di overload di >> sui vari integral types di modo che sia possibile fare così...
seq >> string1 >> pchararray1 >> integer1 >> float2 >> ecc. dove [sequence >> integral] ritorna seqiter& con i=0 e 
dove [seqiter >> integral] ritorna seqiter& con i=i+1...
l'unico problema potrebbe essere la thread safety perchè tra un'istruzione e l'altra un altro thread potrebbe aver 
aggiunto/modificato/rimosso un elem, ma tale problema esiste anche per << ...quindi potrei rendere sequence lockable 
dove i metodi lock/unlock ritornano il rif alla seq così posso scrivere così...
(seq.lock >> string1 >> integer1).unlock ... (seq.lock << string1 << integer1).unlock o magari se definisco 
opportunamente un operatore potrei scrivere così... seq.lock << string1 << integer1 & seq.unlock; ...no, è ridicolo 
perchè è sufficiente scrivere così... seq.lock << string1 << integer1; seq.unlock;
inoltre elimino il trylock sostituendolo da un opportuno overload di lock che deve permettere di attendere 
indefinitamente, attendere fino ad un timeout, adottare un comportamento correntemente definito come default, inoltre 
serve anche un metodo per specificare la modalità di default...

Nota: idea per la dynamic-lifetime/scope degli oggetti...ho un singleton che mi crea gli oggetti ritornandomi sia 
un puntatore che un reference (a scelta) ritornandomi come intermediario un altro oggetto inizializzato col puntatore 
che una volta uscito dallo scope farà o no il delete di quell'oggetto a seconda di quale metodo ho usato per crearlo...
così ho il vantaggio di usare reference e non puntatori, ma se mi fermo qui non ho vantaggi rispetto ai banali 
new e delete, però se ragiono meglio magari posso trovare dei meccanismi per decidere a quanti livelli di upscope 
posso far sopravvivere l'oggetto...in realtà tutta questa faccenda non mi piace, ma in taluni casi forse potrebbe 
tornarmi utile...
