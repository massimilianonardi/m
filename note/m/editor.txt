
js-lib-dynamic: make it as a standalone project (with import from core lib for Queue, but specific functions insdide this project)
  - find a way to pass path to modules.js.json and modules.css.json from browser (global variables???, maybe an array of paths so that one script tag is needed)

electron editor:
  - process typing for syntax highlight, hints and code completion, bracket matching, folding blocks detection, linting (error/warning detection), smart indent
  - multiple undo/redo
  - json / xml / html (hex/octal/etc. ???) wysiwyg edit without typing delimiters and keywords
  - memorize actual text to be saved and show visual effects and keep indexing between the two
  - source of modifications is: keyboard, mouse (cut, copy, custom commands, etc.), function api offered to external sources
  - start of modifications: first define carets positions + modifing functions with parameters (eg type char "a", type word "etc", paste text from clipboard)
  - carets definitions: arrow keys, mouse, mouse+keys
  - type of modifications: typed key (char or control key (eg canc, backspace, enter, etc.)), mouse (context menu via modification api)
  - generalize typed keys via modification api -> thus is possible to
  - integrate, generalize and make transparent undos/redos into the modification api -> maybe a class object to keep state (carets, selections, etc.)
  - also integrate detectors into modification api that can be added dynamically and transparently
  - detectors can be abstracted at different levels (eg key, word, line, etc.) and should be well thought
  - pre/code contenteditable keyboard/mouse events handlers should detect hotkeys that map into modifications api???
  - insertText accepts strings (one char from key event, text from paste event or other)
    it deletes current selections (if not empty) and insert text after the current carets (one for each selection range)
    insert/remove text is processed by reversed array of ranges, but any range modification affects indexes of following ranges
    insert -> first range results in a delta = range-collapsed + inserted-chars (despite of direction), next range add delta to range and process again
    remove -> direction MATTERS A LOT! first range: collapse, if reverse no problem because no range can be before first, delete chars upto next range start,
    if remains more chars are to be removed, then collapse next range and delete from ranges, then delete chars upto next range, and so on, then go to next range
    if reverse ...
    function to collapse ranges from->to can be useful to insert/remove actions especially to simplify remove alg
  - detections are calculated on inserted text with surrounding text delimited by particular chars (space, brackets, etc.)
  - range: ranges cannot intersect/overlap!!!
    ranges are ordered by insertion order, but they can be ordered by start index (most common situation)
    at the end index is always positioned a "directional caret" (visually and logically)
    "column range" is an array of single line ranges that usually are one below other, this allows "column ranges"
    that can be of any shape and not only rectangular (eg like magic wand, draw a closed perimeter that defines it)
    multiline text default is to be pasted as whole column, but paste block for each caret can be choosen
    every caret remain at end of each insertion (range is collapsed, that is start=end)
  - persistent selections, selections in global history and only selection history
  - copy/paste columns to/from external apps tables
  - smart selections: draw a rectangle and each line selection is expanded/stretched on delimiters (space, comma, etc.)
  - editable selections (adjust conrers, borders, etc.) by hotkeys, but also mouse.
  - support code documentation (decide for de facto standard tool, or make my own standard)
    standardize also comments within code
    ability to hide docs and or comments
  - code preprocessing for debug commands removal, different source code genration for different profiles (eg: release, debug,  inline-release, etc.)
  - code analyze, code graph generation, automatic uml, etc.

    Internal code documentation—intended for developers inside the organization (doxygen for c/c++, php, etc. javadoc, jsdoc, etc.).
    External code documentation—intended for developers outside the organization who integrate with the product or need to understand its code.
    Low-level or inline documentation—resides within the source code and explains details of specific code parts in isolation, such as the purpose of certain functions and arguments.
    High-level documentation—describes the architecture, design principles, implementation guidelines, or other broader concerns.
    Walkthrough documentation—describes flows, patterns and other important parts of the codebase, especially for developers who need to contribute to the code.
