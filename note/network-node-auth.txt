
--------------------------------------------------------------------------------

BLOCKCHAIN REGISTRATION / AUTHENTICATION:

definitions:
net-master-node: the node that bootstraps the network and then self destroys pri-key, but keeps/publish the pub-key
srv: registrar
cli: registrant
untraceable: subject not identifiable nor distinguishable
anonymous: subject distinguishable, but without certified info assignable
certified: subject distinguishable and with certified info assigned
asym-key: <pub-key, pri-key> generated by an asymmetric cryptographic algorithm
id-name: pub-key
id-key: pri-key
credential: blockchain of <pub-key, eventual info to certify>, encoded with precedent agent pri-key starting with net-master-node pri-key encoding
            it certifies the membership to the net and the position on the net (master-node > sub-node > ... > first contacted node)
            may also certifies infos on certain node responsability
            infos may be list of credentials themselves (thus graphs of blockchains) so that responsibility is shared with other nodes (to be better defined)
cred-dec: info resulting from the last element decoded from a credential. credential first element is decoded using net-master-node-pub-key
id: <<pub-key, pri-key>, sym-key, credential> where pri-key and pub-key are generated by the same process and pub-key is part of cred-dec
sym-key: used for efficient encrypting/decrypting of private big data instead of pub-key for enc and pri-key to dec
id-anon: anonymous identity (credential has no info, only pub-keys)
id-cert: certified identity (credential has some info certified by some node on its own responsability)
id-*-sec: id physically accessible only bt the owner
id-*-unsec: id physically accessible at least by one subject who is not the owner
token: random generated string
enc-token: token encrypted with pri-key



registration:
cli: send <authnreg-req-cmd, cli-token, cli-pub-key>
srv: send <authn-req-cmd, srv-token, srv-credential>
cli: verify srv-credential (srv belongs to the net), keep srv-pub-key from last element decoding
     send <authn-res-cmd, enc-srv-token>
srv: verify <enc-srv-token, cli-pub-key> (cli is who he claims to be)
     cli-cred-last = encoding of cli-pub-key + eventual info with srv-pri-key
     send <authnreg-res-cmd, enc-cli-token, cli-cred-last>
cli: verify <enc-cli-token, srv-pub-key> (srv is who he claims to be)
     verify cli-cred-last that decoded pub-key matches cli-pub-key and eventual info are correct
     save cli-credential = srv-credential + appended cli-cred-last as last element



authentication:
cli: send <authn-req-cmd, cli-token, cli-credential>
srv: verify cli-credential (cli belongs to the net), keep cli-pub-key from last element decoding
     send <authn-req-cmd, srv-token, srv-credential>
cli: verify srv-credential (srv belongs to the net), keep srv-pub-key from last element decoding
     send <authn-res-cmd, enc-srv-token>
srv: verify <enc-srv-token, cli-pub-key> (cli is who he claims to be)
     send <authn-res-cmd, enc-cli-token>
cli: verify <enc-cli-token, srv-pub-key> (srv is who he claims to be)
     if srv-credential is "better" than cli-credential first n-1 elements
        then try to register again to srv



NB performance trick: cache pairs of <credential-element, pub-key-decoder>, or <credential-element, decoded <pub-key, info>>
NB bandwidth trick: find statistically relevant registrar nodes close to me and try to send only the shortened credential, if other has not in cache, then send full

golden chains: chains shorter than X -> they register only after the gained level of trust is higher than Y

this authentication guarrantees that acces was granted from a member of the net and who was (this could be the base for a responsibility system)
if the net bootstraps in a decent way, then the average credential length tend to be 2
issue: if master node and early sub-nodes disappear forever too early, then minimum achievable length for credentials may be not small and thus inefficient
in this case it can be found statistically the nodes that disappeared forever and remove them from the chain, if some node reject, then send full chain

NB physical ownership of identities, may be dangerous (they can be stolen, or at least they can reveal you). find a way to share and use securely.
encrypt with a simmetric algorithm and or upload them to the net and download/cache when needed and only keep them in memory in your user authenticated session

--------------------------------------------------------------------------------

REGISTRATION / AUTHENTICATION:

users and nodes are treated the same way registration on the net is allowed to anyone with only not blocking conter measures against spam, flood, ddos
a node can act as node and/or client
browsers are thin client, native or java nodes are full client
thin client cannot generate ids
full client generates and stores ids. NB ids should have associated a name or description and pri-key should have a decoding password
physical-id: a multiplatform full client on a read-only usb pen-drive

web of trust (wot) registration (registrars are responsible for every registrant they register)
key signing party: wot members signs id/keys each other
several form of authentications (mobile number, document id, bank/paypal, general site (google, fb, etc.), gov site csrf id verification, calligraphic)
mobile authentication with app that reads phone number and maybe other accounts info or @apple.com e-mail registration
prevent mass and spam registration (eg incremental authorization with human interaction (captcha, math operation, semantic phrases questions, etc.))
delayed registrations: 1 day delay, or wait for registrar user to manually verify registration (eg calligrapic, etc.)
user identity on owned node for simplicity, but must be distributed
user registration by one node alone (signed by him) with embedded internet ip
user registration by mobile browser putting together gps location range, timestamp small timeslice, ip, browser/os version, qr code from desktop browser, etc.
browser/gps location must match ip geolocation
not indexed identity = pub-key
user registration: pri/pub key generation on browser/client or outside for max security, upload <pub key + password enc with pri>
temporary registration: registration with embedded expiry. in the meanwhile i can do few things, but if i don't validate within expiry, then none would authenticate
java client authenticate via mac address
android phone receiving sms and via existing app forwards/logs to mail that trusted server reads and contact node to authorize registration
or use andorid phone as sms gateway
almost secure identification registration by donating 1â‚¬/1$ to me, paypal info are certified user send transaction id, if verified, then register with users paypal info

--------------------------------------------------------------------------------

registration is its id + id encrypted with net private key
other clients validate it using net pub key id must match to decrypted id
encrypted id is provided by master of network if accepts registration
there may be a hyerarchy of registered nodes with the master as top where they delegate registration as "to be approved" that need approval of a full hierarchy or just master
master node can register or revoke any node
master node bootstraps network with some trusted nodes
trusted nodes can register or revoke any node, but master may undo trusted nodes operations
after network is bootstrapped, trusted nodes decide collectively the promotion or demotion of nodes to trusted (rules tbd)
more hierarchy level of trust will be defined
moving nodes across different lot is a hard operation based on hard security requirements and needs to be voted by higher levels
tbd safe rules for good/bad behaviour and pyramidal responsability

if registration is accepted by at least one, then it receives a node id + id encrypted with registrant private key + registrant id + registrant public key
with this info then node can connect any node and prove its registration to the network because any registered node can retrieve the list of registrants and pub keys
NB easy generation of unique id: registrant id + timestamp + random (bad thing is that registrant is a clear info, should be anonymous)

--------------------------------------------------------------------------------
