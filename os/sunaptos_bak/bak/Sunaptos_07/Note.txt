loader è un srv come gli altri tranne per il fatto che è l'unico che può interfacciarsi interamente 
con il os che l'ha lanciato e quindi l'unico che può lanciare altri processi.

anzi no, anche altri srv di sistema sono ad accesso full come loader (storage, config, log, etc.)
per ciascuno di questi si crea un exe specifico e con un md5 diverso e con nome diverso, in modo 
che tramite os (linux, mac, windows) posso dare a questi i diritti necessari e 
negare tutto a "client.exe" che genera tutti i srv "normali"

gli altri srv possono caricare solo le lib di sunaptos e nient'altro -> nb l'uso della rete è implicitamente 
concesso (purtroppo) perchè è necessaria a "client.exe" (che ha lanciato srv) per fornire la ipc

kernelloader (o remoteloader) al suo avvio lancia tutti i srv a lui funzionali come config, storage, ecc. 
poi lancia bootloader. in particolare config è importante perchè dice le regole con le quali decidere se 
i nuovi srv devono essere servizi o libs ad es. config deve essere un servizio, storage "non è necessario"...

TODO: pensare ed implementare l'architettura a supporto dei servizi in senso stretto, 
la gestione delle eccezioni ed errori attraverso le chiamate tra srv sia via ipc che tramite chiamata diretta

forse per implementare i servizi potrebbe bastare (o comunque può essere il primo passo) fare sì che 
per una stessa istanza di un srv vengano istanziati diversi canali ipc per ogni richiedente e poi è il 
particolare srv che gestisce le cose come un servizio...poi magari questo comportamento viene pensato come 
formalizzarlo ed implementarlo nell'architettura

pensare bene le interfacce degli streams, in particolare "size" bos/eos in relazione agli stream indeterminati 
come le socket: serve un metodo "available"? size se viene definito anche per gli indeterminati, cosa deve ritornare?

ogni metodo accetta un solo parametro (tramite puntatore) e ritorna un solo parametro (tramite puntatore) di 
tipo "Data" (finora) ma secondo me è meglio rinominalro "Stream" (o "Grid") e definirlo come interfaccia e non classe. 
così facendo separo il problema di impacchettare/spacchettare i dati quando devono usati al di fuori del 
processo, mentre all'interno del processo mantengo il massimo dell'efficenza (con solo l'appesantimento di un 
dynamic_cast) passando puntatori che non vengono serializzati, poichè la de/serializzazione viene effettuata 
invisibilmente solo all'interno dei wrappers cli/srv degli objs.
il "DataTree" che è la cosa difficile e che ancora devo definire, dovrà essere la struttura dati "perfetta" 
che implementerà "Stream" così come ogni suo sottoclasse...tale struttura deve essere pensata considerando: 
- un bel nome
- un'implementazione che massimizzi l'efficenza della de/serializzazione
- un'implementazione che massimizzi l'efficenza d'uso corrente
- un'implementazione che tenga conto dei possibili problemi di allocazione di memoria 
  (segmentazione, out of memory, ecc.)
- un'implementazione che ottimizzi il compromesso dynamic-typing-exceptions/compile-time-check 
  (probabilmente già trovato con l'utilizzo di dynamic_cast e l'interfaccia Stream come classe base di dati)
- un'implementazione che permetta l'utilizzo di sottoinsiemi aggregati di una struttura più grande, mantenendo 
  al suo interno comunque l'indirizzo/riferimento/path all'interno della struttura madre
- un'implementazione che possibilmente permetta agevolmente il calcolo distribuito 
  (cloud/grid-computing) facendo attenzione alla ricorsività intrinseca dal grafo connesso/ciclico (media priorità)
- un'implementazione che possibilmente permetta agevolmente il calcolo parallelo (bassa priorità)
- un'implementazione che possibilmente permetta agevolmente il calcolo real-time (bassa priorità)
- un'implementazione che possibilmente agevoli la persistenza (memorizzazione in uno "storage" persistente)

le esigenze della serializzazione finalizzata all'ipc sono: 
- l'operazione di riempimento (creazione/riassegnazione) di un oggetto deve essere completata affinchè l'oggetto 
  sia valido...in futuro si potrebbe anche pensare che l'interruzione generi comunque un oggetto validato, anche 
  se troncato (comunque generando l'exception)
- la trasmissione può avvenire in pacchetti di qualsiasi dimensione sia minore che maggiore della lunghezza dell'obj
- supporto alla write protection (con una chiave)
- supporto alla read protection (con una chiave)
- supporto all'accesso random (specificando un puntatore relativo)
- supporto all'accesso sequenziale (tracciando internamente un puntatore relativo)
- supporto all'accesso ad un numero variabile di bytes restituendo il numero di bytes effettivamente letti/scritti
- supporto al monitoraggio eof/bof (anzi eos/bos)
- supporto all'accesso dichiaratamente singolo o multiplo (ad es. posso solo leggere sequenzialmente una volta)

per il momento lascio la classe Data, ma la ristrutturo mentre penso a tutto quanto sopra e comincio a ripensare 
a come cambiare ipcs e ipcc che sono coloro che de/serializzano per capire come cambiare Data/Stream:
- creo l'interfaccia Stream
- a Data gli faccio implementare l'interfaccia stream
- sistemo ipcs ipcc in modo che utilizzino i metodi dell'interfaccia stream

gli oggetti data (ed ogni altro tipo per cui serva) vengono creati non con un "new" ma con due metodi: 
uno "persistent" che fa la stessa cosa di new ed uno "scoped" che viene memorizzato internamente in modo che 
quando viene chiamato il distruttore, questo fa il "delete" su tutti i puntatori scoped...in pratica fa una 
semplice "garbage collection" e cerca di evitare i più comuni casini fatti con i puntatori gestiti a mano

gli oggetti Data restituiti da chiamate a srv (anche processi separati, o remoti) potrebbero (pensare se non è un 
casino) essere aggiornabili automaticamente, cioè il srv che li ha generati li aggiorna automaticamente e 
trasparentemente a chiunque lo ha dato...è un casino!!! cioè servirebbe comunque un evento, allora tanto vale 
l'uso del pattern "listener"

data ha una componente di definizione struttura "dstruct" (hashata per fare i check) ed una componente di buffer 
virtuale "vbuffer" che gestisce trasparentemente l'allocazione (ram, disco, ecc.), la segmentazione, ecc.

vbuffer è costituito da un campo int per la versione che definisce la struttura successiva

buffer v01 prosegue con un campo long per la lunghezza in bytes (del campo dati), un campo int per il tipo di 
hash/checksum, un campo di lunghezza dipendente dal tipo di hash, un campo int per il tipo di crittografia, 
uno o più campi di lunghezza dipendente dal tipo di crittografia contenente eventuali chiavi o info accessorie, 
infine il campo data

dstruct  è costituito da un campo int per la versione che definisce la struttura successiva

dstruct v01 prosegue  con un campo long per la lunghezza in bytes (del campo struttura), un campo int per il tipo di 
hash/checksum, un campo di lunghezza dipendente dal tipo di hash, un campo int per il tipo di crittografia, 
uno o più campi di lunghezza dipendente dal tipo di crittografia contenente eventuali chiavi o info accessorie, 
infine il campo struttura...in pratica dstruct è un vbuffer con un particolare campo dati (=struttura) fatto così: 
una sequenza di campi che definiscono la struttura...da pensare come, ad es. tipo xml, tipo struct c, ecc.

tipi di dati: 
(elementari, lunghezza fissa)
long
long long
float
double

(elementari, lunghezza variabile)
string (variable size)
void (variable size) (custom and complex type, like image formats, ecc.)

(complessi->lunghezza variabile)
record<type1, type2, ecc.> (ordered, unamed (no field names), not homogeneus)
map<recordtype1, type1> (a multimap is a map with several types as keys)
  a map can accept any possible values as recordkey, or only within a set of recordkeys
  or within any possible combination of sets of fields (es field1:<1,2,3,4,5>, field2:<aa, ab, ac>)
  es. an array of 5 elements is a map with keys as a recordset of int of values 1,2,3,4,5
multimatrix<dims, <size1,..., sizeNdims>, recordtype1> as convenience (map will create too much overhead) is a 
  multidimensional array of record (es. matrix=multimatrix<2,<5,9>,long>)

NB set is implemented as array of void* and not directly supported in vbuffer-dstruct



(containers) (omo-etero, ord-unord, named-unamed, num-of-dimensions, size-of-each-dimension)
es. 
array: omo, ord, unamed, 1-dim, size=num of elements
matrix: omo, ord, unamed, 2-dim, size=m*n (num of rows, cols)
record: etero, ord, named, 1-dim, size=num  of fields
map: omo, ord, unamed, 1-dim, size=undefined/unlimited/irrational (between two elements can fit any element)
set: etero, unord, unamed, 1-dim, size=undef

array/vector<type> (homogeneus)
set (container of any mixed type)
record<type1, type2, ecc.> (ordered and named, not homogeneus)
matrix (multidimensional) is it a particular map (map<int, int, int, ecc.>(typeX))?
map (multidimensional) (map==matrix???)

data element: object containing type (long, float, char*, void), size and stored value (buffer) -> <t,s,b>
record: array (ordered) of de (types are inside each de)
map: 2 arrays, one of recordtype1 or de (keys), one of recordtype2 or de (values), both of same size (must)
multiarray: array of arrays-of-same-size of arrays-of-same-size...etc. of recordtype1 or de
-> any aggregation can be represented by an aggregation of an array (of arrays or de) and its size where 
   any particularity is mapped onto checking the size and type of each array element 
   eg a record is an array of arr/de of any size/type, map is an array of size 2 where 
   elems are type arr each of any same size, matrix is an arr of arr-of-any-same-size of any arr/de of any size/type
-> probably array should be considered a data element as well

per me i tipi di dato basilari sono: Number, Text, Vector
io uso le mie codifiche ma supporto quelle migliori tipo unicode, ieee floating point, ecc.
anche per i numeri definisco la mia codifica che deve venire utilizzata per la de/serializzazione (streaming)

un servizio può partire come:
- remote loader -> solo iface-stub, service-loop, no loader-ipc-key, no caller-ipc-key
- applicazione/comando standalone -> no stub, no service-loop, solo loader-ipc-key
- servizio -> se c'è già un'istanza, viene avviato solo lo stub con caller-key, altrimenti avvio con service-loop
- libreria -> caricato direttamente (NB attenzione che ai srv nati come servizi, non deve in genere essere consentito)
- libreria remota -> servizio
- come iface...

interfaccia ipc
client lancia il srv wrapper solo se richiesto da linea di comando
ipc prevede un sottosistema di ipc (altro canale o indirizzo, ecc.) dove inviare ricevere richieste di srv-wrappers
così si implementa il sistema dei servizi
implementare anche i "listener" cioè ipc bilaterale
fare interfacce per ipcclient ed ipcserver, poi implementare ipc via stream così lo riutilizzo per tutto
ripensare però alle interfacce stream compatibilmente con i socket o simili dove non si torna indietro
quindi o si astrae un comportamento generale che prevede il rewind, altrimenti 2 tipi di stream 
ad es. composti da due interfacce come streaminput+positionablestream (in contrasto ai limited-size-full-access-stream)
i socket potrebbero essere associati a degli stream che in realtà sono dei buffer dinamici dove ad ogni read vengono 
rimossi i dati letti dalla testa del buffer e dove la fine del buffer coincide sempre con i dati ricevuti 
e non ancora letti

ipc, forse, lancia eventi on-connect, on-disconnect, on-data-change, ecc. per comunicare all'altro estremo 
del canale quello che succede dall'altra

i parametri di ogni metodo di interfaccia solo ora accettano e ritornano Data*, in futuro accettano e ritornano 
qualunque numero di argomenti (completa c++ compliance) con la sola condizione che derivino tutti da Data. 
così facendo garantisco la ipc, ma anche la completa verifica type safe a compile-time. in pratica ogni struttura 
dati è riconducibile ad un'opportuna combinazione di Number, Text, Vector dove quindi nella classe derivata ci sono 
solo dei metodi che fanno da wrapper verso getnum, gettext, getvec, ma avere dei singoli metodi garantisce la 
correttezza semantica e di tipo del dato richiesto

nella massima astrazione anche Number e Text sono riconducibili and un vettore di interi (char, int, long, long long)
NB anche gli operatori!!! ovviamente rivisitandone il significato standard

per i number definisco la mia codifica consentendo: interi, decimali, virgola mobile, razionali, irrazionali, 
complessi, n-vettori, ecc. insomma tutti i tipi matematicamente necessari...ovviamente, tenendo presente che 
alcune codifiche devono avere requisiti matematici puri per le necessità strettamente matematiche, altre invece, 
devono avere dei requisiti di performance (codifiche di default) in base al hw sottostante

le codifiche sono astratte e generali nel senso che definiscono implicitamente sia il tipo di dato, che la sua 
rappresentazione...ciò vuol dire che un numero esadecimale lo posso mettere in un oggetto Number (forse...verificare!). 
in particolare significa che la codifica astrae dal significato (numero/testo)...la distinzione tra i concetti 
"quantità" e "qualità", è definita dagli esseri umani...in realtà il concetto di quantità può essere ricondotto 
al concetto di qualità (un po' tipo i numeri romani)...analogamente al raffronto tra lingue con alfabeto e lingue 
con ideogrammi

considerato anche che numeri e testo sono la stessa cosa, che la codifica indica il tipo/rappresentazione, 
per i numeri/testi non è automatica la relazione di uguaglianza (=, !=, <, >, <=, >=), così come le operazioni 
basilari...quindi in puro stile matematico, le relazioni e gli operatori standard non sono a priori definiti, 
ma possono essere cambiati dinamicamente...ad es l'ordinamento del testo può essere in base al codice ascii, 
oppure in base al contesto a<b<c<... ed i numeri vengono comparati coe numeri e non come stringhe, oppure possono 
esserci altre relazioni di ordinamento arbitrarie (per specifiche esigenze...ad es un'analisi di contesto che 
interpreta anche i numeri romani, le formule matematiche, ecc.)

quindi posso pensare di definire tutti gli operatori standard del c++ che wrappano su delle generiche interfacce 
operatore/relazione (nel senso matematico), definendo degli operatori/relazioni standard che abbiano come subset 
almeno i principali operatori c++.
in generale operatori/relazioni vengono definiti tramite metodi e non mai tramite gli operatori c++ che vengono usati 
solo come wrapper per le cose più comuni, ma che sarebbe bene anche farne a meno.
a tal proposito ritorna ancora più evidente l'utilizzo dei vettori come container generale e come oggetto di 
passaggio parametri/risultato, superando quindi le limitazioni del c++ (e la maggiorparte dei linguaggi).
per i vettori (ma anche numeri/testi) ha senso invece l'utilizzo degli operatori []
una implementazione (lenta) degli op/rel potrebbe essere quella con un unico metodo "op(params)" dove in params 
codifico quale op/rel richiamo, altrimenti dovrei definire degli operatori/rel singleton (e non classi statiche 
perchè altrimenti non posso avere il puntatore) i cui puntatori li memorizzo negli oggetti num/txt.
NB op/rel agiscono in genere in maniera astratta sul singolo "carattere" se poi l'azione sul carattere/vettore 
opera nel contesto numerico o testuale o se tiene conto o non della codifica (solo codifiche testo e specializzata 
alla particolare codifica, oppure tutte le codifiche o solo un subset particolare, ecc.)

la differenza tra testo e numero è che il testo ammette un unico set di valori in qualunque posizione e la dimensione 
dell'oggetto è variabile, mentre il numero ammette diversi set di valori in determinate posizioni (assolute/relative). 
quindi per il momento li tratto diversamente per efficienza computazionale

nella de/serializzazione di chi deve essere la resposabilità di serializzare type, size, wide? idealmente dovrebbe 
essere l'oggetto stesso, ma poi vector come potrebbe fare correttamente la deserializzazione senza sapere in 
anticipo quale oggetto costruire sul quale poi fare il read? ...provare con il polimorfismo, cioè Streamable legge 
type, size, wide e demanda il resto ad un oggetto in base a type...non torna...
soluzione ridondare il tipo così: vector de/serializza anteponendo il tipo rtti cioè un id per la classe giusta 
per il tipo di dato => l'interfaccia Streamable deve supportare la rtti magari con metodi statici...pensare bene!!!
ma se io ho detto che tutto è riconducibile a vactor, number, text, allora basta fare come ora tipo=1,2,3

cercare c++ reflection...

- concetto filosofico discreto di carattere e linguaggio e altri concetti correlati:
un "carattere" è un elemento (uno stato) appartenente ad un insieme finito, dal punto di vista fisico un carattere 
è uno stato di un'entità fisica o fenomeno appartenete ad un sottoinsieme finito degli stati possibili (che 
potrebbero essere infiniti...). ciò significa che se un alieno comunica variando gli spin atomici o gli stati 
energetici dell'atomo, fotoni, muoni, orbita gravitazionale, ecc. insomma con questa definizione possiamo 
accomunare il suo linguaggio al nostro e prevedere delle regole di traduzione già definibili intrinsecamente 
in questa "matematica del linguaggio"...in pratica ogni fenomeno fisico o metafisico, ogni concetto astratto 
può essere utilizato per comunicare...NB anche tra umani incoscientemente la comunicazione avviene anche 
tramite linguaggi "non verbali" definirli o recepirli o interpretarli "matematicamente" è possibile con la 
"matematica del linguaggio" qui definita (pensare agli autistici, gli animali, le piante, gli alieni ed ogni 
altra forma di vita...anzi può essere definito anche il linguaggio delle entità non viventi o addirittura 
dell'universo o degli universi...che non è altro (quasi) che il linguaggio fisico che viene cercato di tradurre 
il più fedelmente possibile dagli umani tramite il linguaggio matematico).
NB la definizione di carattere fondamentale andrebbe associata ad un fenomeno fisico reale per avere senso 
chiamarlo "fondamentale"...
nella pratica quotidiana invece definisco "fondamentale" ciò che mi fa più comodo (come nelle migliori famiglie 
matematiche)

- concetto filosofico continuo di carattere e linguaggio e altri concetti correlati:
è possibile definire la "matematica del linguaggio" anche tramite concetti "fuzzy", ovvero il carattere non come 
"stato distinto" ma come "punto continuo" cioè come stato reale continuo cioè non più come stato orbitale 
di un atomo, ma ad es. come lunghezza d'onda di un fotone o una radiazione qualsiasi o suono...chiaramente il 
"linguaggio continuo" (o fuzzy) è poco pratico nella realtà umana odierna e troppo sforzo rispetto alla mia 
utilità, perciò per il momento mi focalizzo sul linguaggio discreto...

- esempio di carattere discreto fondamentale: valore di un byte...potrebbe essere anche il bit, ma la scelta sarebbe 
ottimale per le cpu ed un linguaggio macchina, per il c++ e linguaggi di alto livello ha più senso scegliere 
come carattere fondamentale il valore di un byte ovvero il valore di un tipo di dato "unsigned char". il tipo 
di dato "unsigned char" rappresenta l'insieme degli stati possibili ovvero dei caratteri possibili
"alfabeto" = tutti i possibili valori ammessi per un carattere, ovvero l'insieme degli stati considerati

- linguaggio discreto:
"carattere fondamentale": valore appartenente ad un unsigned char (typedef unsigned char charf)
"carattere complesso": valore appartenente all'insieme di tutte le combinazioni possibili di più caratteri fondamentali
(cioè "c" appartentente all'insieme dei valori possibili di charf[d] dove d è la dimensione "wide" del car.compl.)
es. unicode_character -> charf[2], ascii_character -> charf, o charf[1]
"complessità" (o larghezza o wideness): numero di caratteri fondamentali che compongono il carattere complesso
NB non utilizzare mai charf da solo, bensì charf[d] anche se d=1 per non perdere di generalità, cioè filosoficamente 
significa che l'elemento fondamentale viene considerato "teorico" o "mistico" e passare dal trattare lo stato 
"mistico" di limitata utilità pratica (cioè non serviva tutta 'sta manfrina se rimanevo chiuso in 8 fottutissimi bit) 
allo stato "complesso" cioè nello spazio dei caratteri complessi, dove complessità 1 è un caso come gli altri...
NB carattere complesso significa l'aver implicitamente introdotto il concetto di "insieme finito ed ordinato di 
elementi"...diamogli un nome!!!
"insieme finito ed ordinato di elementi (caratteri fondamentali)": sequenza finita (cioè sequence == charf[])
sequenza finita: ha un inizio ed una fine (stringa -> non mi piace come nome)
sequenza infinita (semi-infinita): ha un inizio ma non una fine (stream -> non mi piace questa ambiguità)
sequenza bi-infinita (infinita): non ha inizio e non ha una fine (stream -> non mi piace questa ambiguità)
rete (net): generalizzazione delle sequenze
rete finita: ha un nodo di inizio ed ogni possibile path termina (con una foglia)
rete infinita: ha un nodo di inizio ed ha almeno un path infinito
rete bi-infinita: rete infinita dove non esiste nemmeno il nodo iniziale, ovvero ogni path è una sequenza bi-infinita

cosa faccio definisco stream come sequence? oppure? ...

class Character represents complex characters finite sequences -> depending of the context it may represent
a text string or a number (bool, int, float, etc.).
Text and Number classes inherit this class to provide specific contextual functionalities and facilities.
Paradox: defining a language means using a predefined language for definition (tautology).
we assume the predefined languages to be c++ language and basic "numeric" language with "character" alphabet.
we don't care what happens inside methods, only the interface is important to behave as theory wants.
numeric language is not required, quantities (wideness, ordinal position) are conceptually "characters"
the important thing is to guarrantee to have enough "states" (size of number) to represent dynamically
any complexity.
complex characters are defined on behalf of fundamental characters.
we defined the fundamental character
we define an intermediate complex character to behave as a big enough number useful to easily define
complexier characters

ambito testo ed ambito numerico: se ho del testo unicode, ho 16bit per rappresentare caratteri che non hanno 
significato numerico per cui all'interno del testo uso alcuni caratteri (0-9) per rappresentare dei numeri... 
altrimenti dovrei cambiare contesto e passare dalla codifica unicode alla codifica "int16" e mi basterebbe 
un solo carattere per rapresentare in numero 32000, anzichè 5 caratteri 16bit in unicode...questa è traduzione 
alfabetica, cioè il mappare un alfabeto in un altro.
tale questione è di non poca rilevanza perchè mi pone delle domande su come trattare testo e numeri, considerando 
anche che vorrei utilizzare per entrambi le sequenze e che bisogna tenere presenti i problemi di allineamento 
di memoria.
credo di non avere problemi ad usare le sequenze per entrambi facendo attenzione all'alineamento affinchè possa 
tradurre da/verso i basic data types / sequenze tramite dei semplici c-cast dei puntatori alle sequenze/numeri. 
l'altro problema dovrebbe risolversi in parte (ma è un semplice rimandare il problema) memorizzando nella sequenza 
la codifica utilizzata...il che mi permette di sapere che cosa ho nella sequenza (testo ascii, numeri puri, ecc.)

che cosa posso fare con i caratteri da soli? niente (pensare a controindicazioni)
tutto quello che voglio fare lo devo fare sulle sequenze (eventualmente sequenze monocarattere)
come sto usando Character nella definizione di CharacterSequence, in pratica è come se fosse un numero altrimenti 
dovrei ricadere nel paradosso di usare CharacterSequence per definire CharacterSequence, l'alternativa sarebbe 
utilizzare i basic data types per definire CharacterSequence.
oppure potrei usare Character semanticamente come numero definendo in esso la sola relazione ordinale e nessuna 
operazione, quindi ai soli fini di ordinamento ed implicitamente di dimensionamento (cioè attribuire delle grandezze). 
CharacterSequence invece la uso per definire i numeri come li conosciamo noi, ovvero con le operaioni ed il resto.
NB mi devo interrogare sul perchè voglio veramente i numeri come sequenze anzichè come caratteri perchè la naturale 
associazione sarebbe Character = numeri, CharacterSequence = testo...ma io voglio uniformare soprattutto ai fini 
dello streaming/serializzazione, ma in realtà anche per un altro motivo: con le sequenze posso definire teoricamente 
numeri infiniti e le operazioni rimangono nello stesso spazio (delle sequenze semifinite) altrimenti n+m=k dove 
k ha complessità +1 rispetto ad n,m.
potrei prendere due piccioni con una fava così (pensare bene): uso Character come numeri veri cioè uniformo non più 
numeri con stringhe, ma numeri con caratteri e nello streaming uso le sequenze (generiche). in pratica devo memorizzare 
l'encoding nel singolo carattere (waste of memory for strings), le sequenze sono nient'altro che un wrapper...

devo definire classi diverse: "Sequence" come sostituto generale di "vector" e CharacterSequence come sostituto di 
testo e numeri. ciò vuol dire che anche se concettualmente simili, si utilizzano in modo diverso ovvero Sequence 
è un conteiner di oggetti Streamable, o un container per "net"? o altro? ...pensare...

cosa devo poter fare con le sequenze di caratteri:
- tipiche operazioni sulle stringhe (append, substring, ecc.) e sui numeri (+,-,*,/,%)
- relazioni generiche (unarie, binarie, n-arie, ecc.)
- operazioni generiche
- funzionali vari
- passare a spazi diversi (cambiare wideness) gestendo anche il passaggio di codifica
- passsare da una codifica all'altra nello stesso spazio

ho deciso:
- basic char: float
- big char?: se si allora è un double...intanto lo definisco, cerco di non utilizzarlo (deprecato) però se serve, c'è!
- complex chars: NO ARRAYS (character[])! se servono caratteri grossi allora uso la classe Character con tutte le 
operazioni definite tali e quali alle op definite dal c++ sui float/double...NB pensare bene ad un'implementazione 
veloce per la MIA rappresentazione floating point sui multicaratteri...NB definire una rappresentazione "numerica" 
significa definire la famosa relazione ordinale in base alla quale sono poi automaticamente definite le operazioni 
numeriche standard. per il momento implemento il minimo indispensabile, magari vedo se posso fare la furbata di 
definire Character come typedef di double...tutto dipende da come utilizzo Character in CharacterSequence...
- char seq: in pratica è l'estensione per le stringhe con caratteri di ampiezza qualunque...per il momento mappo 
tutto in puntatori a character[w][s] dove w=1 per tutti i casi pratici NB w=1character=sizeof(float)=word=4bytes...
più del necessario ma si guadagna in velocità "portabile" perchè tanto per allineamento anche char prende 4bytes 
e quando non lo fa, fa perdere velocità...perciò la mia decisione è giusta così.
ora devo decidere se char seq rispetto alle operazioni si deve comportare come stringa o come Character (cioè 
come un numero)...e qui è che si apre il mondo perchè se devo poter usare sia character che Character che 
CharacterSequence come numeri ci deve essere un senso...ed in effetti c'è: l'esistenza della relazione ordinale!
inoltre c'è anche un altro motivo: concettualmente caratteri complessi e sequenze di caratteri sono la stessa cosa, 
ma sono solo ambiti (spazi) diversi...perciò definisco le operazioni sulle seq di caratteri in base alla relazione 
ordinale..ergo devo prima definire bene la relazione ordinale STANDARD (poi altre custom le posso mettere comunque) 
magari in futuro per fare le cose fiche definisco l'interfaccia "relazione ordinale" di cui la rel.ord.standard è 
un'implementazione, poi definsco le op standard tramite l'interfaccia rel.ord.

problema: float o double? l'ideale per le performance, il range e l'utilizzo sarebbe double, ma sprecare 8bytes per 
un carattere quando di solito ne basta 1, è un po' troppo...a meno che...furbatona...uso le dimensioni frazionali!!! 
e perchè no? tanto i numeri possono essere con la virgola (double) (NB attenzione alla precisione e gli arrotondamenti 
dei numeri in virgola mobile...) avere sequenze di un alfabeto sottospazio aumenta anche la generalità...quindi, 
tutti contenti!!! deve solo essere arrotondato ad 1byte
...a questo punto potrei anche abbandonare Character (o rinominare character in Character) ed usare esclusivamente 
le sequenze sia come caratteri-complessi/grandi-numeri che come stringhe...dovrei solo fare attenzione a non 
incappare nuovamente nella dipendenza ciclica di una classe da se stessa...
domandona: ma che senso ha usare caratteri complessi quando il linguaggio prevede allocazioni di dimensione massima 
pari al maxvalue-of-size_t? -> devo definire un oggetto Memory (singleton) che alloca dealloca memoria di qualunque 
dimensione e ciò grazie all'uso dei caratteri complessi o sequenze come parametri...avere limitazioni dentro Memory 
ha molto senso perchè è un'interfaccia verso l'hardware disponibile che ha i suoi limiti fisici e quindi tutto va 
bene se non fosse per il fatto che Memory dovrebbe essere un srv? per il momento me ne frego ed uso Memory come 
un semplice componente della core library, ma poi dovrò pensare a come si deve interfacciare l'hardware con i 
srv e come gestire l'accesso simultaneo...per le periferiche secondarie/lente non è un problema, la cosa difficile 
è gestire componenti basilari come cpu/memoria soprattutto se voglio supportare ad es "memoria hot-plug"...

Character non ha encoding all'interno perchè per descrivere l'encoding mi servirebbe un Character (o sequenza) 
ma sarebbe una dipendenza ciclica, in realtà un carattere è uno stato che da solo non significa niente, l'encoding 
poi è una mappatura ad un altro alfabeto

relazione ordinale: per le sequenze (sia Character che CharacterSequence) a sinistra c'è il carattere meno 
significativo (cioè il contrario dei numeri), le sequenze più lunghe sono "maggiori di" (così come 20 è maggiore 
di 3) quindi da destra a sinistra è maggiore la sequenza col primo carattere (da destra) che sia "maggiore di", 
si arriva quindi alla comparazione tra carattere complessi che in genere hanno larghezza diversa e per i quali 
la comparazione si fa con lo stesso procedimento (in pratica sono array di double, dove quello di sinistra è 
"il meno significativo"...e rappresenta una cifra come se fosse il sistema arabico al contrario), si arriva 
quindi al carattere fondamentale che ha il suo ordinamento definito a priori.
operazioni fondamentali: da quanto sopra la somma si fa carattere a carattere da sinistra a destra con il riporto...
e l'equivalente dei numeri decimali? ...mi servono le sequenze ad indice negativo e quindi i numeri con indici 
negativi sono l'equivalente dei numeri dopo la virgola...mi sembra perfetto!!!
con questa estensione (seq negative), bisogna espandere anche "append": append left, right, centre; dove 
appleft mette la seq di sinistra alla estremità sinistra di quella di destra (es "asd.asd" al "qwe.qwe" = 
"asdasdqwe.qwe"), appright analogamente (es "asd.asdqweqwe"), appcentre pure (es "asdasd.qweqwe")

pensare se voglio le sequenze fast (anche se grosse) e le sequenze generali o solo quelle generali

nuove decisioni:
- utilizzo fast tramite "character" sia come carattere che soprattutto come numero (double) => massime performances 
(almeno su architetture 64bit, su 32bit sono al max doppie dei float...in ogni caso è inutile guardare al passato 
per ottimizzare, col passato al massimo si mantiene la compatibilità, ma solo se non compromette il futuro -> 
principio di carattere generale)
- rimane il problema che non posso rendere "character" intrinsecamente streamable, per cui potrei pensare 
al contrario, ovvero non rendere gli oggetti streamable, ma gli stream capaci di serializzare determinati 
oggetti...però questo vuol dire perdere di generalità...ma potrebbe essere anche un bene perchè così vincolo cosa 
può essere serializzato
- utilizzo di sequenze con il max della generalità, ma con il limite di essere finite <=> sono numerabili tramite 
character...matematicamente: <S,C,A> è uno spazio finito <=> l'insieme delle sequenze S e l'insieme dei caratteri C 
hanno cardinalità inferiore o uguale alla cardinalità di A, cioè <=> dato n il numero di elementi di A, le sequenze 
hanno al massimo n caratteri ed il numero degli elementi di C (caratteri) è al massimo n
NB A è un sottoinsieme di N
- in pratica fisso lo spazio massimo accettabile <S,C,A> pari a <S,double,double> (NB ascii=<S,char,double>)
dove per "double" intendo la parte intera del double
- le sequenze infinite sono matematicamente un'altra cosa, nella realtà non è detto che esistano, quindi 
è accettabile escluderle, ma devo comunque considerare delle cardinalità arbitrariamente grandi
- astraggo i limiti fisici tramite l'utilizzo di una classe "Memory", ma rimane il problema della cardinalità
- attualmente i limi me li impone il compilatore con i basic data type (double) perchè anche se astraggo con 
una classe (perdendo molta velocità) i limiti rimangono implicitamente dall'uso dei basic data types all'interno 
della classe (il problema è ricorsivo...alla fine arrivo sempre a double/long-long) anche se uso gli array e 
anche se uso i puntatori...per allocare la memoria arrivo sempre a funzioni o elementi del linguaggio che 
richiedono l'uso di basic data types...che fare? l'unica soluzione sembra l'utilizzo della ricorsione e dei 
puntatori (es tipo le liste) cioè gestisco blocchi con i bdt al massimo delle possibilità, poi i puntatori 
a tali blocchi li metto in un blocco...i puntatori a tali blocchi li metto in altri blocchi, ecc. insomma 
mi si viene a creare una struttura ad albero arbitrariamente ricorsiva che mi nasconde i limiti della memoria fisica. 
ci sarebbe il problema dell'accesso (indirizzamento) che può essere altresì risolto con la ricorsione (es 
root->getblockpointer()->getelempointertoblock(i)->getelempointertoblock(j)->getelempointertoblock(k)->...) 
in pratica un albero "arbitrariamente finito" che è l'esatto equivalente matematico che voglio ottenere...ora 
devo capire come renderlo pratico...uso Memory come albero che mi permette di avere un'allocazione di memoria 
arbitrariamente lunga (NB andrebbe ugualmente bene (o addirittura meglio?) utilizzare una classe Array), devo solo 
studiare l'interfaccia adatta che mi consenta di: sapere la dimensione lineare accedere ad un blocco tramite 
un'indirizzo ricorsivo e di lunghezza ricorsiva specificata, cioè del tipo 
"Memory* Memory::getBlock(Recursive address, Recursive size)" fregandosene ampiamente della sincronizzazione, 
thread safety ecc. un'interfaccia di quel tipo può rappresentare la base per array multidimensionali (tra le 
altre cose) di arbitrario numero di dimensioni e di arbitrarie dimensioni dove NB "Recursive" non può essere 
banalmente "Memory*" poichè concettualmente sono due cose diverse ed infatti le interfacce devono essere diverse. 
Recursive ha praticamente il significato di un carattere (o numero) arbitrariamente grande (NB al posto di 
size dovrei usare address2 per evitare di introdurre i concetto di numero che mi riporterebbe ricorsivamente 
ai problemi iniziali, quindi Recursive rappresentano "indirizzi" astratti/virtuali di memoria lineare, vabbè è 
inutile, si può lasciare size che sarebbe lìindirizzo virtuale (rispetto a se stesso) massimo che il sottoblocco 
avrebbe) Recursive in pratica è un carattere complesso (cioè Character) ovvero un array arbitrariamente lungo di 
caratteri base (character)...quindi dopo tutte queste considerazioni emerge che posso definire una classe 
CharacterSequence che lavora in due modalità: una fast con tutte le interfacce basate su character, quindi 
opero nell'ambito di una "foglia concettuale", l'altra modalità ricorsiva dove ci sono interfacce basate su 
Character per il quale vale lo stesso discorso...internamente sia CharacterSequence che Character usano Memory 
per il quale vale lo stesso discorso opera su character finchè può, poi passa a Recursive che però è un Character 
quindi ritorna il problema di ciclicità a meno che seppur concettualemente identici distinguo Character da 
indirizzi e dimensione utilizzando il concetto di ordinamento...insomma tutto sto casino per decidere che alla 
fine non è vero che tutto è un carattere ma tutto è un numero! ...è già, perchè posso pure dire che l'ordinamento 
è un concetto astratto e che lo costruisco ricorsivamente così come i caratteri, ma dietro il concetto di 
ordinamento ci sono i numeri che guardacaso si costruiscono ricorsivamente e quindi??!!! facciamo finta di niente 
definisco un altro nome che non sia "carattere" o "numero" ad es tipo "ordinalem/ordem/ore/etc." (ordinal element) 
così astraggo ulteriormente dicendo che un linguaggio deriva dalla definizione di una relazione base su un insieme 
(finito, infinito, discreto, continuo) di stati...ora bisogna capire se questa relazione deve essere per forza 
di ordinamento e/o che caratteristiche deve avere. sulla base di un linguaggio base posso definire delle regole 
ricorsive di espansione del linguaggio per incrementarne (e daje co' 'sti numeri) le possibilità.
NB comunicare vulo dire sparare sequenze di caratteri...sequenze appunto, quindi l'ordinamento lineare è 
il prerequisito per la definizione di un linguaggio.

alla fine sono troppe pippe mentali per il momento e forse è meglio continuare con number=double e text=wstring, 
oppure pensare di espandere text in modo che sia anche considerabile come sequenza di "number"...
a questo punto c'è il problema dei vettori/data: gli array/vettori sono insiemi ordinati che abbiamo stabilito 
essere alla base di qualunque cosa (linguaggi, numeri, caratteri), cioè l'ordinamento genera le sequenze/vettori 
le quali generano un linguaggio.
quindi partiamo dall'ordinamento implicito nei "double del c++" definito a priori, su questo definiamo le 
sequenze (generiche sia per caratteri, oggetti, ecc.), qui c'è un solo problema: sequenze omogenee ok, eterogenee 
non banali per via del fatto che non sono direttamente supportate dal linguaggio posso utilizzare i puntatori e 
l'allocazione dinamica, ma non so cosa c'è dentro, per le sequenze generiche forse mi può andare bene ma non 
sono streamable...
ecco la paraculata: number è l'elemento base, tutto il resto è una sequenza di number e sequenze (implica un gran 
spreco sulle stringhe a parte che posso rimappare l'array...) quindi è la sequenza che si occupa di serializzare 
i double, le sequenze richiama i loro read/write...rimane il problema di come faccio a sapere se in una posizione 
della sequenza c'è un double o un'altra sequenza (NB queste sequenze sono in realtà delle reti...)...posso imporre 
di passare al concetto di rete e tenere due liste distinte una per i double, una per i puntatori ad altre sequenze 
(NB nel concetto originario, avevo considerato i record al posto dell'array di double, o un solo elemento...ma 
qui siamo andati oltre astraendo da tutto abbiamo ricondotto tutto ai numeri) così ho definito delle sequenze 
semiomogenee sulle quali posso derivare un'altra classe per implementare il concetto generale delle sequenze 
eterogenee base semplicemente introducendo una sequenza di indirizzi dove mischio puntatori a double e puntatori 
ad altre sequenze nell'ordine che preferisco in pratica una mappatura! se poi voglio introdurre dei tipi complessi 
come i record, le matrici, le mappe, ecc. basta che riconduco tutto a double e sequenze e creo una classe wrapper 
che offre i metodi per offrire le funzionalità tipiche di quel tipo complesso. ovviamente le sequenze devono 
implementare tutte le operazioni e funzionalità che si possono inventare sulle sequenze (considerando anche che 
ho un due array in ogni sequenza)

il risultato di quanto sopra è l'avere una base che mi permette di generare qualunque cosa e che basilarmente mi 
offre le funzionalità richieste dalla mia infrastruttura, ovvero la serializzazione ed in futuro chissà cosa...

problema: ownership dei dati e puntatori contenuti nelle sequenze ad es se deleto un nodo, deleto in cascata 
tutti i path? se fosse un grafo ciclico sarebbe l'autodistruzione perchè cancellare un nodo, cacellerebbe tutto 
il grafo...probabilmente lo lascio come opzione di creazione del root node e come metodo richiamabile, gli altri 
nodi possono essere creati sono tramite il nodo padre...pensare anche se sembra ok così...

riorganizzare: template base uguale a std::vector con le mie funzionalità e basta, poi sequence implementa 
Streamable ed offre solo due metodi: miovector<number>* getnumbers() e miovector<Sequence*>* getsequences() 
così evito di duplicare i metodi e le implementazioni ed è molto più razionale

riorganizzare: template base uguale a std::vector con le mie funzionalità + l'accesso raw tramite puntatore al 
array per consentire di memorizzare il puntatore ed avere poi l'accesso alla massima velocità e basta. quindi 
ora ho una classe per manipolare le sequenze omogenee ma anche un accesso velocissimo ed una manipolazione 
diretta dei dati senza overhead. il limite è la memoria contigua, cosa di cui me ne frego perchè se ho una 
quantità spropositata di dati e l'hardware è pietoso, non è un mio problema! casomai è un problema del compilatore 
...ma nemmeno!
dunque, a me servono le sequenze di sequenze, le sequenze di number e le sequenze raw di ampiezza che decido io 
e cioè sequenze di ascii, sequenze di unicode, ecc. il problema è che usando i template non posso definire 
direttamente le seq di seq perchè devo specificare il tipo, quindi potrei usare le seq di streamable ma non 
va bene perchè dovrei fare i dycast, l'alternativa sarebbe le seq mutevoli cioè come i template, ma a runtime!
NB approfondire come il c++ gestisce l'accesso agli array multidimensionali (se fa somme, moltiplicazioni, ecc. 
con i puntatori, indici ecc.)
potrei usare dei metodi reshapeas... che cambiano l'ampiezza del singolo elemento dell'array, quindi il raw deve 
essere void* ed uso i metodi get... per avere il tipo voluto, questo implica che non posso più usare l'operatore [].

ho una seq dentro ci posso mettere puntatori ad altre seq, oppure elementi number, oppure elementi generici di 
ampiezza (in bytes) non definita a priori, oppure definite le sottodimensioni di number, ovvero num8-16-32-64. 
in questi sottotipi ci posso mettere quello che mi pare numeri piccoli, interi, float, stringhe ascii, stringhe 
unicode, ecc. cioè number è il tipo naturale che mi consente tutto alla max velocità, gli altri sono tipi di 
ampiezze esatte e predefinite per particolari esigenze (spazio, interfacciamento, ecc.) mettendo la velocità 
in secondo piano, fare il reshape è deprecabile perchè altero il tipo originale che ci ho messo dentro, quindi 
è preferibile usare i templates, perchè tanto alla fine devo sempre gestire i diversi tipi suddetti. quindi 
ho 5 tipi ed una seq template che mi genera altrettante 5 seq, poi ho una seq di puntatori che mi ritorna seq
dei vari tipi (5+1) il problema è che la seq di seq non la posso fare...o faccio la seq di streamable e poi 
l'utente fa il dycast, oppure faccio una derivata di questa ed aggiungo dei metodi che wrappano il dycast. 
l'uso del template mi serve anche per mantenere il raw array del tipo specificato.

faccio seq tale che nel costruttore decido cosa conterrà (no templates) ha metodi che ritornano tutti i tipi 
previsti (seq, number, num8-16-32) che lanciano un eccezione se il tipo non è corrretto
---
Sequence& s;

char8seq c8s = s.get(0);
number n = s.get(1).get(0);
c8s.append("asd");

Sequence s1; // sequence of sequences
Sequence s2((number) 2); // sequence of char16
Sequence s3(0); // sequence of numbers

number n = s3[0];
s3[s3.size()] = 0;
Sequence s = s1[0]; // reference

non è possibile perchè l'operatore [] ritorna lo stesso tipo, si potrebbe fare solo con i templates...quindi diventa:
number n = s3.getnumber(0); // reference
s3.getnumber(s3.size()) = 0; // reference
Sequence s = s1.getsequence(0); // reference
s3.subsequence(6, 9); // tipo in base alla costruzione

s.number().get(0); s fa un dycast di se stessa a seq di numbers

+++

come ottenere ciò?:
number[] n = s.get(0);
text t = s.get(1);
sequence* sq = s.get(2);

tengo un void* (in realtà char o num8) usando realloc che mantiene il contenuto che posso castare ad array di 
qualunque cosa (number, num8-16-32, seq, ecc.) devo fare attenzione ai num16-32 perchè sono array e devo vedere 
che succedo se li casto a int, long ecc. 
che operazioni consentire? resize (basato su num bytes == realloc), le assegnazioni le faccio tramite array ottenuto 
da get(). 
in realtà potrei memorizzare qualunque dato come se fosse una struct immaginaria dove l'utente accede specificando 
indice (numero di byte) e tipo da ritornare (number, num8-16-32, void* pointer) dove gli indici potrebbero anche 
essere dei define per esplicitare una singola struct immaginaria. 
potrei anche pensare le seq come seq di number assicurandomi che sizeof(number) possa contenere i puntatori (cioè 
puntatori a sequence*), ma come gestisco il problema dei sottotipi?
allora creo diversi get che mi ritornano array del tipo che mi serve (reshaping) ed internamente impostano il wide 
appropriato così tutte le successive operazioni si basano su questo, cioè il get fa il reshaping implicito, oppure 
prevedo il reshape esplicito e se uso il get sbagliato lancia un'eccezione. posso anche imporre il wide in fase di 
costruzione ed impedire il reshape...
in pratica i number li accedo direttamente il testo e le seq no lo uso implicitamente e ci faccio operazioni sopra... 

numeri, sequenze di dati (numeri, testo, ecc.), sequenze di puntatori a sequenze. 
posso decidere che le sequenze siano omogenee, il che significa che i dati (numeri) sono solo sulle foglie, altrimenti 
ho sequenze di numeri in ogni nodo, mi sembra più ragionevole la prima ipotesi...
usando i templates avrei data=seq<streamable*> per cui poi dovrei fare un dycast da streamable* a seq<number>

number n = dynamic_cast<numseq>(params.get()[0])[0]; // un vero casino
sequence s = dynamic_cast<sequence>(params.get(0));
numseq sn = dynamic_cast<sequence>(s.get(0));

ritorniamo al discorso che data=params=seqseq dove get ritorna numseq o seqseq, quindi seq potrebbe avere un array 
di puntatori a sequenze di vario tipo quindi se seq è numseq allora avrà un array di un elemento che punta ad array di 
numeri se 

number[] n = s.get(0).raw();
sequence* sn = s.get(0);
number m = sn.raw()[0];
text t = s.get(1);
sequence* sq = s.get(2);

number n = (number) p.buf[0]; // multimatrix
string s = (num8) p.buf[0];
sequence sq = dynamic_cast<sequence>(p.buf[0]);
number n = (number) sq.buf[0];
number n = p.getseq
number n = (number) p.buf[0][0];

pensiamo tutto in termini di seqseq...è impossibile in termini di template, solo classe! così facendo si arriva a delle 
seq che in realtà non contengono altre seq, ma dati, qui posso fare il raw, ottengo un num8* (num8[]) che posso castare 
a number* o number[] o num16* (num16[])

sequence s = p.get(0);
string str = p.get(1).raw();
wstring ws = (num16) p.get(2).raw();
number[] n = (number*) p.get(3).raw();

i puntatori DEVONO essere trattati diversamente perchè nello streaming non devono comparire ma essere rimpiazzati dagli 
oggetti a cui puntano...per cui forse devo riprendere i discorsi teorici e fare il passaggio da seq a net. 

---


UNIVERSO:
partiamo dall'inizio...
esistente: concetto assiomatico primario e non definibile. 

universo: è l'insieme dell'esistente (o degli universi nella comune accezione) per il quale è sempre valida la legge 
di causa-effetto.

legge di causa-effetto: transizione/trasformazione/funzione continua dell'esistente da uno stato x ad uno stato 
x+dx sulla linea del tempo.

tempo: particolare linea a cui è stato attribuito questo nome sulla quale sembra basarsi ogni transizione/fenomeno 
dell'esistente comunemente chiamato multiverso (NB multiverso è sottoinsieme dell'universo definito da me).

NB <esistente, trasformazione/funzione, linea> sono i concetti assiomatici primari e non definibili che consistono 
nella massima astrazione umanamente possibile della realtà esistente confidando che permetta eventuali ulteriori 
astrazioni nel caso se ne dimostri la possibilità...

universo: <esistente, causa-effetto, tempo>

sequenza: ...

NB la sequenza eterogenea è il concetto più naturale basato sui concetti assiomatici...
NB sequenza è un concetto anche più astratto del concetto di universo

vediamo quindi di ricondurre il concetto di rete, grafo, ipergrafo al concetto di sequenza...
ipergrafo è un insieme di sottoinsiemi di elementi di un insieme X = sequenza di sequenze di elementi di X... dove 
l'ordinamento delle sequenze è teoricamente matematicamente superfluo, ma nella pratica è alla fine il concetto 
che permette l'accesso agli elementi...visto dal punto di vista del principio di heisenberg, sebbene esista la 
indeterminazione tra una coppia di variabili canoniche (non dipendenti) comunque ogni sottoinsieme dell'esistente 
ha un luogo ed un tempo ben preciso anche se non precisamente misurabile, anche per oggetti appartenenti allo stesso 
tempo io per accedervi o farvi riferimento, ho bisogno di coordinate, che per l'indeterminazione non posso conoscere 
e quindi usare nella pratica devo (o comunque posso) operare un'astratta mappatura di coordinate, per cui per la 
massima semplicità mappo le coordinate universali (non identificabili) nel più semplice sistema di coordinate...quello 
lineare...quindi se sono riuscito a mappare il concetto di ipergrafo (il più astratto) a sequenze, ho raggiunto il mio 
scopo! ...quindi devo usare solo sequenze!

elemento: porzione spazio-tempo dell'universo. NB qui ritorna l'indeterminazione perchè oltre al utilizzare 
concetti primitivi come "porzione", "sottoinsieme", ecc. porzione -> volume -> insieme di punti -> insieme denso di 
coordinate universali -> sequenza di coordinate universali -> sequenza di punti

ora un problema è che se considero una seq eterogenea che a sua volta può contenere altre sequenze, in teoria sarebbe 
un oggetto molto grosso, io invece devo usare i puntatori per le seq (cioè coordinata lineare consecutiva per gli 
elementi non seq e riferimenti per le seq), cioè internamente due sistemi di coordinate, che devo nascondere. 
poi c'è un altro problema che sarebbe quello che a priori dovrei (in teoria) poter accedere a qualunque tipo di 
oggetto

---

sequence params;
number n = params(0);
num8 n8 = params(1);
sequence* seq = params(2);
potrei fare che op() ritorna una sequence e poi uso "op number()" per fare il cast implicito
se penso sequence come "omogeneussequence<streamable*>" op() ritorna il cast di uno streamable* a 
omogeneussequence<streamable*>

number n << params(0);
potrei fare che seq ritorna void* e ci metto dentro qualunque cosa, poi io che mi sono costruito il tipo X mi creo 
l'operatore <<(X, void*) che mi fa il cast trasparentemente...forse al posto dovrei usare Streamable*, ma poi non ci 
posso mettere gli integral types, oppure per i tipi integral forzo la conversione (reinterpret_cast) a void* e poi al 
tipo richiesto...NB non serve dichiarare "friend" gli op globali dentro seq (la quale non ne sa proprio l'esistenza) 
perchè non devo accedere ai dati interni faccio solo casting...

quindi:
sequence = omogeneussequence<streamable*>
sequence* sequence::operator()(number n);
number& operator<<(number& n, streamable*);

oppure:
sequence = omogeneussequence<streamable*>:sequencestreamable:streamable
omogeneussequence::operator[](int i); // trovare un sostituto all'operatore [] perchè mi impone int
sequence* sequence::operator()(number n);
T* omogeneussequence<T*>::operator()(number n);
numseq = omogeneussequence<number>
number& operator<<(number& n, streamable*);
numseq& operator<<(numseq& n, streamable*);

cioè:
number n = (ns << params(0))[0]; // quasi accettabile

anzi:
numseq ns << params(0);
number n = ns(0);
num8seq n8 << params(1);
string s = (char*) n8.raw();

così facendo le seq di streamable possono accettare puntatori di ogni tipo e posso convertire implicitamente a tutti i 
tipi...

---

problema: risolvere il problema dello streaming di sequenze quando il contenuto non è integral, cioè puntatori ed 
oggetti...posso accettare elementi integral, oggetti sequenze e puntatori a sequenze e ciò mi risolve il problema 
di sapere a priori il tipo di oggetto da leggere (Sequence è una classe Streamable non astratta e non template), ma 
devo ancora saper distinguere fra i tre casi...

forse la cosa migliore è limitarsi a tipi integral e puntatori a sequenze, sia per semplicità di allocazione di memoria 
che per flessibilità, che per evitare problemi di blocchi troppo grandi, ecc. tanto posso wrappare qualche metodo ed 
operatore per gestire come input/output sia i puntatori che gli oggetti (reference ad oggetti) nella de/serializzazione 
invece includo tutto ricorsivamente, sia perchè è più semplice da gestire, sia perchè è più naturale...

problemi: inserire/prendere elementi nelle/dalle sequenze, upcastare una sequence a numseq, num8seq, ecc.
upcast: ho un oggetto sequence e mi serve un operatore/funzione e specificare il tipo a cui upcastare...per far ciò 
mi serve anche un oggetto d'arrivo col tipo richiesto (ad es numseq), ma tutto questo ha un prezzo che consiste 
nell'avere una variabile ed un'assegnazione in più e complica inutilmente le cose, forse è meglio abolire le
sequenceomogeneus<T> ed utilizzare solo le sequence con l'aggiunta di funzioni template per inserire/prendere elementi 
dalla seq già castati così mi risparmio molti passaggi tra cui la definizione di ulteriori tipi (numseq, ecc.) e se 
definisco bene ed in maniera non ambigua le funzioni template, non ho bisogno di specificare il tipo nella chiamata.

inserire:
seqseq params;
const char* text;
const wchar_t* wtext;
params << num8seq(text); // aggiunge una sequenza di caratteri
params << num16seq(wtext);
params << numseq(20); // aggiunge una sequenza di un numero
params << numseq({20, 30, 40}); // aggiunge una sequenza di tre numeri
quindi mi serve un costruttore che prende puntatori ad array e li inserisce nella sequenza (problema: come determino 
la lunghezza da leggere? catcho un'eccezione? null terminator? pensare...)

prendere:
seqseq res;
const char* text = res(0).raw(); // buffer della sequenza alla posizione 0 di res
num16seq wtext = res(1); // sequenza di caratteri unicode usando = definito da seqomo
wstring ws = (const wchar_t*) wtext.raw();
number n = *(number*) res(2)(0); // rischioso perchè op() di sequence mi ritorna il puntatore e poi è troppo casino
number n = (*res(2))(0); // funzione template overloading sul op*...probabilmente non funziona...
number n = res(2) | 0; T operator|(sequence seq, number num)
number n = dynamic_cast<numseq>(res(2))(0); // troppo casino se non aggiungo qualcosa che semplifichi
numseq ns = res(3); // sequenza di numeri usando = definito da seqomo
*((number*) res(3).raw() + i) con il check su width può essere un modo per le funztempl
il discorso è che seqseq ritorna oggetti seq, seq ritorna void*, quindi mi servono template (classi e funzioni) che 
mi permettano a partire da una seq o void* di ottenere oggetti di tipo T.

decisioni:
per inserire uso il template operator<< dentro la classe (non template) sequence il che vuol dire che posso fare: 
sequence seq << n << text; 
rimane poi da definire come si comporta...potrebbe inserire come puntatore (facendo new, store address, copy) 
comportandosi come una vera sequenza eterogenea al prezzo di un doppio consumo di memoria per i numeri ed ininfluente 
per le stringhe, ciò avrebbe senso solo se accompagnato da intelligenti seqomo...ok, allora facciamo così: quando 
ho seq << elem, se elem è un puntatore a seq o derivate, ne prendo il puntatore e memorizzo (copio), se elem è 
qualsiasi altra cosa, costruisco (new) una nuova seqomo, ci metto dentro elem e memorizzo il puntatore in seq. 
gestita intelligentemente seq avrebbe diverse seqomo (seqomo<num8>, seqomo<num16>, seqomo<number>), cioè tante 
seqomo quante sono le stringhe, più una seqomo per tutti i number, più una seomo di seq per tutte le strutture 
complesse (record, matrici, mappe, ecc.). 
per prendere la questione è più delicata perchè potrei definire dei miei integral types (number, num8, numseq, ecc.) e 
memorizzare dentro ogni sequence il tipo contenuto e scrivere esplicitamente operatori overloaded per ogni tipo 
integral e lanciare eccezioni se uso il tipo non corrispondente...altrimenti uso operatori o funzioni template e spero 
che chi li usa lo faccia con cognizione di causa. in ogni caso ho il problema che non posso overloadare sul return type 
per cui probabilmente dovrò usare il sistema di mettere il reference della variabile risultato tra gli argomenti 
del metodo/operatore.
in breve mi serve un sistema sicuro e controllato per prendere oggetti/puntatori/numeri.
se usassi un buffer interno dove serializzo più un buffer di indirizzi, tramite la differenza tra indirizzi contigui 
conosco la dimensione del tipo memorizzato e quindi risalire al integral memorizzato (num8, num16, number, ecc.) e 
dato che nella mia concezione tutto è un numero e il cosa c'è dentro dipende dal contesto che non è affar mio, il tutto 
mi quadra...

params << string1
params << string2
params << new sequence << number1 << number2 << ecc.

cioè con i puntatori a char e wchar creo automaticamente delle sequenze ed aggiungo queste, per i numeri no aggiungo 
i numeri castati a "number"

const char* string1 << params|0
const wchar_t* string2 << params|1
sequence seq << params|2
number1 << seq|0
number2 << seq|1

number1 << params|0|0
number2 << params|0|1

number3 << params|0|0|1|3(2)
string3 << params|0|0|1|3(0) // sempre 0 finale perchè è l'array di caratteri, oppure...
string3 << params|0|0|1|3 // con opportuno overload di << con una sequenza come rvalue e char* come lvalue
number3 << params-0-0-1-3+2 ...meglio di no!

cioè operator|(number) ritorna un reference a sequenze assumendo che la seq di ingresso contenga puntatori a seq, 
operator()(number) ritorna una copia del contenuto...poi rimane il problema dell'operatore template, quindi potrei 
usare un metodo, ad es number3 << params|0|0|1|3.get<number>(2) oppure op() non è template e ritorna un puntatore 
a num8* e << viene overloadato per ogni integral type prendendo il num8* lo traduce in number (no puntatore) e lo 
casta al tipo richiesto

string1 << seq1 | i;
non va bene per via della precedenza degli operatori quindi devo trovare un'alternativa per cui al posto di | ho un 
operatore con alta priorità ed al posto di << ho un operatore con bassa priorità, non è = perchè deve essere membro, 
non può essere <<= o simili perchè implicano l'assegnazione su oggetti già esistenti...cioè...
char* string1 <<= seq1 | 1; <=> string1 = string1 << seq1 | 1;
cioè sarebbe ricorsivo...

faccio che le seq con width  negativo, hanno width pari al maggiore tra il sizeof double e il sizeof void* così ho 
ottenuto le seq eterogenee perchè possono contenere sia puntatori ad altre seq, che numeri...se invece ho bisogno di 
dimensioni esatte (come per le stringhe) fisso il width, cioè se non specifico, sono eterogenee...
