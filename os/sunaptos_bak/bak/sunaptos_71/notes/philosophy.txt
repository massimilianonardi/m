la differenza tra testo e numero è che il testo ammette un unico set di valori in qualunque posizione e la dimensione 
dell'oggetto è variabile, mentre il numero ammette diversi set di valori in determinate posizioni (assolute/relative). 
quindi per il momento li tratto diversamente per efficienza computazionale

- concetto filosofico discreto di carattere e linguaggio e altri concetti correlati:
un "carattere" è un elemento (uno stato) appartenente ad un insieme finito, dal punto di vista fisico un carattere 
è uno stato di un'entità fisica o fenomeno appartenete ad un sottoinsieme finito degli stati possibili (che 
potrebbero essere infiniti...). ciò significa che se un alieno comunica variando gli spin atomici o gli stati 
energetici dell'atomo, fotoni, muoni, orbita gravitazionale, ecc. insomma con questa definizione possiamo 
accomunare il suo linguaggio al nostro e prevedere delle regole di traduzione già definibili intrinsecamente 
in questa "matematica del linguaggio"...in pratica ogni fenomeno fisico o metafisico, ogni concetto astratto 
può essere utilizato per comunicare...NB anche tra umani incoscientemente la comunicazione avviene anche 
tramite linguaggi "non verbali" definirli o recepirli o interpretarli "matematicamente" è possibile con la 
"matematica del linguaggio" qui definita (pensare agli autistici, gli animali, le piante, gli alieni ed ogni 
altra forma di vita...anzi può essere definito anche il linguaggio delle entità non viventi o addirittura 
dell'universo o degli universi...che non è altro (quasi) che il linguaggio fisico che viene cercato di tradurre 
il più fedelmente possibile dagli umani tramite il linguaggio matematico).
NB la definizione di carattere fondamentale andrebbe associata ad un fenomeno fisico reale per avere senso 
chiamarlo "fondamentale"...
nella pratica quotidiana invece definisco "fondamentale" ciò che mi fa più comodo (come nelle migliori famiglie 
matematiche)

- concetto filosofico continuo di carattere e linguaggio e altri concetti correlati:
è possibile definire la "matematica del linguaggio" anche tramite concetti "fuzzy", ovvero il carattere non come 
"stato distinto" ma come "punto continuo" cioè come stato reale continuo cioè non più come stato orbitale 
di un atomo, ma ad es. come lunghezza d'onda di un fotone o una radiazione qualsiasi o suono...chiaramente il 
"linguaggio continuo" (o fuzzy) è poco pratico nella realtà umana odierna e troppo sforzo rispetto alla mia 
utilità, perciò per il momento mi focalizzo sul linguaggio discreto...

- esempio di carattere discreto fondamentale: valore di un byte...potrebbe essere anche il bit, ma la scelta sarebbe 
ottimale per le cpu ed un linguaggio macchina, per il c++ e linguaggi di alto livello ha più senso scegliere 
come carattere fondamentale il valore di un byte ovvero il valore di un tipo di dato "unsigned char". il tipo 
di dato "unsigned char" rappresenta l'insieme degli stati possibili ovvero dei caratteri possibili
"alfabeto" = tutti i possibili valori ammessi per un carattere, ovvero l'insieme degli stati considerati

- linguaggio discreto:
"carattere fondamentale": valore appartenente ad un unsigned char (typedef unsigned char charf)
"carattere complesso": valore appartenente all'insieme di tutte le combinazioni possibili di più caratteri fondamentali
(cioè "c" appartentente all'insieme dei valori possibili di charf[d] dove d è la dimensione "wide" del car.compl.)
es. unicode_character -> charf[2], ascii_character -> charf, o charf[1]
"complessità" (o larghezza o wideness): numero di caratteri fondamentali che compongono il carattere complesso
NB non utilizzare mai charf da solo, bensì charf[d] anche se d=1 per non perdere di generalità, cioè filosoficamente 
significa che l'elemento fondamentale viene considerato "teorico" o "mistico" e passare dal trattare lo stato 
"mistico" di limitata utilità pratica (cioè non serviva tutta 'sta manfrina se rimanevo chiuso in 8 fottutissimi bit) 
allo stato "complesso" cioè nello spazio dei caratteri complessi, dove complessità 1 è un caso come gli altri...
NB carattere complesso significa l'aver implicitamente introdotto il concetto di "insieme finito ed ordinato di 
elementi"...diamogli un nome!!!
"insieme finito ed ordinato di elementi (caratteri fondamentali)": sequenza finita (cioè sequence == charf[])
sequenza finita: ha un inizio ed una fine (stringa -> non mi piace come nome)
sequenza infinita (semi-infinita): ha un inizio ma non una fine (stream -> non mi piace questa ambiguità)
sequenza bi-infinita (infinita): non ha inizio e non ha una fine (stream -> non mi piace questa ambiguità)
rete (net): generalizzazione delle sequenze
rete finita: ha un nodo di inizio ed ogni possibile path termina (con una foglia)
rete infinita: ha un nodo di inizio ed ha almeno un path infinito
rete bi-infinita: rete infinita dove non esiste nemmeno il nodo iniziale, ovvero ogni path è una sequenza bi-infinita

Paradox: defining a language means using a predefined language for definition (tautology).
we assume the predefined languages to be c++ language and basic "numeric" language with "character" alphabet.
we don't care what happens inside methods, only the interface is important to behave as theory wants.
numeric language is not required, quantities (wideness, ordinal position) are conceptually "characters"
the important thing is to guarrantee to have enough "states" (size of number) to represent dynamically
any complexity.
complex characters are defined on behalf of fundamental characters.
we defined the fundamental character
we define an intermediate complex character to behave as a big enough number useful to easily define
complexier characters

cosa devo poter fare con le sequenze di caratteri:
- tipiche operazioni sulle stringhe (append, substring, ecc.) e sui numeri (+,-,*,/,%)
- relazioni generiche (unarie, binarie, n-arie, ecc.)
- operazioni generiche
- funzionali vari
- passare a spazi diversi (cambiare wideness) gestendo anche il passaggio di codifica
- passsare da una codifica all'altra nello stesso spazio

NB definire una rappresentazione "numerica" 
significa definire la famosa relazione ordinale in base alla quale sono poi automaticamente definite le operazioni 
numeriche standard.

problema: float o double? l'ideale per le performance, il range e l'utilizzo sarebbe double, ma sprecare 8bytes per 
un carattere quando di solito ne basta 1, è un po' troppo...a meno che...furbatona...uso le dimensioni frazionali!!! 
e perchè no? tanto i numeri possono essere con la virgola (double) (NB attenzione alla precisione e gli arrotondamenti 
dei numeri in virgola mobile...) avere sequenze di un alfabeto sottospazio aumenta anche la generalità...quindi, 
tutti contenti!!! deve solo essere arrotondato ad 1byte

sequenze con indice negativo?

pensare se voglio le sequenze fast (anche se grosse) e le sequenze generali o solo quelle generali

- utilizzo di sequenze con il max della generalità, ma con il limite di essere finite <=> sono numerabili tramite 
character...matematicamente: <S,C,A> è uno spazio finito <=> l'insieme delle sequenze S e l'insieme dei caratteri C 
hanno cardinalità inferiore o uguale alla cardinalità di A, cioè <=> dato n il numero di elementi di A, le sequenze 
hanno al massimo n caratteri ed il numero degli elementi di C (caratteri) è al massimo n
NB A è un sottoinsieme di N
- in pratica fisso lo spazio massimo accettabile <S,C,A> pari a <S,double,double> (NB ascii=<S,char,double>)
dove per "double" intendo la parte intera del double
- le sequenze infinite sono matematicamente un'altra cosa, nella realtà non è detto che esistano, quindi 
è accettabile escluderle, ma devo comunque considerare delle cardinalità arbitrariamente grandi
- astraggo i limiti fisici tramite l'utilizzo di una classe "Memory", ma rimane il problema della cardinalità
- attualmente i limi me li impone il compilatore con i basic data type (double) perchè anche se astraggo con 
una classe (perdendo molta velocità) i limiti rimangono implicitamente dall'uso dei basic data types all'interno 
della classe (il problema è ricorsivo...alla fine arrivo sempre a double/long-long) anche se uso gli array e 
anche se uso i puntatori...per allocare la memoria arrivo sempre a funzioni o elementi del linguaggio che 
richiedono l'uso di basic data types...che fare? l'unica soluzione sembra l'utilizzo della ricorsione e dei 
puntatori (es tipo le liste) cioè gestisco blocchi con i bdt al massimo delle possibilità, poi i puntatori 
a tali blocchi li metto in un blocco...i puntatori a tali blocchi li metto in altri blocchi, ecc. insomma 
mi si viene a creare una struttura ad albero arbitrariamente ricorsiva che mi nasconde i limiti della memoria fisica. 
ci sarebbe il problema dell'accesso (indirizzamento) che può essere altresì risolto con la ricorsione (es 
root->getblockpointer()->getelempointertoblock(i)->getelempointertoblock(j)->getelempointertoblock(k)->...) 
in pratica un albero "arbitrariamente finito" che è l'esatto equivalente matematico che voglio ottenere...ora 
devo capire come renderlo pratico...uso Memory come albero che mi permette di avere un'allocazione di memoria 
arbitrariamente lunga (NB andrebbe ugualmente bene (o addirittura meglio?) utilizzare una classe Array), devo solo 
studiare l'interfaccia adatta che mi consenta di: sapere la dimensione lineare accedere ad un blocco tramite 
un'indirizzo ricorsivo e di lunghezza ricorsiva specificata, cioè del tipo 
"Memory* Memory::getBlock(Recursive address, Recursive size)" fregandosene ampiamente della sincronizzazione, 
thread safety ecc. un'interfaccia di quel tipo può rappresentare la base per array multidimensionali (tra le 
altre cose) di arbitrario numero di dimensioni e di arbitrarie dimensioni dove NB "Recursive" non può essere 
banalmente "Memory*" poichè concettualmente sono due cose diverse ed infatti le interfacce devono essere diverse. 
Recursive ha praticamente il significato di un carattere (o numero) arbitrariamente grande (NB al posto di 
size dovrei usare address2 per evitare di introdurre i concetto di numero che mi riporterebbe ricorsivamente 
ai problemi iniziali, quindi Recursive rappresentano "indirizzi" astratti/virtuali di memoria lineare, vabbè è 
inutile, si può lasciare size che sarebbe lìindirizzo virtuale (rispetto a se stesso) massimo che il sottoblocco 
avrebbe) Recursive in pratica è un carattere complesso (cioè Character) ovvero un array arbitrariamente lungo di 
caratteri base (character)...quindi dopo tutte queste considerazioni emerge che posso definire una classe 
CharacterSequence che lavora in due modalità: una fast con tutte le interfacce basate su character, quindi 
opero nell'ambito di una "foglia concettuale", l'altra modalità ricorsiva dove ci sono interfacce basate su 
Character per il quale vale lo stesso discorso...internamente sia CharacterSequence che Character usano Memory 
per il quale vale lo stesso discorso opera su character finchè può, poi passa a Recursive che però è un Character 
quindi ritorna il problema di ciclicità a meno che seppur concettualemente identici distinguo Character da 
indirizzi e dimensione utilizzando il concetto di ordinamento...insomma tutto sto casino per decidere che alla 
fine non è vero che tutto è un carattere ma tutto è un numero! ...è già, perchè posso pure dire che l'ordinamento 
è un concetto astratto e che lo costruisco ricorsivamente così come i caratteri, ma dietro il concetto di 
ordinamento ci sono i numeri che guardacaso si costruiscono ricorsivamente e quindi??!!! facciamo finta di niente 
definisco un altro nome che non sia "carattere" o "numero" ad es tipo "ordinalem/ordem/ore/etc." (ordinal element) 
così astraggo ulteriormente dicendo che un linguaggio deriva dalla definizione di una relazione base su un insieme 
(finito, infinito, discreto, continuo) di stati...ora bisogna capire se questa relazione deve essere per forza 
di ordinamento e/o che caratteristiche deve avere. sulla base di un linguaggio base posso definire delle regole 
ricorsive di espansione del linguaggio per incrementarne (e daje co' 'sti numeri) le possibilità.
NB comunicare vulo dire sparare sequenze di caratteri...sequenze appunto, quindi l'ordinamento lineare è 
il prerequisito per la definizione di un linguaggio.

alla fine sono troppe pippe mentali per il momento e forse è meglio continuare con number=double e text=wstring, 
oppure pensare di espandere text in modo che sia anche considerabile come sequenza di "number"...
a questo punto c'è il problema dei vettori/data: gli array/vettori sono insiemi ordinati che abbiamo stabilito 
essere alla base di qualunque cosa (linguaggi, numeri, caratteri), cioè l'ordinamento genera le sequenze/vettori 
le quali generano un linguaggio.
quindi partiamo dall'ordinamento implicito nei "double del c++" definito a priori, su questo definiamo le 
sequenze (generiche sia per caratteri, oggetti, ecc.), qui c'è un solo problema: sequenze omogenee ok, eterogenee 
non banali per via del fatto che non sono direttamente supportate dal linguaggio posso utilizzare i puntatori e 
l'allocazione dinamica, ma non so cosa c'è dentro, per le sequenze generiche forse mi può andare bene ma non 
sono streamable...
ecco la paraculata: number è l'elemento base, tutto il resto è una sequenza di number e sequenze (implica un gran 
spreco sulle stringhe a parte che posso rimappare l'array...) quindi è la sequenza che si occupa di serializzare 
i double, le sequenze richiama i loro read/write...rimane il problema di come faccio a sapere se in una posizione 
della sequenza c'è un double o un'altra sequenza (NB queste sequenze sono in realtà delle reti...)...posso imporre 
di passare al concetto di rete e tenere due liste distinte una per i double, una per i puntatori ad altre sequenze 
(NB nel concetto originario, avevo considerato i record al posto dell'array di double, o un solo elemento...ma 
qui siamo andati oltre astraendo da tutto abbiamo ricondotto tutto ai numeri) così ho definito delle sequenze 
semiomogenee sulle quali posso derivare un'altra classe per implementare il concetto generale delle sequenze 
eterogenee base semplicemente introducendo una sequenza di indirizzi dove mischio puntatori a double e puntatori 
ad altre sequenze nell'ordine che preferisco in pratica una mappatura! se poi voglio introdurre dei tipi complessi 
come i record, le matrici, le mappe, ecc. basta che riconduco tutto a double e sequenze e creo una classe wrapper 
che offre i metodi per offrire le funzionalità tipiche di quel tipo complesso. ovviamente le sequenze devono 
implementare tutte le operazioni e funzionalità che si possono inventare sulle sequenze (considerando anche che 
ho un due array in ogni sequenza)

il risultato di quanto sopra è l'avere una base che mi permette di generare qualunque cosa e che basilarmente mi 
offre le funzionalità richieste dalla mia infrastruttura, ovvero la serializzazione ed in futuro chissà cosa...

problema: ownership dei dati e puntatori contenuti nelle sequenze ad es se deleto un nodo, deleto in cascata 
tutti i path? se fosse un grafo ciclico sarebbe l'autodistruzione perchè cancellare un nodo, cacellerebbe tutto 
il grafo...probabilmente lo lascio come opzione di creazione del root node e come metodo richiamabile, gli altri 
nodi possono essere creati sono tramite il nodo padre...pensare anche se sembra ok così...

ho una seq dentro ci posso mettere puntatori ad altre seq, oppure elementi number, oppure elementi generici di 
ampiezza (in bytes) non definita a priori, oppure definite le sottodimensioni di number, ovvero num8-16-32-64. 
in questi sottotipi ci posso mettere quello che mi pare numeri piccoli, interi, float, stringhe ascii, stringhe 
unicode, ecc. cioè number è il tipo naturale che mi consente tutto alla max velocità, gli altri sono tipi di 
ampiezze esatte e predefinite per particolari esigenze (spazio, interfacciamento, ecc.) mettendo la velocità 
in secondo piano, fare il reshape è deprecabile perchè altero il tipo originale che ci ho messo dentro, quindi 
è preferibile usare i templates, perchè tanto alla fine devo sempre gestire i diversi tipi suddetti. quindi 
ho 5 tipi ed una seq template che mi genera altrettante 5 seq, poi ho una seq di puntatori che mi ritorna seq
dei vari tipi (5+1) il problema è che la seq di seq non la posso fare...o faccio la seq di streamable e poi 
l'utente fa il dycast, oppure faccio una derivata di questa ed aggiungo dei metodi che wrappano il dycast. 
l'uso del template mi serve anche per mantenere il raw array del tipo specificato.

i puntatori DEVONO essere trattati diversamente perchè nello streaming non devono comparire ma essere rimpiazzati dagli 
oggetti a cui puntano...per cui forse devo riprendere i discorsi teorici e fare il passaggio da seq a net. 

---


UNIVERSO:
partiamo dall'inizio...
esistente: concetto assiomatico primario e non definibile. 

universo: è l'insieme dell'esistente (o degli universi nella comune accezione) per il quale è sempre valida la legge 
di causa-effetto.

legge di causa-effetto: transizione/trasformazione/funzione continua dell'esistente da uno stato x ad uno stato 
x+dx sulla linea del tempo.

tempo: particolare linea a cui è stato attribuito questo nome sulla quale sembra basarsi ogni transizione/fenomeno 
dell'esistente comunemente chiamato multiverso (NB multiverso è sottoinsieme dell'universo definito da me).

NB <esistente, trasformazione/funzione, linea> sono i concetti assiomatici primari e non definibili che consistono 
nella massima astrazione umanamente possibile della realtà esistente confidando che permetta eventuali ulteriori 
astrazioni nel caso se ne dimostri la possibilità...

universo: <esistente, causa-effetto, tempo>

sequenza: ...

NB la sequenza eterogenea è il concetto più naturale basato sui concetti assiomatici...
NB sequenza è un concetto anche più astratto del concetto di universo

vediamo quindi di ricondurre il concetto di rete, grafo, ipergrafo al concetto di sequenza...
ipergrafo è un insieme di sottoinsiemi di elementi di un insieme X = sequenza di sequenze di elementi di X... dove 
l'ordinamento delle sequenze è teoricamente matematicamente superfluo, ma nella pratica è alla fine il concetto 
che permette l'accesso agli elementi...visto dal punto di vista del principio di heisenberg, sebbene esista la 
indeterminazione tra una coppia di variabili canoniche (non dipendenti) comunque ogni sottoinsieme dell'esistente 
ha un luogo ed un tempo ben preciso anche se non precisamente misurabile, anche per oggetti appartenenti allo stesso 
tempo io per accedervi o farvi riferimento, ho bisogno di coordinate, che per l'indeterminazione non posso conoscere 
e quindi usare nella pratica devo (o comunque posso) operare un'astratta mappatura di coordinate, per cui per la 
massima semplicità mappo le coordinate universali (non identificabili) nel più semplice sistema di coordinate...quello 
lineare...quindi se sono riuscito a mappare il concetto di ipergrafo (il più astratto) a sequenze, ho raggiunto il mio 
scopo! ...quindi devo usare solo sequenze!

elemento: porzione spazio-tempo dell'universo. NB qui ritorna l'indeterminazione perchè oltre al utilizzare 
concetti primitivi come "porzione", "sottoinsieme", ecc. porzione -> volume -> insieme di punti -> insieme denso di 
coordinate universali -> sequenza di coordinate universali -> sequenza di punti

ora un problema è che se considero una seq eterogenea che a sua volta può contenere altre sequenze, in teoria sarebbe 
un oggetto molto grosso, io invece devo usare i puntatori per le seq (cioè coordinata lineare consecutiva per gli 
elementi non seq e riferimenti per le seq), cioè internamente due sistemi di coordinate, che devo nascondere. 
poi c'è un altro problema che sarebbe quello che a priori dovrei (in teoria) poter accedere a qualunque tipo di 
oggetto

---

params << string1
params << string2
params << new sequence << number1 << number2 << ecc.

cioè con i puntatori a char e wchar creo automaticamente delle sequenze ed aggiungo queste, per i numeri no aggiungo 
i numeri castati a "number"

const char* string1 << params|0
const wchar_t* string2 << params|1
sequence seq << params|2
number1 << seq|0
number2 << seq|1

number1 << params|0|0
number2 << params|0|1

number3 << params|0|0|1|3(2)
string3 << params|0|0|1|3(0) // sempre 0 finale perchè è l'array di caratteri, oppure...
string3 << params|0|0|1|3 // con opportuno overload di << con una sequenza come rvalue e char* come lvalue
number3 << params-0-0-1-3+2 ...meglio di no!

cioè operator|(number) ritorna un reference a sequenze assumendo che la seq di ingresso contenga puntatori a seq, 
operator()(number) ritorna una copia del contenuto...poi rimane il problema dell'operatore template, quindi potrei 
usare un metodo, ad es number3 << params|0|0|1|3.get<number>(2) oppure op() non è template e ritorna un puntatore 
a num8* e << viene overloadato per ogni integral type prendendo il num8* lo traduce in number (no puntatore) e lo 
casta al tipo richiesto

string1 << seq1 | i;
non va bene per via della precedenza degli operatori quindi devo trovare un'alternativa per cui al posto di | ho un 
operatore con alta priorità ed al posto di << ho un operatore con bassa priorità, non è = perchè deve essere membro, 
non può essere <<= o simili perchè implicano l'assegnazione su oggetti già esistenti...cioè...
char* string1 <<= seq1 | 1; <=> string1 = string1 << seq1 | 1;
cioè sarebbe ricorsivo...

definizione iface basilari:
StorageMemory: memoria lineare...tipo file, ram, ecc. NB il hd non è lineare, per cui un srv HDStorageMemory lo nasconde
StorageFileSystem: basato su StorageMemory, offre un basilare supporto ai "file"
Encryption: pensare una iface basata su input/output generici che vada bene per ogni tipo di storage, stream, ecc.
Storage: basato sui suddetti, offre "user access control", tab, alberi, grafi, ecc. strutture dati di altissimo livello
Log: basato su Storage e non su StorageFileSystem o StorageMemory perchè i log devono poter essere altamente strutturati
Configuration: basato su Storage e non su StorageFileSystem o StorageMemory
BootSequence: basato sui precedenti?
UserInput: basato sui driver di periferiche, offre segnali di alto livello discreti, fuzzy, multidimensionali, ecc.
UserInterface: basato su UserInterface e driver di periferiche offre generiche funzionalità per creare "applicazioni"
SecurityManager: basato su Configuration mappa le azioni o i parametri che gli utenti, srv, iface possono fare...

Log: data-ora (timestamp), luogo (classe, metodo, pc, os, città, ecc.), oggetti (nomi e valori delle variabili), tipo di 
informazione loggata (loglevel), azione e parametri, chi (user, system, service, ecc.), status (del contesto in cui il 
log esiste e non più ampio perchè eventualmente quelle info se servono si ottengono dal merging nel contesto di una 
log analisys) NB per "time" deve essere creato uno standard universale astratto (cfr discorso sul linguaggio...)...
la log analisys la si ottiene dalle feature avanzate di Storage o al limite da un iface "ReportAnalisys"...la cosa 
importante è che venga definito un standard universale di memorizzazione dei log in Storage...NB Log scrive soltanto!!!

Configuration: similarmente a Log, è un'interfaccia ad uno standard di memorizzazione dati in Storage, più delle 
classificazioni concettuali...config ha un nometipo univoco ed una versione che identificano la sua struttura 
immodificabile nel tempo (cioè se aggiungo o rimuovo o rinomino un campo, DEVO cambiare almeno versione). ogni config 
può avere diverse sottoconfig ad es fsconfig_v1=<fsc_v1, fsprefs_v2>, storageconfig_v1=<fsprefs_v2, userprofile_v1> 
cioè posso comporre sezioni di conf diverse per ottenere una nuova conf, oppure semplicemente per avere il profili, 
cioè imposto una sezione base con info relative al pc, e poi una sezione preferenze, così di volta in volta carico 
il profilo che l'utente desidera senza replicare le info comuni (cosa che potrebbe creare casino), altro vantaggio è 
che se il sistema di sicurezza lo consente, posso ottenere che le mie preferenze di una app si riflettono su ogni 
altra app collegata, cioè massima flessibilità...

come procedere:
- skippo StorageMemory
- definisco StorageFileSystem
- implemento un StorageFileSystem che wrappa sul file system locale mappando una sottodirectory
- veloce ragionamento su Encryption e definizione
- definizione Log
- definizione Storage (lavoro impegnativo!!!)
- implementazione semplice di Storage basato sul file system locale (lavoro lungo!!!) ed eventualmente sqlite
- implementazione di Log
- definizione di Configuration
- impementazione di Configuration
- definizione di UserInput
- definizione di UserInterface
- implementazione UserInput
- implementazione UserInterface (GUI)

dipendenze:
hw-bootsequence -> il bios gli dice da dove prendere il kernel da caricare in memoria ed eseguire (kernel è il loader)
kernel-bootsequence -> avvia storage sullo stesso device da quale il bios ha caricato il kernel
                    -> prende da storage il srv configuration, lo carica in memoria e lo esegue
                    -> prende da storage il srv securitymanager, lo carica in memoria e lo esegue
                       (securitymanager richiede ed usa configuration)
                    -> prende da storage il srv bootsequence, lo carica in memoria e lo esegue
NB il nome dei srv di storage, securitymanager, configuration e bootsequence sono hardcoded nel kernel e sono random 
e sono scelti/calcolati in fase di installazione come contromisura per i virus/cracker
bootsequence -> avvia un hardcoded configuration ed in base a questa decide se, cosa, in che ordine avviare e termina

NB la precedente sequenza di avvio funziona solo se storage non dipende da configuration, cioè storage deve poter 
essere operativo almeno a livello base anche senza config, poi magari attiva la modalità full che carica config, 
altrimenti bisogna far precedere storage da basicstorage e basicconfiguration e quindi storage dipende da 
basicconfiguration che non è il massimo...

quindi:
hwboot
kernelboot
  basicstorage
    bootsequence
      basicconfiguration
      storage
      configuration
      (start securitymanager and set secureloader as default)
=> quindi:
-hwboot
--kernelboot -> instantiate basicloader: last srv instantiated per each iface, become the default for such iface...
---storagememory (ram) -> il kernel viene mappato in memoria con codice e dati, storage memory mappa la parte dati
---basicconfiguration (storagememory) -> "sequence"...c'è solo la config di storage...
---basicbootsequence
----storage (basicconfiguration) -> loader uses this srv as default
----configuration (storage) -> loader uses this srv as default
----bootsequence (configuration)

NB in storage è presente il sistema con i dati, le iface, i srv, ecc.
(storage > configuration > securitymanager > bootsequence > tutto)

OPERATIVE SYSTEM / SHELL / DESKTOP MANAGER
apps, tasks, tabs...attualmente si aprono più applicazioni per lavorare ad una cosa (es. notepadpp + photoshop per 
una pagina html) e nelle stesse applicazioni ci sono più tab relative a progetti diversi...tutti gli OS ti 
permettono di navigare tra le app, le app tra le tab e basta...
invece sarebbe UTILISSIMO che il OS gestisca anche le tab, permettendo anche di navigare per progetto e non 
solo per app/processo...
quindi...non avrei più la taskbar e varie tabbar (una per ogni app), ma avrei solo una tabbar a più livelli che 
posso riconfigurare dinamicamente: 
(1) level-1=projects, level-2=apptab 
    (es: prjtab1=website, apptab1=photoshop/logo.jpg, apptab2=npp/page1.htm, apptab3=npp/page2.htm)
(2) level-1=projects, level-2=app, level-3=apptab 
    (utile se per un prj apro molti file in una sola app come ad es applicazioni java, cpp, ecc.)
(3) level-1=app-instance, level-2=apptab (come si comportano gli OS odierni...)

riepilogo:
così come per l'universo, si prescinde dalla causa del big bang, qui si prescinde dall'avvio del srv kernel. 
l'importante è che qualcuno, in qualche modo lanci il primo srv, questo poi in genere avviando altri srv definisce 
un "reticolo di avvio", cioè non mi importa classificare bootsequence, storage ecc., in quanto il "reticolo di avvio" 
sarà specifico per il contesto, l'importante è che con il primo srv esista il loader (stesso processo), altrimenti non 
potrebbe avviare nulla.
quindi il primo srv deve essere in grado di lanciare altri srv nel suo universo.
quindi ogni srv deve avere a disposizione il loader per creare il suo network interno ed un sistema di comunicazione per 
collegarsi ad altri network. comunicazione = wormhole verso altri universi. quindi creare nuovo processo = creare un 
altro universo da questo universo. tutto ciò pone dei quesiti filosofici che devono essere risolti per poter definire 
anche i concetti tecnologici.
esaminando da un punto di vista pratico, lanciare un altro processo si fa ricorrendo alle api di sistema, quindi faccio 
ricorso all'universo dimensionale più alto (cioè un oggetto 2D chiede ad uno 3D di creare un altro oggetto 2D)...cioè 
assioma: si assume che non posso creare un nuovo universo da un universo dello stesso livello/rango. 
assioma: posso comunicare con universi di rango superiore ed inferiore. 
assioma: ogni universo può creare sottouniversi (ma come detto non universi di livello uguale o maggiore). 
conseguenza: ogni processo nasce con un loader dll (stesso processo), ogni processo comunica all'universo superiore 
(OS tramite api exec) di lanciare altri processi. 
necessità: razionalizzazione. 
possibile soluzione: inglobando la comunicazione di istanziazione "superiore" (creare nuovo processo) nel loader, 
si generalizza l'istanziazione multilivello, quindi NB exec (comunicazione liv sup) ed ipc (comunicazione stesso liv) 
devono far parte del loader. 
alternativamente ipc fa parte del loader (tutti possono comunicare con altri processi), ma exec lo implementa 
solo un KernelMaster e tutti devono passare da lui...apparentemente aumenta sicurezza, ma di fatto exec è 
disponibile a tutti!!! questo implica che la sicurezza di instanziazione, la può implementare solo un universo 
di livello superiore (come è logico che sia), cioè il OS! ...ovviamente la "capacità di impedire exec", è del OS, 
ma le policy il OS può chiederle anche ad un processo!!! NB le policy comunque dovrebbero far parte dell'uni sup 
perchè l'uni di livello inf può essere aggredito dai suoi pari, quindi è una modalità meno sicura. 
Cioè nella situazione teorica ideale: il loader di processo può instanziare universi di livelli inferiori (oggetti), 
uguali (processi), superiori (ad es. avviare un OS con wake-up lan) perchè l'universo che lo ha creato e lo possiede 
(cioè il suo OS), gli concede queste facoltà secondo delle policy gestite da lui solo ed inaccessibili in nessun modo 
da universi inferiori, uguali o superiori...cioè le policy fanno parte del OS, anche se il OS può accettare richieste 
di modifica...se rientra fra le sue policy!!! 
va quindi generalizzata l'instanziazione attraverso i vari livelli di universo ad es con le sequenze eseguibili (seq_exe). 
di modo che l'interfaccia del loader sia sempre la stessa e la sua capacità di comunicare con livelli diversi, sia nascosta 
e non gestibile da chi invoca il loader. Quindi si ha la massima astrazione della comunicazione tra entità: ogni entità 
comunica con altre di livelli superiori/inferiori, come se fosse dello stesso livello. 
necessità: naming convention per specificare path di reticolo che individuino universi da instanziare. solo così l'astrazione 
dell'instanziazione multilivello, sarà totale. NB convenzione per tutti gli universi di ogni livello!!! 
in realtà il problema si ripropone anche per tutto il resto, ad es. anche storage ha senso perchè il OS gli offre delle api 
e quindi anche qui il OS dovrebbe avere delle policy...però è anche vero che le atre cose, impattano solo sull'universo stesso 
e non ne coinvolgono altri. comunque le cose fornite dal OS fondamentalmente sono: cpu, ram, storage. ram e storage si 
possono astrarre ed unificare, cpu è gestibile in modo basilare, tranne forse per gli rtos. facendo il discorso di hardware e 
driver, si ritorna al fatto che potrei usare la scheda di rete per comunicare con altri universi dello stesso livello, o il 
monitor per comunicare con il livello superiore (gli umani). Ma NB la comunicazione, è libera...acconsentire alle richieste 
invece no, fa parte delle policy. 
Quindi: come le considero le api di sistema??? faccio così: delle api di sistema e di driver, me ne frego...magari è 
meglio un modello di tipo web of trust...
Ripensamento: le api ed i driver nel OS definitivo devono comunque essere dei srv, quindi in generale i srv possono accedere solo 
ad altri srv, non esistono ne api di sistema, né driver! quindi ogni srv, è una cosa oscura di cui non si sa come è stato creato 
e come può fare quello che fa...ne deriva che il OS decide a chi dare certe prerogative e come. 
Quindi: va bene come è stato fatto finora -> solo la capacità di comunicazione (almeno la ipc locale) fa parte di ogni srv, 
il quale al suo avvio si mette in comunicazione col suo creatore (kernel/loader) che gli fornisce il minimo indispensabile 
(load di altri srv) per poter fare qualunque cosa.
il discorso torna:
- qualcuno crea un subuniverso (processo) con il suo dna (info sul next step (srv da caricare) 
- un subuniverso è a sua volta un creatore (kernel) che può creare altri subuniversi (caricare dll dinamicamente) 
- il suo dna gli dice quale subsubuniverso creare (srv dll)
- il suo dna gli dice anche come mettersi in contatto col suo creatore (o presunto tale...in realtà il creatore può dargli l'ipc di un altro)
es: 
liv1: processo=creatore, dll=subuniverso, dll-name-in-params=1st-subuniverso
liv2: os=creatore, processo=subuniverso, boot=1st-subuniverso
liv3: cluster=creatore, os=subuniverso, 1st-os=1st-subuniverso
liv4: uomo=creatore, os/cluster=subuniverso, 1st-os/cluster=1st-subuniverso
liv5: bigbang=creatore, uomo=subuniverso, ecc. (non è proprio così...ma semplifichiamo giusto per spiegare che è un concetto generale)

NB: nel mio standard, ogni creatore crea un solo subuniverso che poi fa tutto quello che vuole...in realtà non è così perchè quando 
crea il primo subuni, in realtà ha già creato la scatola in cui si muoverà (ad es almeno il kernel master, per non parlare di storage, ecc.)
questo è vero soprattutto per i livelli più astratti (vedi uomo, bigbang, ecc.) dove alla creazione un universo non fa una sola cosa...

Quindi: os -> boot -> kernel/loader, storage, i/o, ecc. (in realtà può bastare così...) -> ui (desktop/shell) -> app -> srv1, srv2, srv3, ...
Quindi: un uni alla sua creazione, crea dei subuni basilari (le sue potenzialità) + uno: quello che darà vita ad altri subsubuni...cioè, 
crea un ecosistema e poi da inizio al suo scopo vero e proprio. 
Quindi: devo definire i "servizi" di sistema per il mio standard, cioè quelli indispensabili per qualunque cosa (anche la creazione 
dell'uomo, o universi paralleli!!!) secondo il massimo livello di astrazione! ...NB è fondamentale che il paradigma sia ben pensato 
per poter in futuro creare intelligenza artificiale distribuita, androidi, o umani sintetici, organismi uni/pluricellulari digitali 
o biologici, ecc. 
Analogie: meiosi -> kernel/loader, dna -> configuration, cellula -> storage, vita -> cpu/process loop, fecondazione -> creazione
NB: il mio intento è quello di astrarre ciò che questo universo ha creato, in modo da "standardizzarlo", ma soprattutto capirne 
l'essenza, in modo anche da capire come muoversi per contattare universi paralleli o l'eventuale creatore...catturare l'essenza 
di questo universo e del suo funzionamento...solo dopo si potranno fare le pippe sulla teoria delle stringhe, ponti dimensionali ecc.
libe (living being): entità in grado di riprodursi (cellula, umano, società, ecc.) -> è un tantino opinabile, potrebbe anche essere tutto!
mole (molecules): entità (libe o non libe) di cui è composto un libe (biomolecole, cellule, umani, società, ecc.)
dna: configurazione interna. 
gene: dato, carattere/numero base. 
geco (genetic code): tabella dei caratteri base. 
NB: anche nel rna c'è un carattere di terminazione (come per le seq) composto da tre codoni (su 64 possibili)...tre perchè si assemblano a 
gruppi di tre (come il byte = 8 bit). 
NB: nucleo della cellula umana -> 10 micron di diametro, contiene 2 metri di dna -> ottima compressione!!! 
NB codone=word=sequenza di tre nucleotidi (basi) -> nucleotidi=character, replicazione dna analoga a materia ed antimateria...la doppia elica si apre 
come una chiusura lampo ed ogni mezzo filamento rigenera la parte mancante (tipo copia speculare?). la diffeerenziazione cellulare 
avviene tramite la comunicazione tra cellule che disattiva certe parti del dna in alcune di esse che quindi si specializzano. 
fecondazione: generazione di una nuova entità. 
comunicazione cellulare: scambio di molecole extracellulari catturate da recettori. 
storage: stato di un universo, risultato di un complesso di interazioni di una cellula con molecole. 
processo: vita, complesso di interazioni di una cellula. 
life/exec: esecuzione (di processo, os, srv, ecc.). 
dna/config: configurazione nativa (boot process + registry del os, config app per il srv, ecc.). config è pertinente alla vita, storage no. 
stor: contenitore. la sua variazione di stato è conseguenza della vita dei vari libe
comm/ipc: comunicazione. scambio di dati. 

quindi: generare un altro pari è un'abilità di ogni entità. quindi loader local e remote in ogni processo. anche ipc multiliv fa parte di ogni processo. 

quindi: nella core dll ci sono loader (subliv, extern, superliv), ipc (subliv, extern, superliv) e config (native, passed). 
tutti e tre sono basati su informazione (come raggiungere il dato ed il dato) -> 
reticolo relativo: per ogni cosa non è pratico definire un origine assoluta (big bang?), quindi un dato è determinato dall'informazione contenuta 
in un luogo dello spazio identificato da coordinate relative nel sistema di riferimento concordato (handshake) tra le entità comunicanti. 

lanciare un processo passandogli dei parametri è come generare una cellula con il suo dna perchè i parametri non sono "comunicati", possono 
essere considerate come "creati" nel processo. MA io preferisco considerare config come innata, non come parametri. quindi 
config passed -> minimal, config native -> most but decentralised as ipc. quindi forse è più appropriato DNA=PROGRAMMA!!! 

CASO GENERALE:
loader: capacità di creare pari o subuniversi. superuniversi non è possibile in generale (limite fisico)
communication: capacità di comunicare con pari, sub e super. i subuniversi, si comandano/invocano/lanciano in base al dna. ai superuniversi si risponde. 
storage: stato della parte inanimata dell'universo. 

NB: load è una delle cose considerata come execution = living, quindi ritorna che le cose fondamentali sono <esecuzione, memoria, comunicazione>
per il load confermo la volontà di permettere la creazione di pari solo ad un srv di sistema...i srv di sistema hanno senso proprio come per la 
natura, ha senso la specializzazione delle cellule...ad un certo punto, certi compiti li possono fare solo alcune. 

quindi: kernel master è il primo srv che lancia solo un srv esterno: boot. questo si occupa di generare l'universo. siccome boot genera tutti 
srv esterni (altrimenti non ha senso), utilizzando quindi kernel master, quest'ultimo finchè boot non finisce tiene in memoria tutti i srv 
avviati, alla fine di boot, km, cerca quelli che servono a lui (config, storage, ecc.) e completa la sua inizializzazione. così facendo km 
si avvale da subito di tutti i srv più avanzati semplicemente posticipando (sincronizzando) il completamento della sua stessa creazione. 
NB: va pensato se ogni srv per ogni creazione passa per km che decide per lui (possibile collo di bottiglia e falla di sicurezza), oppure 
decide in autonomia...ma poi viene meno tutto il controllo che volevo mettere in pratica!!! direi che la gestione se la scelgono kernel e km 
tra di loro, l'importante è che per i srv ci sia un solo loader semplice e trasparente => no scelta esplicita del tipo di load (sub, same, sup) 
poi ad esempio una possibile gestione è che km possa cedere/delegare temporaneamente tutte o determinate creazioni senza autorizzazione 
preventiva, ecc. ma tutto questo non è visibile ai srv! 

quindi: bisogna tirar fuori da core.dll il più possibile e lasciare solo l'indispensabile. 
sequence = dato (gene, codone, ecc.), storage = memoria contenitore dei dati (membrana cellulare), cioè dati + indirizzi, cioè mappa di dati. 

todo: process->main: generalizzare il passaggio di parametri nel caso generale; ricontrollare l'instanziazione del kernel ed il passaggio 
del puntatore; kernel: rivedere l'interfaccia con un unico metodo che chiede sempre a kernel master che gli risponde "si tieni", 
"si fai da solo", "no", se non c'è km non fa mai nulla! (tutto torna perchè km, è lui e "solo lui", capace di instanziare processi esterni). 
creare macro per il kernel "k->f(Kernel::create_separate, params)" -> "load(params)" ed in generale (macro o forse meglio template function) 
"srv->f(SrvClass::method_1, params)" -> "srv(SrvClass::method_1, params)". 
controllo runtime dei tipi di dato. 
NB: in generale il kernel, anzichè ritornare il srv richiesto, può ritornare un srv filtro che applica delle policy su ogni singolo metodo e parametro 
al fine di consentire architetturalmente la massima sicurezza e flessibilità possibile...poi sta alla configurazione specifica decidere il giusto 
compromesso tra sicurezza e performance. 
todo: sequences tipizzate con runtime advanced check (es controllare un indirizzo mail, url, data, ecc.). 
todo: sequences event driven che ricevono e (soprattutto) mandano segnali circa la variazione dei dati. utile in particolar modo per le gui
todo: ui come abstract constructor di elementi mono/multi-dimensionali tipizzati astrattamente, con gui come implementazione di "interfaccia ui". 
