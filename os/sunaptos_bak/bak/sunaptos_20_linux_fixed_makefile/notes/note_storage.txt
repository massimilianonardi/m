StorageFileSystem:
- setstoragememory -> nome del particolare srv che implementa l'iface storagememory sul quale sfs va a gestire i file 
che sono a loro volta dei storagememory...NB nel caso che il particolare sfs faccia solo da wrapper verso il fs 
sottostante, questo metodo non fa nulla...anzi ritorna sempre errore (non eccezioni)
- filecreate
- filedelete
- filerename
- getfile -> ritorna un oggetto file/stream...il problema è che non può essere offerto con l'attuale architettura...
oppure inserisco qui le funzioni sul singolo file in stile c con gli handle...
- fileopen -> secondo me open/close vanno tolte perchè è roba da medioevo...al max serve una getid per avere l'handle...
- fileclose -> come sopra
- fileid -> ritorna la seq file a partire dal nome...
- filesize
- filesetposition -> no! la posizione DEVE essere fornita a read/write dal chiamante sempre ed è lui che ne deve 
tenere traccia...
- fileread
- filewrite
- listfiles
- openedfiles -> ritorna sia gli handle che i nomi
- closeall
NB anche se non è una soluzione pulitissima, io posso strutturare bene una seq params che vada bene per tutti i 
metodi sopra e che quindi è quasi come un oggetto file...
tutto ciò in realtà ha anche un senso visto che il device sul quale c'è il fs è lo stesso, quindi sia i primi tre 
metodi che gli altri operano sullo stesso hw, avere due oggetti non collegati implicherebbe problemi di 
sincronizzazione...

Storage:
consente di memorizzare qualunque tipo di struttura dati (record, file, tabelle, alberi, mappe, grafi, sequenze, ecc.) 
(che abbiamo stabilito derivare tutte da "sequence"), modificarle, crearle, cancellarle, interrogarle, importarle, 
esportarle...
ho due strade...o definire a priori le cose suddette nel tentativo di ottimizzare al massimo le performance, oppure 
permettere di definire dei nuovi tipi in base a composizioni di sequence e vincoli su di esse (cfr riflessioni a 
proposito)... la seconda strada mi piace molto di più e la mia prima impressione è che potrebbe avere comunque delle 
performance al top, ma è tutto da verificare...in ogni caso moltissimo dipende da come memorizzo le sequence in base 
ai vincoli di composizione...
- setstoragememory -> nome del srv che implementa l'iface storagememory sul quale storage va a gestire i dati
- createtype -> metodo semplice che opera su sequence e vincoli (va usato più volte per tipi complessi)
- deletetype -> controlla che i tipi non siano in uso o abbiano dipendenze
- modifytype -> controlla che i tipi non siano in uso o abbiano dipendenze
- copytype
- listtypes -> può essere inclusa in searchtypes
- searchtypes
- create -> crea un oggetto di un determinato tipo
- insert -> aggiunge un elemento di un certo tipo all'interno di una struttura
- get
- set
- delete
- modify
- copy
- search
il punto cruciale è definire un generico algoritmo di ricerca/parsing, cioè come navigare nei path, cioè devo 
specificare cosa fare ad ogni seq, es tabelle: ho una seq (tab) di seq di numeri (cols), il mio search devo specificare 
una seq di index che indica quali colonne prendere (se null le prendo tutte), poi per ogni index (col) specificato, 
do un insieme di criteri sul contenuto della seq-colonna...
in pratica: i criteri di search, si riconducono ad un agglomerato di seq-criteria, dove si distingue in base al 
contenuto che ci si aspetta, ovvero i criteri su oggetti possono essere gli indici da prendere, oppure il risultato 
di una delle relazioni definite su number o sequence. 
altra cosa importante è che in base al search, io individuo un sub-oggetto/sotto-grafo/ecc. ed una sottostruttura, 
quindi io DEVO POTER modificare un sub-oggetto oppure specificare una sottostruttura che riempio e poi dico a 
storage di sovrascriverla alla sottostruttura dell'oggetto specificato. siccome ho progettato BENE le sequenze (cioè 
realmente sequenziali), un sub-oggetto potrebbe essere rappresentato semplicemente dagli indici/sub-indici una volta 
che l'algoritmo di search ha individuato la sottostruttura corrispodente ai criteri (NB i criteri/relazioni potrebbero 
essere anche degli algoritmi molto complessi e quindi...lenti!). 
quindi tutto il problema delle performance risiede negli algoritmi relazionali su number/seq che potrebbero essere 
velocizzati con delle strutture aggiuntive di supporto che vengono calcolate una-tantum (all'inserimento, modifica, 
ecc.) e quindi si arriva anche alla crucialità del metodo di memorizzazione delle strutture dati...questi discorsi 
mi sembrano ulteriori indizi nel proseguire nella strada generica...
Nota: probabilmente una buona strategia di memorizzazione potrebbe essere che ogni sequenza la spacchetto in linked 
files, così quando apporto modifiche non devo riscrivere file molto grandi (file molto grande = colonna con 
tantissimi elementi)
il servizio storage prevede anche la gestione di seq in memoria sia localizzate (la copia originale) nel srv storage 
che nel srv utilizzatore (a richiesta)...e deve essere possibile spostare la localizzazione a run-time...tutto ciò 
fa si che l'utilizzo delle seq nella core-library rientrino in un contesto più generale dove le seq e lo storage 
sono strettamente legate l'uno all'altro...d'altronde le seq in core utilizzano la ram come storage ma senza le 
funzionalità dell'iface storage...vuol dire che anche le seq in ram hanno una classe di id e possono essere cercate 
ed il fatto di essere in ram (volatili) o su disco (persistenti) è solo un attributo scelto dal creatore/utilizzatore 

ora veniamo al come implementare la prima e più semplice versione cercando di garantire che i classici file possano 
essere memorizzati come se stessi (a meno che io non voglia spacchettare gli stream come nel caso dei video...). 
nella soluzione finale dovrò sicuramente (forse) avere una storagememory basata su un device hw o similare ed al di 
sopra uno storagefilesystem (devo cambiare questi nomi) e sopra questo storage, ma ora implemento storage direttamente 
sul filesystem locale fornito dal sistema operativo...
nuovi nomi:
StorageSequence (storagememory) -> mappa una memoria lineare (ram, hd, file) in una sequenza e viceversa (iface molto 
  simile a sequence)
StorageSequenceSpace (storagefilesystem) -> mappa/memorizza diverse sequenze in uno StorageSequence, può farlo 
  automaticamente oppure può essere specificata la posizione...può essere importante...i nomi delle seq sono 
  degli id di tipo number, se voglio nomi, attributi, permissions, ecc. devo implementarlo con una iface derivata 
  che memorizzi queste info in seq apposite, per i miei propositi sono superflue, ma in generale è giusto così per 
  separare le funzionalità ed una maggiore flessibilità

rivediamo quindi l'iface di...
Storage:
storagesequencespace -> imposta e/o ritorna lo stoseqspc sul quale opera...NB è sss ad impostare storagesequence, 
  quindi se voglio cambiare device, devo chiedere al loader o chi per lui l'istanza di sss che sta usando il mio 
  storage e poi a quell'istanza gli dico quale storagesequence utilizzare...magari ci metto un metodo per semplicità...
storagesequence -> fa quello detto sopra...
create -> crea una struttura specificando i vincoli (di struttura e/o di contenuto) su di essa, in pratica crea due 
  strutture, una è la struttura dati e l'altra contiene i vincoli/criteri...poi se queste vengono messe insieme in una 
  seq di sue elementi, o se le seq dati le metto tutte da una parte e quelle vincoli da un altra, dipende 
  dall'implementazione, l'importante è che esista un collegamento che associ ad ogni struttura dati, la propria 
  struttura vincoli. questi vincoli sono controllati in fase di "set" ed "ins". NB una stessa struct vincoli può 
  essere utilizzata da più struct dati...
modify -> modifica la struttura vincoli SE possibile E rende consistente la struttura dati con i nuovi vincoli 
get -> ritorna una substruct a partire da una struct dati ed una struc vincoli/criteri di ricerca (NB in genere è 
  una struct con criteri più restrittivi dei vincoli associati alla struct dati all'atto della creazione). 
  NB come per i db i la ricerca ed i criteri possono fare riferimento a molte struct dati, cioè il campo non è 
  ristretto ad una struct, posso fare join, mix, union ecc. tutto e di più!!!
set -> a partire da una struct dati ed una vincoli che ne individui una substruct, rimpiazza i valori...in pratica 
  copia i valori di una struct in una struct/substruct (anche frutto di get) controllando i criteri di quest'ultima
ins -> simile a set, ma non individua una substruct, ma una "posizione" nel quale mettere i dati previo rispetto 
  della struttura e dei vincoli, spostando gli altri elementi...se la pos non è specificata, fa un add...
del -> cancella una struttura frutto di get (NB per cancellare una struct dati ED anche i vincoli, devo fare due del 
  a meno che non facciano parte di una stessa rootseq, ma come abbiamo detto questo dipende dall'implementazione...)

NB in realtà potrei astrarre ulteriormente la faccenda dei vincoli, ma potrebbe essere molto lungo e complicato o 
potrei perdere in sicurezza dei dati...rimandiamo il discorso ad una eventuale vers 2 della iface...

NB come criteri/vincoli devo supportare almeno le rel base <>=, più tutti i criteri supportati dai vari database per 
le ricerche, più quelle eventuali della teoria dei grafi, più le regular expressions...questa è tosta, ma va fatta! 
inoltre devo trovare unificante, potente e veloce (nel senso che è direttamente interpretabile dall'implementazione 
di storage e non come sql/regexp/xml/ecc. che mi obbligano a fare il parsing di testo...il mio equivalente sarà 
ovviamente un agglomerato di sequenze che poi posso rappresentare come testo, ma è solo una facility di 
import/export delle ricerche...)

StorageOSFS:
è il srv che implementa l'iface Storage basandosi sul file system fornito dal sistema operativo su cui gira. 
tenendo presente che il sss sottostante tiene l'elenco di tutte le seq memorizzate io devo definire una regola sugli 
id (nomi) per distinguere le seq di sistema da quelle user-created -> da 1 a 1.000.000 sono di sistema (mi sono tenuto 
basso perchè questa è un'implementazione che verrà superata da quella basata su sss e ss che a sua volta verrà 
migliorata col tempo ecc. per cui qui non vado troppo per il sottile...0 è not-used (potrebbe essere un utile valore 
di test per gli errori) da 1.000.001 a 2.000.000 sono per le struct vincoli, da 2.000.001 in poi sono per le struct 
dati. la seq 100 contiene gli id delle seq-struct-rules, la seq 200 contiene gli id delle seq-struct-data, la 
seq 300 (di lunghezza sempre pari alla 200) contiene gli id dei vincoli associati alle seq dati (anche qui vincoli?). 
le seq data potrebbero essere create senza vincoli associati (pericolose!!! potrebbero crescere a dismisura o creare 
casini!!!), però facciamo che se non viene specificato alcun vincolo, viene impostata una seq-struct-rules di default 
con id 1.000.001...ora emerge il problema delle seq eterogenee...tanto per cominciare esiste anche nelle seq 
implementate nella core library perchè teoricamente posso inserire un numero che casualmente coincide con il 
puntatore di una qualche sequenza...insomma il problema è come distinguere tra number e link a seq...in ogni caso il 
problema lo risolvo al momento solo qui in storage e poi con l'esperienza lo risolvo anche in core che comunque 
dovevo reimplementare perchè non mi piaceva la soluzione adottata...
consideriamo ad esempio che io voglia creare una tab con una lista di file ed associati dei flag booleani, allora 
faccio una seq di due seq (vincolo) di uguale lunghezza (vincolo) di cui la prima accetta solo 0/1 (vincolo) e la 
seconda accetta solo link (id) a sequenze esistenti...quindi devo poter esprimere i seguenti vincoli...

numero di elementi (esatto, range, set di possibili valori)
tipo di elementi (number/seq-id)
valori elementi (range/set/etc.)

NB ciascun vincolo può essere un valore predeterminato, ma può anche essere il risultato di una get (search)!!!

NB potrei anche fregarmene del tipo di elementi perchè in fondo i seq-id sono dei number...poi sono io che li 
interpreto come tali!!! il punto cruciale è che poi non avrei delle relazioni esplicite e quindi nessuna garanzia che 
gli id siano validi...insomma è la stessa differenza tra un db relazionale ed uno no...devo riflettere bene, anche 
se sono abbastanza convinto di imporre le relazioni...
allora se io prendo da storage posso scegliere se voglio gli id in chiaro oppure che le seq vengano mappate 
trasparentemente (modo naturale di procedere), ma se io faccio un set come faccio a specificare se una sub-seq deve 
sovrascrivere quella già esistente (se si è richiesto che mantenga lo stesso id?) o se ne creo una nuova e rimpiazzo 
solo l'id? diciamo che per il momento sono per il sovrascrivere perchè i link/id sono degli artifici implementativi 
in realtà, concettualmente parlando, una sub-seq sta dentro la struttura, poi il fatto che un stessa sub-seq possa 
essere condivisa da più struct, è un problema a parte e porta il discorso ai loop, ricorsioni, ecc. dei grafi oltre 
al discorso delle relazioni e relazioni inverse (se cancello una seq devo poter sapere dove è stata referenziata se 
voglio poter adottare contromisure, altrimenti mi ritrovo id relativi a seq non esistenti o peggio relativi a nuove 
seq che non hanno niente a che vedere con quelle cancellate e referenziate...)

come implementare ins...
pensando ad una tabella è come se io dessi una replica di una struct con solo alcuni elem (con valori diversi) 
i quali vanno ad inserirsi opportunamente...ins è molto complicato, meglio pensare prima a set...

come implementare set...
devo specificare una get che mi ritorna una substruct S e poi fornisco una struct O, le strutture devono essere 
identiche rispetto alle lunghezze, tipo del contenuto ed alla struttura in generale...ora basta un algoritmo 
di navigazione esaustiva e faccio il replace uno ad uno...il che mi rimanda a...

come implementare get...
a partire dalla seq radice, posso specificare un vincolo, questo mi ritorna una seq ridotta con possibili link ad altre 
subseq sulle quali applicare altri vincoli...la vera domanda è questa...devo sapere a priori come è fatta la seq 
ridotta per poter specificare ed applicare vincoli alle subseq, oppure posso limitarmi a specificare delle regole? 
sicuramente la seconda ipotesi mi può essere utilissima quando si arriva alle "foglie" o giù di lì, ma è molto 
complicato per cui per il momento mi limito al fatto che nelle ricerche per poter applicare dei sottovincoli 
devo necessariamente specificare con esattezza la seq ridotta che mi deve arrivare dal vincolo precedente...



piccolo riepilogo:

set è il più semplice di tutti, prende due struct uguali e sovrascrive una dentro l'altra, dopodichè salva 
quest'ultima che in realtà era un raggruppamento di link ad elementi di determinati file...

get parte da una struct vincoli/filtri ed una struct dati, applica a quest'ultima i filtri e ritorna dei 
link/puntatori ad elementi...da ciò si deduce che serve una classe analoga (forse derivata) a sequence, ma che 
internamente ha dei riferimenti/puntatori al file che la contiene...in pratica due passi, uno mappare una seq in un 
file distinguendo tra numeri e link ad altre sequenze/file, due una perfetta sincornizzazione e thread-safety 
magari mediante eventi, mutex, lock, transactions, ecc. insomma meccanismo di mappatura in real-time almeno per il 
read dei dati, eventualmente flush+trasactions per il write...forse basta un singleton per ogni file che supporti 
il lock/mutex in scrittura ed il flush su file è gestito internamente analogamente al journaling dei file systems 
cioè in pratica in base al compromesso safety/performances posso scrivere subito il file ( quello che farò nella 
prima implementazione) ad ogni scrittura nella classe, oppure ogni tot elementi cambiati e/o ogni tot secondi/minuti 
o secondo altri criteri...comunque bisogna tener conto che tutte le suddette modalità prevedono degli eventi, 
quindi conviene tenere presente che in futuro dovrò supportare gli eventi...
NB quanto detto sopra è pari pari quello che deve/dovrà fare l'iface StorageSequence, quindi è meglio che non uso 
gli stessi nomi per evitare problemi di compilazione, comunque mi ritroverò il grosso dell'implementazione...
ANZI NO!!! è fondamentalmente diverso, perchè StorageSequence fa rifarimento ad un device a se stante e la mappatura 
è riferita ad una sola seq...no link ad altre seq sullo stesso device!!! NB anche StorageSequenceSpace non 
prevede link tra seq, la relazione di linking tra seq è una peculiarità stretta di Storage e basta!!! per cui 
le classi che devo definire sono diverse...
mi serve una classe con interfaccia uguale a sequence più dei metodi per gestire la sincronizzazione con lo storage 
fisico, oppure posso inserire dentro un policy manager e poi di volta in volta specifico quale policy bisogna 
adottare...
la prima domanda è se posso trovare un modo semplice per rendere Sequence sufficientemente virtuale da permettermi di 
derivare la classe di cui sopra da seq...ma lo rimando, per ora la copio e basta...
NB una cosa importante, magari non immediatamente ma quasi, è la possibilità per le subseq di essere "inline" ovvero 
memorizzate insieme alla seq parent questo per evitare che le stringhe vengano memorizzate come file a parte...
ovviamente deve essere opzionale e consentito solo alle seq foglie? ...se lo imposto a delle subseq non foglie la 
cosa non si propaga automaticamente su tutte le seq child (ma devo prevedere un metodo per la propagazione ricorsiva). 

ins rimane il più complicato, pensare dopo...

Nota: espandere il Loader mettendo un metodo template che fa il dynamic_cast automaticamente...

Nota: implementare il lock in SequencePersistent in put e write (cioè non puoi inserire mentre scrive...) o forse 
devo implementare delle SequenceLockable in core...

ragionamenti per arrivare ai search...
per fare riferimento ad un elemento (numero) io scrivo così -> seq(2)(3)[4], questa espressione vuol dire che ho 
una sequenza seq a cui applico ricorsivamente gli indici 2,3,4...in pratica l'array {2,3,4} rappresenta le coordinate 
dell'elemento in seq, quindi per accedere ad ogni elem basta una sequenza di coordinate!!! ...per accedere 
a n elementi, mi serviranno quindi una sequenza di n subsequenze...potrei ottimizzare quensto discorso potrei 
vederlo "per righe" (approfondisco il livello per ogni elem contemporaneamente) anzichè "per colonne" (arrivo ad un 
elem per volta), ma fondamentalmente ci siamo per il caso più semplice, quindi devo trovare un metodo per mappare 
questo ragionamento in un algoritmo che mi ritorni una seq di puntatori ad elem...NB questo dettaglio è importante!!! 
perchè non solo devo avere una seq ridotta, ma le modifiche su questa DEVONO riversarsi in real-time sulla seq di 
partenza!!!
supponendo di fare un search che su una seq dice di prendere gli indici da 2 a 9, la seq risultante...è e deve essere 
una seq...ciò vuol dire che i criteri mi servono solo in fase di generazione della seq, ma il risultato è una "seq" 
la differenza sta nel fatto che le seq frutto di search apparentemente sono uguali all'origine (come se avessero 
tutti gli elementi), ma nella pratica hanno solo gli elem richiesti...per far ciò ho bisogno di una diversa classe 
derivata da sequence dove anzichè un solo buffer con i dati, ho due buffer uno con gli indici originali, uno con i 
puntatori agli oggetti nella seq di origine...ciò mi permette tre cose uno di accedervi tramite gli indici originali 
(anche se è molto più lento perchè faccio usa di una mappa e quindi l'indice è in realtà una chiave da cercare alla 
quale è associato un indice nel secondo buffer => triplo passaggio) due di accedere con i nuovi indici e tre di 
modificare direttamente l'origine...NB questa classe però mi deve fornire anche due possibilità uno di avere un 
oggetto copia (cioè ho ancora la possibilità di accedere con gli indici originali, ma le modifiche non si riflettono 
sull'originale) e due di esportare in una seq classica (cioè perdo ogni collegamento con l'origine)...
stabilito ciò...il get è immediato, il set diventa una semplice facility che effettua cicli e ricorsioni per copiare 
tutti i dati previa verifica della congruenza tra le due strutture...rimangono ins e del che sono i più complicati...
ins di un "record" fornisco una seq di seq-coordinates più una seq di elementi (le due seq devono essere lunghe 
uguali), ins di più "record" semplicemente la seconda seq diventa una seq di seq-record...
del ha la seq di coordinate più una seq di numeri che indicano quanti elem eliminare...

Nota: modificare sequence aggiungendo i metodi ins e del, facendo si che alla fine abbia get, set, ins, del, add...
creare una classe sequenceiterator o simile che contenga il riferimento (o puntatore) ad una sequence ed un indice 
valido per questa, più una serie di overload di >> sui vari integral types di modo che sia possibile fare così...
seq >> string1 >> pchararray1 >> integer1 >> float2 >> ecc. dove [sequence >> integral] ritorna seqiter& con i=0 e 
dove [seqiter >> integral] ritorna seqiter& con i=i+1...
l'unico problema potrebbe essere la thread safety perchè tra un'istruzione e l'altra un altro thread potrebbe aver 
aggiunto/modificato/rimosso un elem, ma tale problema esiste anche per << ...quindi potrei rendere sequence lockable 
dove i metodi lock/unlock ritornano il rif alla seq così posso scrivere così...
(seq.lock >> string1 >> integer1).unlock ... (seq.lock << string1 << integer1).unlock o magari se definisco 
opportunamente un operatore potrei scrivere così... seq.lock << string1 << integer1 & seq.unlock; ...no, è ridicolo 
perchè è sufficiente scrivere così... seq.lock << string1 << integer1; seq.unlock;
inoltre elimino il trylock sostituendolo da un opportuno overload di lock che deve permettere di attendere 
indefinitamente, attendere fino ad un timeout, adottare un comportamento correntemente definito come default, inoltre 
serve anche un metodo per specificare la modalità di default...
rendere seq equivalente a storage, nel senso che fa i search e genera ogni tipo di struttura...così alla fine storage 
diventa un wrapper di seq più un sistema di memorizzazione su un device (virtuale o fisico)...mi sembra la cosa 
migliore, così rendo seq molto potenti l'unico problema potrebbe esserci per le strutture enormi (più della ram) 
quindi faccio così: seq offrono tutte le funzionalità di storage ma l'implementazione è ottimizzata per il runtime e 
con le seq tutte in mem, più il supporto alle seq generate da search e che mantengono i rif agli indici originali 
(quelle con gli indici ricalcolati sono seq normali), il senso è che io in una app uso solo una parte di tabelle 
anche enormi e nel db ci sono tutti i record...analogamente con storage, solo che nel mio caso avere la stessa 
interfaccia per storage e sequence è un'importante astrazione oltre al fatto che seq comunque non possono essere 
solo dei banali vector...altra differenza è che sequence ha tutto interno, mentre storagea seconda delle policy e/o 
della particolare config di una particolare seq, può memorizzare tutto insieme (stesso file, ecc.) o separare parti 
e collegarle tramite id (come le relazioni nei db)...
aggiungere il supporto ai flag per tracciare gli elementi modificati e l'eventuale supporto al de/serialize parziale...
operazioni elementari sulle seq...concatenate, compare ==, substring, contains/find->NO, replace->NO...le ultime due 
sono riconducibili ai metodi get/set di storage...
operazioni elementari sui vettori, matrici, ecc. somma, prodotto scalare, prodotto vettoriale, gradiente, divergenza, 
prodotto, somma, ecc. di uno scalare, norma

Nota: idea per la dynamic-lifetime/scope degli oggetti...ho un singleton che mi crea gli oggetti ritornandomi sia 
un puntatore che un reference (a scelta) ritornandomi come intermediario un altro oggetto inizializzato col puntatore 
che una volta uscito dallo scope farà o no il delete di quell'oggetto a seconda di quale metodo ho usato per crearlo...
così ho il vantaggio di usare reference e non puntatori, ma se mi fermo qui non ho vantaggi rispetto ai banali 
new e delete, però se ragiono meglio magari posso trovare dei meccanismi per decidere a quanti livelli di upscope 
posso far sopravvivere l'oggetto...in realtà tutta questa faccenda non mi piace, ma in taluni casi forse potrebbe 
tornarmi utile...

vincoli, constraint, rules, filter, criteria:
numero di elementi (esatto, range, set di possibili valori) -> lunghezza, size, width
indici
tipo di elementi (number/seq-id) -> number, seq
valori elementi (range/set/etc.) -> boolean operations on number (other operands as parameters)

riepilogando (criteria):
criteria sulla sequenza (prendo o no tutta la seq in blocco) -> size, width, result of a search inside the seq
criteria sugli elementi (prendo o no uno specifico elemento) -> type (number, seq), index criteria, value criteria

quindi value-criteria (index, value, seq-size, seq-width), type-criteria (number, seq), search-result-criteria
quindi number-value-criteria (index, value, seq-size, seq-width, search-result), boolean-value-criteria (elem-type) 
quindi tutto è riconducibile a number-value-criteria (esatto, range (combinations of <,=,>), set) con valori 
forniti da metodi che ritornano: index, value, seq-size, seq-width, elem-type, search e che operano su una seq o su 
un elem e che hanno un numero non specificato di parametri...

number-value-criteria -> criteria = match + source
match = number (exact), set (possible values), set of intervals (seq of 2-elem-seq) 
-> number è un caso particolare di set, set è un caso particolare di set-intervals...pensare se e quali unificare... 
source = funzione applicata ad uno specifico elemento (di indice "i") di uno specifico tipo -> index(i), value(i), 
type(i), size(i), width(i), search(i, criteria)...ognuna di queste si applica ad un solo tipo (number o seq), se il 
tipo fornito è sbagliato, cosa devo fare ritornare "false" o lanciare un'eccezione? per il momento decido "false"... 

risistemiamo:
criteria = match + source
match = number (exact), set (possible values), set of intervals (seq of 2-elem-seq) 
source = func(number) -> value... func(seq) -> size, width, search... func(number/seq) -> type, index
source = all<type, index> number<value> sequence<size, width>
ora il problema è che tutte le funzioni ritornano un number eccetto search che in realtà non c'entra niente perchè 
anzichè indicarlo qui lo indico nella catena dei search sulla singola seq...cioè quell descritto sopra è un semplice 
criteria-search su una seq, ovvero il controllo sugli elem della seq...il seq-criteria è una composizione di 
elem-criteria...quindi composizione-elem-criteria -> single-seq-criteria, composizione-single-seq-criteria -> 
complex-seq-criteria...

tutto parte da una search su una seq, quindi la prima ed unica cosa che posso fare è l'applicazione di uno 
comp-single-seq-criteria, se questo è true, si passa alla comp-elem-criteria sugli elem di quella seq, se anche 
questo è true, si passa ricorsivamente a dei criteria sulle subseq, questa ricorsione può essere molto complessa se 
non prevedo una struttura fissa perchè posso avere dei criteria condizionali, opzionali, ricorrenti, ecc. (discorso 
da approfondire più avanti) la seq risultato del search è quella composta da tutti gli elem/subseq sui quali i 
criteria hanno avuto risultato "true" mantenendo la struttura originaria con il troncamento di qualche ramo...
NB quando una subseq è false, tutto quanto sta sotto viene rimosso e se ci stanno loop su nodi che già abbiamo 
considerato, vuol dire che prendo parte di un loop che non sarà più tale...
NB mi serve pure un criteria sul numero di ricorsioni/rami/ecc. che sto facendo...

quindi mi rimane da stabilire come fare le composizioni sugli elem-criteria (type, index, value), come fare le 
composizioni sulle seq-criteria (size, width) e come scendere nella ricorsione (è implicito nella composizione dei 
criteria)...posso comporre con gli operatori logici (not, and, or, xor)

riepilogando:
seq-criteria (size intervals, width intervals), index intervals, number -> value(i), subseq -> recursion...
rimane da stabilire come gestire il match sui valori e la ricorsione in maniera dinamica, per il momento stabilisco 
che la struttura è fissa e nota a priori...

criteria:
- width intervals
- size intervals
- index intervals
- value criteria -> seq of pairs <index-intervals, value-intervals>
- recursion criteria -> seq of pairs <index-intervals, criteria>

NB oltre al metodo "get" che opera un filtro, mi serve un metodo "check" che ritorna un boolean che verifichi il 
rispetto di tutti i criteri sulla seq...indispensabile nelle ins quando voglio stabilire delle strutture dati 
integre (cioè struttura che decido a priori nella sua rigidità/flessibilità con valori controllati)

rimane da stabilire come sono fatte le seq "intervals":
sono seq di seq di due elementi (a, b) per cui a<=x<=b...come definire gli estremi +/- infinito? o un solo estremo? 
facciamo come seq di seq di quattro elementi (a, au, b, bu) dove au e bu assumono tre valori (-1, 0, 1) che indicano 
non considerato (infinito), estremo non compreso (solo < e >) estremo compreso (<= e >=)...forse è meglio la prima 
definizione con solo gli estremi, poi il infinito e l'estremo escluso, li posso simulare con dei valori appositi 
(MAX_VALUE, MIN_VALUE, a+MIN_DECIMAL, b-MIN_DECIMAL)...comunque devo rifletterci su...

quindi mi serve una func o metodo per il check di un valore in una seq-intervals e due func o metodi per fare il for 
negli index-intervals sia per il value-check che per la recursion...

NB criteria è composta di seq-intervals...sia per criteria che per ogni isolata seq-intervals devo fare il cotrollo di 
struttura...

NB ripensare i criteria in modo da permettere tutte le ricerche/query possibili con i db vedi ricerche LIKE e 
wildcards sulle stringhe (pattern comparison), clausola IN (cerca sequenza o parte in un ramo o set di seq), 
permettere che i "value" non siano statici ma possano provenire da altre search...quindi...
value: risultato di search
value-criteria: sia per righe che per colonne, ovvero elem by elem (per colonne) oppure pattern matching su tutta la 
seq (per righe)...tutto è riconducibile al pattern matching...

pattern matching:
sequenza di matches -> single value (exact, intervals, set), spacing (none, intervals, set), ecc.

criteria:
- width intervals (only check by design, reduction of width must occur by mean of a conversion algorithm)
- size intervals (only check by design, reduction of size must occur via filtering)
- pattern matching (anche index-intervals incluso qui dentro, quindi sia pattern match stretto che index filtering)
- recursion criteria

pattern matching (trovare altro nome) vuol dire che da una seq opero una specie di regex cioè verifico sia il 
rispetto di determinati pattern (anche il pattern della presenza di subseq), sia il filtro sugli elem...in pratica 
faccio filter+match contemporanei...NB potrei metterci anche il size match...anzi c'è e potrei rimuoverlo da sopra, 
ma preferisco tenerlo esplicitato sopra anche se è una ridondanza...
in pratica la seq viene segmentata dinamicamente (individuo il primo seg e processo, poi passo al prox) ed ogni 
segmento posso flaggarlo come true/false e se true posso prenderlo o no...anzi ragioniamo diversamente...
un pattern matching and filtering può essere suddiviso in un insieme di operazioni booleane il cui confronto 
elementare si riduce al cercare una seq dentro la seq originaria e se trovata a che indice ed eventualmente 
controllo se l'indice appartiene ad un certo "intervals" questo controllo elementare è alla base sia del filtering 
(cioè ho trovato un pattern, quindi relativamente ad esso estraggo/filtro una parte di seq) che del matching...da 
quanto detto si evince che concettualmente anche per fare filtering serve un pattern matching, quindi la catena 
è pattern-matching+filtering eventualmente ricorsivo...NB il pmf può essere applicato sia agli elem che alle subseq...
ad es posso decidere di prendere o no una seq solo se determinate sue subseq ritornano true ai loro criteria...così 
posso anche comporre dei criteria che dipendono unicamente dai valori foglia...insomma è più generico e potente!!!
NB anche l'applicazione dei criteria alle subseq passa per un pattern matching perchè sia a pos fisse che dinamiche 
devo comunque avere delle regole per scegliere gli elem da considerare subseq e quindi passargli gli appropriati 
criteria, inoltre il pmf deve ritornare gli indici presi sui quali in una seq parallela posso fare il pmf...quindi...

criteria:
- width intervals (only check by design, reduction of width must occur by mean of a conversion algorithm)
- size intervals (only check by design, reduction of size must occur via filtering)
- pmf -> ritorna true/false (se procedere oltre), se true ritorna una subseq (eventualmente vuota)
NB recursion criteria fa parte del pmf in genere come ultimo passo, ma anche come criterio di valutazione (faccio un 
peek nel livello più in basso, questo se poi a sua volta fa altri peek, si innesca la ricorsione...)

elementary match: cerco un pattern-segment (una seq) nella seq su cui sto operando, la ricerca può essere fatta in 
un index-intervals, ma io preferisco la ricerca in una pos esatta oppure la ricerca di tutte le occorrenze e poi 
valuto gli indici ritornati...è tutto troppo complicato senza neanche raggiungere la generalità che vorrei...forse 
è meglio che mi limito fare due tipi di pmf, uno controllo ogni val che sia in un intervals, due faccio il pmf con 
le wildcards % e _ come per i LIKE in sql...nel primo caso skippo le subseq, nel secondo skippo le subseq che ricadono 
nelle wildcards, mentre per i segmenti ci devono essere solo valori, cioè nel criteria non posso mettere subseq 
by design e nella seq su cui opero se trovo una subseq nel confronto con un seg ritorno false...in pratica il criterio 
da applicare alla seq può essere di due tipi: val by val (numeri), o pattern matching (stringhe)...
il primo è molto semplice e fa automaticamente anche da filtro, nel secondo si potrebbe prevedere il filtraggio, ma 
per il momento per semplicità impongo che il filtro ritorni sempre tutta la seq...NB in ambedue i casi il criterio 
ritorna una seq di indici che hanno passato il criterio, i quali possono essere gli indici di input per la prox 
subseq della seq parent (metodo per simulare le ricerche nelle tabelle dei db), quindi ritorna il index filtering...

criteria:
- width intervals (only check by design, reduction of width must occur by mean of a conversion algorithm)
- size intervals (only check by design, reduction of size must occur via filtering)
- indexes-seq (simple seq, no intervals)
- value intervals -> this criteria returns indexes-seq (if empty, the whole criteria returns an empty seq -> discard!)
- pmf -> this criteria returns indexes-seq
NB if all (AND) of the above return a no-empty indexes-seq, then the whole criteria returns the intersection of all 
indexes...if empty the whole seq is discarded! actually for better performance, sequentially each indexes-seq returned 
by a sub-criteria is the input of the following sub-criteria (less computation)
NB rimane il recursion criteria che non è altro che una seq che mi associa agli index dove sono le subseq a dei 
sub-criteria e dove l'indice -1 rappresenta la seq stessa così facendo posso scegliere l'ordine di applicazione dei 
criteria e quindi posso far dipendere i criteria di una seq dai risultati dei criteria su alcune subseq (cfr discorso 
fatto prima) per ciascuno di questi criteria gli devo poter specificare dove prendere i vari parametri (width, size, 
values, pmf) e cioè possono essere fissi o derivanti da searches su altre seq completamente scollegate dal presente 
grafo di seq in esame...NB potrei pensare di espandere il discorso del riutilizzo degli indexes di un ramo in un altro 
pensando non solo ad una lista di indexes ma ad un grafo di indexes, cioè prendo gli indexes di un ramo con la sua 
struttura e li applico ricorsivamente ad un altro ramo con la stessa struttura...

pmf è fatto così: è una seq dove se trovo un number=0 significa %, se number=1 significa _, se ho una subseq 
significa che devo cercare quella seq in quella in cui sto operando...

NB uno dei prerequisiti per poter prendere i parametri da altre searches è quello di poter manipolare la struttura 
risultato di una search...proprio come avviene nei db che trmite il rename delle colonne nel select, i count, group, 
join ecc. da una query ottengono una tab virtuale che può non aver niente a che vedere con quelle da cui ha tratto 
i dati...DEVO prevedere anche io questi strumenti di manipolazione...

decisione: no più reference seq, basta avere la possibilità di ritornare gli indici originali (o struttura di indici) 
con i quali posso manualmente mappare verso la seq di origine...poi successivamente mi creerò in core delle classi 
helper per fare la mappatura tra indici-seq e la tracciatura delle modifiche e queste classi mi offriranno dei metodi 
che mi ritornano direttamente i parametri costruiti per fare direttamente i set, ins, del...

riepilogo:
criteria fa dei "match", "filtering", "get con specifici criteria" sulle subseq, "get con specifici criteria" su seq 
esterne...
quindi un criteria tra i vari parametri indica anche a quale seq deve essere applicato 
(current, subseq(i), extern(name))...il problema che nasce qui è che a runtime extern dovrebbe avere un puntatore, 
in storage dovrebbe avere un nome di una seq in quello storage...como lo risolvo?

NB in un mondo perfetto, mi piacerebbe avere delle strutture dati frutto di query per le quali storage tiene traccia 
e se c'è stato un cambiamento di un qualche dato nell'origine, mi notifica che c'è un update e se voglio faccio il 
refresh...sembra semplice a parole, ma è molto complicato soprattutto per le implicazioni strutturali, due su tutte 
il doppio link nella ipc (implementare i listener...) ed una struttura con interfaccia uguale a sequence ma diversa 
in grado di fare il listener (e da event dispatcher) e l'autoupdate solo dei dati cambiati...questa ultima può 
essere superflua, ma ha un impatto sulle performance...pensare...

criteria:
seq di criterion (subseq) fatte cosi...
<type, who, ref, params, reshape>
type = width-check, size-check, index-filter, value-filter, value-check, pattern-filter, pattern-match, seq-criteria 
who = this, subseq(i), extern(name)
ref = i/name (depending on "who")
params = parametri fissati, derivanti da un altro criterion, o derivanti da un'altra "get"
reshape = rules for changing the structure...
NB non tutte le possibili combinazioni sono valide ovviamente...
NB params sono fissati perchè ho già il who che mi dice se devo applicarlo su una seq-extern...
NB reshape forse è un type

criteria: return-type (indexes, indexes-struct, seq, all) + seq (ordinata) di criterion
criterion: <who, ref, type, params>
who = this, subseq(i), extern(object), storage(name)
ref = i/object/name (depending on "who") NB i/name means index/id-number object means putting the extern seq as subseq 
type = wd-check, sz-check, index-filt, value-filt, value-check, pattern-filt, pattern-match, seq-criteria, reshape 
params = seq con valori fissati 

NB devo trovare un modo per unificare object/name perchè altrimenti i criteria dipendono dal contesto (runtime/storage) 
NB criterion ritorna cose diverse a seconda del "type"

type->input / return->input for next criterion:
wd-check = this / boolean -> this
sz-check = this / boolean -> this
value-check = this / boolean -> this
pattern-match = this / boolean -> this
index-filt = indexes / this-seq-reduced -> this-seq-reduced
value-filt = indexes / this-seq-reduced -> this-seq-reduced
pattern-filt = indexes / this-seq-reduced -> this-seq-reduced
seq-criteria = indexes, indexes-struct, seq -> seq
reshape = seq -> seq

criteria: returns indexes-struct-seq + filtered-reshaped-seq
width-check
size-check
value-check
pattern-match-check
filter-seq (combination of value/pattern filtering) -> returns indexes-seq + filtered-seq
recursion-seq -> returns indexes-seqs filtered-subseqs
reshape-seq (group, count, etc.)
NB filter/recursion/reshape may access/search to other unrelated seqs

NB se io avessi una seq filtrata che mappa direttamente nell'oggetto origine, mi basterebbe get e poi set e del 
sarebbero automatici...rimarrebbe ins che può essere ricondotto al get della pos in cui voglio inserire...ma 
diventa troppo complicato...lasciamo perdere...

NB per ovviare al problema del contesto da cui prendere le seq esterne, posso prevedere che ai metodi che fanno dei 
search oltre ai criteria gli passo anche il rif all'oggetto storage a cui chiedere...poi esplicito anche che 
sequence implementa l'interfaccia storage così posso passare una seq che fa da runtime-storage...non mi torna...
se impongo che questi metodi sono solo di storage e non di seq avrei risolto il problema, ma non potrei più fare le 
ricerche su oggetti runtime...a meno che non implemento in core una classe derivata da storage che wrappa un altro 
storage e che mi fornisce sia oggetti persistenti che oggetti runtime e potrebbe fare ricerche incrociate...sembra 
la soluzione più pulita...

criteria -> <indexes-struct-seq, filtered-reshaped-seq>:
check: width, size, values, pattern -> boolean
filter: seq of several value/pattern filters -> indexes-seq + filtered-seq
recursion-criteria: seq of rules
reshape-seq: seq of rules

check = seq of number (wd), number(sz), "value-filter", "pattern-filter"
filter = seq of 2: filter(0) = types (0 = value, 1 = pattern), filter(1) = seq of filters
value-filter = seq of seq of 2 numbers or extern criteria seq of 2 (first=seqid-number, second=criteria-seq)
pattern-filter = seq of values for exact match and subseq of 1 for a wildcard (0 = any number of elems, 1 = one elem) 
                 and a subseq of 2 for an extern criteria (first=seqid-number, second=criteria-seq)
recursion = seq of 3: first = seq of indexes of subseq, second = seq of criteria NB unspecified subseq are taken whole 
            third = extern...
reshape = ...

semplifichiamo il linguaggio, lo perfezioneremo in seguito...

criteria(indexes-struct-seq, filtered-reshaped-seq):
fast-check = s-2(n-width, n-size)
value-check = s(s-2(n-a, n-b), ...) OR di intervalli...
pattern-check = s(n-exact | s(n-wildcard(0 = any number of elems, 1 = one elem)), ...)
index-filter = s(n-index, ...)
value-filter = s(s-2(n-a, n-b), ...) OR di intervalli...
pattern-filter = ...not currently implemented...
recursion-filter = ...not currently implemented...
complex-reshape-recursion-filter+check = ...not currently implemented...sarà il mio equivalente delle regex+sql!!!



criteria(indexes-struct-seq, filtered-reshaped-seq):
type = n(0=query-width, 1=query-size, 2=match-width, 3=match-size, 
         10=query-indexes, 11=query-index-filtered, 12=index-struct, 13=index-struct-filtered, 
         20=seq, 21=seq-filtered, 22=seq+recursion, 23=seq-filtered+recursion)
params = depends on type
---
type-case:
0 -> n-width
1 -> n-size
2,3 -> n-boolean
  params:
  value = n-number-to-match
  OR criteria = s(criteria for querying value)
10 -> indexes-seq (filtered of subseqs)
11 -> indexes-seq (filtered of subseqs and by custom criteria)
   params:
   filter = s(criteria for filtering NO recursion and NO reshape because of no meaning for indexes)
12 -> index-struct-seq (subseqs index also recursively)
13 -> index-struct-seq (filtered of subseqs and by custom criteria)
   params:
   filter-recursion = s(criteria for filtering-recursion and NO reshape because of no meaning for indexes)
20 -> seq (filtered of subseqs)
21 -> seq (filtered of subseqs and by custom criteria)
   params:
   filter = s(criteria for filtering NO recursion and NO reshape because of no meaning for indexes)
22 -> seq and subseqs recursively (all struct)
23 -> seq+struct filtered and reshaped
   params:
   filter-recursion-reshape = s(criteria for filtering-recursion-reshape)
---
filters:
index = s(n-index, ...)
value = s(s-2(n-a, n-b), ...) OR di intervalli...
pattern = s(n-exact | s(n-wildcard(0 = any number of elems, 1 = one elem)), ...)
recursion-filter = ...not currently implemented...
complex-reshape-recursion-filter+check = ...not currently implemented...sarà il mio equivalente delle regex+sql!!!

NB mi mancano due cose, uno uno standard per indicare per ciascun filter i parametri da ottenere tramite 
extern-search, due come passare alle subsearch (recursion) risultati ottenuti da altri subsearch o dalla seq parent...

facciamo così...
filters:
number = 0=static filter params, 1=dynamic filter params
seq = if 0 is directly the params to pass to the filter, if 1 is a criteria to launch and obtain as a filter-params as 
      result
recursion:
...todo...

riepilogo...
ogni operazione sullo storage anche se espressa con get/set/ins/del, grazie alla complessità dei criteria in realtà 
complessivamente rappresentano delle operazioni molto complesse che passano per step intermedi esprimibili in termini 
elementari, detto ciò ogni operazione sullo storage va vista come una "trasformazione" NB anche se non si alterano i 
dati originali e quindi si fa una semplice query/vista, io opero una trasforamzione su come vedere i dati, quindi in 
generale parlerò di trasformazione, morphing, o altro termine da decidere...

criteria...lo rimpiazziamo con "storage-op" o "morph" o "metamorph" o "mmorph" o "transform" o "tform":
number id = sequence id
number op = 0, 1, 2, 3 (get, set, ins, del)
seq params = depends on "op"

  if get then params = seq criteria
  if set then params = 
                       seq criteria
                       (resulting seq can only contain link to data, no queried values like width, size, indexes, etc.)
                       seq replacing
  if ins then params = 
                       seq criteria
                       (resulting seq can only contain link to data, no queried values like width, size, indexes, etc.)
                       seq inserts
  if del then params = seq criteria
                       (resulting seq can only contain link to data, no queried values like width, size, indexes, etc.)
quindi:
tform = <id, op, criteria, data (for set or ins only)>
criteria = <type, filter, recursion, reshape>
filter = <seq-static-chained-dynamic, rule1, rule2, ...>
recursion = <seq-static-chained-dynamic, rule1, rule2, ...>
reshape = <...>

NB filter modifica i numbers della seq, recursion modifica le subseq, reshape modifica l'insieme di numbers+subseqs...
NB chained filter vuol dire che prende il params dalla seq parent che glielo passa, chained recursion vuol dire che 
prende il params dal risultato della recursion rule precedente

---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del
- sequence criteria:
  - type: ...
          0=query-width, 1=query-size, 2=match-width, 3=match-size, 
          10=query-indexes, 11=query-index-filtered, 12=index-struct, 13=index-struct-filtered, 
          20=seq, 21=seq-filtered, 22=seq+recursion, 23=seq-filtered+recursion
  - filter:
    - static-dynamic-chained: seq of number specifing the type of each following rule
                              0=static, 1=dynamic, 2=chained
    - rules: sequence of number specifing the type of each following rule
                  0=index , 1=value , 2=pattern
    - param: sequence specifing the filtering rule param according to static-chained-dynamic
    ...
    - param-n:
  - recursion:
  - reshape:
- sequence data: the sequence to set from or to insert, for get/del data is not present
---
es. tabella 4col: 1 match size (num colonne) 2 (prima colonna) query size 3 (seconda col) query-index-filtered + 
filtra-ottieni valori < val derivante dalla chain filter sulla prima colonna (size prima colonna) 4 query-index-filt + 
filtra-ottieni any subseq che match un pattern 5 (quarta col) index-filter...
in pratica sulla seq madre controllo che la lunghezza sia 4 e che abbia solo subseq, sulla prima subseq non opero 
filtraggio ma chiedo un valore (solo query senza seq) che uso per filtrare sulla seconda colonna dalla quale ottengo 
sia la colonna filtrata che gli indici degli elem+suseqs buoni con questi (passaggio erroneamente mancante 
nell'esempio) filtro la prima colonna e richiedo ancora gli indici buoni (uguali a prima ovviamente) che passo poi 
alla terza colonna (colonna di stringhe) sulla quale prima filtra sugli indici, poi filtro imponendo che abbia solo 
subseqs (stringhe) e ricorsivamente prendo solo le subseqs che matchano un certo pattern con gli indici della terza 
colonna filtro semplicemente la quarta colonna...così ho ottenuto l'equivalente di una query su tabella con where 
sulla seconda colonna con x < val (dove val è una subquery) e dove sulla terza colonna è fatta di stringhe che 
rispettino un like...per simulare una clausola IN subquery basta che uso una subquery che ritorni un intervallo con 
i vari a=b (cioè un set anzichè un intervallo)
detto ciò, appare evidente che filter e recursion devono poter essere mischiati nella catena di operazioni elementari 
che queste operazioni ritornano dei risultati che possono essere utilizzati da una o più operazioni successive...
quindi utilizzo una seq "global" che raccoglie tutti i risultati delle operazioni nell'ordine di esecuzione poi nella 
descrizione della catena di operazioni ad ogni op come input specifico semplicemente la mappatura in global dove 
prendere i params...tale mappatura è al solito un path rappresentato come sequenza di indici...
riflessioni:
i filtri index-value-pattern ritornano tutti la seq filtrata dove NB pattern ritorna tutta la seq se il pattern matcha 
altrimenti seq vuota...cerco di riportare tutto a "filtri" onde unificare...quindi: filtro "numseq" ha come input 
0/1 a seconda del quale ritorna solo i num di una seq o solo le subseq...così semplificato il type, se poi riporto 
i query/match width/size nel reshape (concettualmente corretto per i query, no per i match) ho semplificato molto...
i filtri ed i recursion devo essere unificati, il reshape per il momento lo lasciamo a parte ed indefinito...poi ci 
sono le query ed i check...i check possono essere ricondotti ai filtri facendogli ritornare l'intera seq proprio come 
pattern, le query potrebbero funzionare come i filtri, ma il problema è che non fanno parte della seq o subseq, quindi 
sarebbero casomai opportune nei reshape...quindi la catena di filtri vanno associati ad una seq (0=master, 1,2,3,... 
alle subseq) ogni catena si occupa della sua seq, poi ci sono le query interne ed esterne da usare come params dei 
filtri o nei reshape...query=tform, sulle subseq sono criteria...

NB idea XDB = XML°DataBase un wrapper da xml verso storage...

---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del
- sequence criteria:
  - params: sequence of static-fixed params (expanded at runtime with results of each step of the chain)
  - seq: sequence of indexes where to pick the subseq to operate with (-1 for master seq, -2 for every subseq)
  - type: sequence of numbers specifing the chain of filter types
          0=match-width, 1=match-size, 2=width, 3=size, 4=indexes
          10=check-values, 11=check pattern, 12=check-numseq
          20=filter-index, 21=filter-values, 22=filter-pattern, 23=filter-numseq
  - params-index: sequence of indexes relative to params sequence where to pick the sub-params
  - replace: sequence of flags telling if the result must replace the seq on which operated
  - reshape: create empty seq, get(path), set(path,seq), ins(path,seq), del(path)
- sequence data: the sequence to set from or to insert, for get/del data is not present
---
allora, io specifico i criteri per "this" e i criteri per ogni subseq oppure una lista di criteri per ogni subseq...
in pratica io devo definire un path dove su ogni nodo faccio filtraggio, in più definisco altri path di filtraggi...
---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del, 4=create
- sequence criteria:
  - this-seq filter chain: sequence of filters...filter=
    - type: sequence of numbers specifing the chain of filter types
            0=match-width, 1=match-size, 2=width, 3=size, 4=indexes
            10=check-values, 11=check pattern, 12=check-numseq
            20=filter-index, 21=filter-values, 22=filter-pattern, 23=filter-numseq
    - params index: index of params seq where to get the params for this filter
  - all-subseq criteria (eventually empty)
  - specific subseq criteria (eventually empty): seq of criteria...one for each subseq present 
                                                 each result expands params
  - params: sequence of static-fixed params (expanded at runtime with results of each sub-tforms)
  - subtforms: sequence of transformations used to fill dynamic params
  - reshape: create empty seq, get(path), set(path,seq), ins(path,seq), del(path) using this seq and params as input 
             values from this seq are stored by pointers so that modifications are mad on original, values from 
             params are copied because it may be difficult to maintain integrity
- sequence data: the sequence to set from or to insert, for get/del data is not present
---
avendo appena rivisto il srv storage esteso anche alle seq nei processi ed in ram, ma anche da un punto di vista 
teorico, il concetto di constraint per le seq/storage DEVE essere considerato in modo ampio e probabilmente 
dovrò scegliere di includere le seq constraint dentro la seq di riferimento e non fare come ho detto sopra un 
raggruppamento per i vincoli ed uno per le seq dati, anche perchè spostando le seq da un processo ad un altro, 
cambiandone la persistenza, delocalizzarle su un altro pc ecc. sarebbe molto più complesso ed error-prone, 
gestirle separatamente...inoltre un vincolo può propagarsi direttamente alle subseq o prevedere che determinate 
subseq abbiano un certo tipo di vincolo ecc. insomma le possibilità sono infinite!!! per cui mi conviene affrontare 
il problema vincoli in un secondo momento ed addirittura rimandare la completa implementazione alla versione 2 di 
storage perchè dipende strettamente dalle potenzialità delle tform...quindi prima devo definire per bene le tform...
inltre un vincolo può essere relativo ai dati direttamente (set/ins) oppure alla seq risultante dalla op...ad es 
i dati rispettano tutti i vincoli per cui posso aggiungere una subseq alla seq madre, ma se questa può avere un 
numero di subseq tra 0 ed n, il non rispetto del vincolo in questo caso dipende dalla seq madre NON dai dati!!!

NB criteria = op-params...
NB i filtri check/filter-values possono essere uno per tutti indistintamente gli elem oppure può essere specificato 
un filtro/check diversi per elem specifici a determinati indici...
---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del, 4=create
- sequence params:
  - params: sequence of static-fixed params
  - filter-results: filled with results of specific filters used as dynamic params
  - subtforms: sequence of transformations used as dynamic params
  - this-seq filter chain: sequence of filters...filter=
    - id: -1=this, -2=all subseqs, 0,...,this-size=index of specific subseq
    - type: sequence of numbers specifing the chain of filter types
            0=match-width, 1=match-size, 2=width, 3=size, 4=indexes
            10=check-values, 11=check pattern, 12=check-numseq
            20=filter-index, 21=filter-values, 22=filter-pattern, 23=filter-numseq
    - static params index: index of params seq where to get the params for this filter
    - filter res params index:
    - subtforms params index:
  - reshape: create empty seq, get(path), set(path,seq), ins(path,seq), del(path) using this seq and params as input 
             values from this seq are stored by pointers so that modifications are mad on original, values from 
             params are copied because it may be difficult to maintain integrity
  - sequence data: the sequence to set from or to insert, for get/del data is not present
---
NB il reshape viene fatto sempre dopo il filtering...se per qualche motivo mi serve prima del filtering, non faccio 
altro che usare due tform separatamente con la prima che fa solo il reshape e la seconda fa il filtering...
---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del, 4=create
- sequence params: same definition for every op except that "data" is present only for "set" and "ins"
  - sequence filter: seq of filters...filter and check this seq and subseqs recursively to get only
    - sequence filter:
      - number id: -1=this, -2=all subseqs, 0,...,this-size=index of specific subseq
                   (how to specify a sequence resulted by a filter or its indexes sequence???!!!)
      - number op: 0=match-width, 1=match-size, 2=width, 3=size, 4=indexes
                   10=check-values, 11=check pattern, 12=check-numseq
                   20=filter-index, 21=filter-values, 22=filter-pattern, 23=filter-numseq
                   30=sub-tform with filtered sequences context
                   40=sub-tform with filtered sequences indexes context
      - number result: 0=filtered sequence + sequence of filtered indexes,
                       1=filtered sequence, 2=sequence of filtered indexes
      - sequence filter-params: reshape algorithm based on static data, results from previuos filters and 
                                defined tforms acting on other sequences
  - sequence reshape: create empty seq, get(path), set(path,seq), ins(path,seq), del(path) using this seq and 
                      params as input values from this seq are stored by pointers so that modifications are made 
                      on original, values from params are copied because it may be difficult to maintain integrity
  - sequence data: the sequence to set from or to insert, for get/del data is not present
---
pensare alle notifiche delle variazioni delle sequenze, ovvero un elemento di una sequenza quando viene modificato 
lancia un evento verso i listeners subscribed a quella seq...ora il fulcro sta nel come viene gestita la 
sottoscrizione dei listeners...cioè posso far si che ogni qualvolta una seq viene aggiunta ad un'altra seq, la master 
viene aggiunta come listener alla child, impostando che la notifica di un child viene propagata gerarchicamente in 
alto fa si che gli eventi arrivino alla root seq, la quale poi la inoltra a servizi di altro tipo (es. gui) oppure si 
può far si che la sottoscrizione propagazione derivi da una gestione custom caso per caso da parte di chi utilizza le 
seq, permettendo così che ascolto solo gli eventi di una particolare subseq...questa è la soluzione più efficiente...
