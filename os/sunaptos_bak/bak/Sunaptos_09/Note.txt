loader è un srv come gli altri tranne per il fatto che è l'unico che può interfacciarsi interamente 
con il os che l'ha lanciato e quindi l'unico che può lanciare altri processi.

anzi no, anche altri srv di sistema sono ad accesso full come loader (storage, config, log, etc.)
per ciascuno di questi si crea un exe specifico e con un md5 diverso e con nome diverso, in modo 
che tramite os (linux, mac, windows) posso dare a questi i diritti necessari e 
negare tutto a "client.exe" che genera tutti i srv "normali"

gli altri srv possono caricare solo le lib di sunaptos e nient'altro -> nb l'uso della rete è implicitamente 
concesso (purtroppo) perchè è necessaria a "client.exe" (che ha lanciato srv) per fornire la ipc

kernelloader (o remoteloader) al suo avvio lancia tutti i srv a lui funzionali come config, storage, ecc. 
poi lancia bootloader. in particolare config è importante perchè dice le regole con le quali decidere se 
i nuovi srv devono essere servizi o libs ad es. config deve essere un servizio, storage "non è necessario"...

TODO: pensare ed implementare l'architettura a supporto dei servizi in senso stretto, 
la gestione delle eccezioni ed errori attraverso le chiamate tra srv sia via ipc che tramite chiamata diretta

forse per implementare i servizi potrebbe bastare (o comunque può essere il primo passo) fare sì che 
per una stessa istanza di un srv vengano istanziati diversi canali ipc per ogni richiedente e poi è il 
particolare srv che gestisce le cose come un servizio...poi magari questo comportamento viene pensato come 
formalizzarlo ed implementarlo nell'architettura

pensare bene le interfacce degli streams, in particolare "size" bos/eos in relazione agli stream indeterminati 
come le socket: serve un metodo "available"? size se viene definito anche per gli indeterminati, cosa deve ritornare?

ogni metodo accetta un solo parametro (tramite puntatore) e ritorna un solo parametro (tramite puntatore) di 
tipo "Data" (finora) ma secondo me è meglio rinominalro "Stream" (o "Grid") e definirlo come interfaccia e non classe. 
così facendo separo il problema di impacchettare/spacchettare i dati quando devono usati al di fuori del 
processo, mentre all'interno del processo mantengo il massimo dell'efficenza (con solo l'appesantimento di un 
dynamic_cast) passando puntatori che non vengono serializzati, poichè la de/serializzazione viene effettuata 
invisibilmente solo all'interno dei wrappers cli/srv degli objs.
il "DataTree" che è la cosa difficile e che ancora devo definire, dovrà essere la struttura dati "perfetta" 
che implementerà "Stream" così come ogni suo sottoclasse...tale struttura deve essere pensata considerando: 
- un bel nome
- un'implementazione che massimizzi l'efficenza della de/serializzazione
- un'implementazione che massimizzi l'efficenza d'uso corrente
- un'implementazione che tenga conto dei possibili problemi di allocazione di memoria 
  (segmentazione, out of memory, ecc.)
- un'implementazione che ottimizzi il compromesso dynamic-typing-exceptions/compile-time-check 
  (probabilmente già trovato con l'utilizzo di dynamic_cast e l'interfaccia Stream come classe base di dati)
- un'implementazione che permetta l'utilizzo di sottoinsiemi aggregati di una struttura più grande, mantenendo 
  al suo interno comunque l'indirizzo/riferimento/path all'interno della struttura madre
- un'implementazione che possibilmente permetta agevolmente il calcolo distribuito 
  (cloud/grid-computing) facendo attenzione alla ricorsività intrinseca dal grafo connesso/ciclico (media priorità)
- un'implementazione che possibilmente permetta agevolmente il calcolo parallelo (bassa priorità)
- un'implementazione che possibilmente permetta agevolmente il calcolo real-time (bassa priorità)
- un'implementazione che possibilmente agevoli la persistenza (memorizzazione in uno "storage" persistente)

le esigenze della serializzazione finalizzata all'ipc sono: 
- l'operazione di riempimento (creazione/riassegnazione) di un oggetto deve essere completata affinchè l'oggetto 
  sia valido...in futuro si potrebbe anche pensare che l'interruzione generi comunque un oggetto validato, anche 
  se troncato (comunque generando l'exception)
- la trasmissione può avvenire in pacchetti di qualsiasi dimensione sia minore che maggiore della lunghezza dell'obj
- supporto alla write protection (con una chiave)
- supporto alla read protection (con una chiave)
- supporto all'accesso random (specificando un puntatore relativo)
- supporto all'accesso sequenziale (tracciando internamente un puntatore relativo)
- supporto all'accesso ad un numero variabile di bytes restituendo il numero di bytes effettivamente letti/scritti
- supporto al monitoraggio eof/bof (anzi eos/bos)
- supporto all'accesso dichiaratamente singolo o multiplo (ad es. posso solo leggere sequenzialmente una volta)

per il momento lascio la classe Data, ma la ristrutturo mentre penso a tutto quanto sopra e comincio a ripensare 
a come cambiare ipcs e ipcc che sono coloro che de/serializzano per capire come cambiare Data/Stream:
- creo l'interfaccia Stream
- a Data gli faccio implementare l'interfaccia stream
- sistemo ipcs ipcc in modo che utilizzino i metodi dell'interfaccia stream

gli oggetti data (ed ogni altro tipo per cui serva) vengono creati non con un "new" ma con due metodi: 
uno "persistent" che fa la stessa cosa di new ed uno "scoped" che viene memorizzato internamente in modo che 
quando viene chiamato il distruttore, questo fa il "delete" su tutti i puntatori scoped...in pratica fa una 
semplice "garbage collection" e cerca di evitare i più comuni casini fatti con i puntatori gestiti a mano

gli oggetti Data restituiti da chiamate a srv (anche processi separati, o remoti) potrebbero (pensare se non è un 
casino) essere aggiornabili automaticamente, cioè il srv che li ha generati li aggiorna automaticamente e 
trasparentemente a chiunque lo ha dato...è un casino!!! cioè servirebbe comunque un evento, allora tanto vale 
l'uso del pattern "listener"

data ha una componente di definizione struttura "dstruct" (hashata per fare i check) ed una componente di buffer 
virtuale "vbuffer" che gestisce trasparentemente l'allocazione (ram, disco, ecc.), la segmentazione, ecc.

vbuffer è costituito da un campo int per la versione che definisce la struttura successiva

buffer v01 prosegue con un campo long per la lunghezza in bytes (del campo dati), un campo int per il tipo di 
hash/checksum, un campo di lunghezza dipendente dal tipo di hash, un campo int per il tipo di crittografia, 
uno o più campi di lunghezza dipendente dal tipo di crittografia contenente eventuali chiavi o info accessorie, 
infine il campo data

dstruct  è costituito da un campo int per la versione che definisce la struttura successiva

dstruct v01 prosegue  con un campo long per la lunghezza in bytes (del campo struttura), un campo int per il tipo di 
hash/checksum, un campo di lunghezza dipendente dal tipo di hash, un campo int per il tipo di crittografia, 
uno o più campi di lunghezza dipendente dal tipo di crittografia contenente eventuali chiavi o info accessorie, 
infine il campo struttura...in pratica dstruct è un vbuffer con un particolare campo dati (=struttura) fatto così: 
una sequenza di campi che definiscono la struttura...da pensare come, ad es. tipo xml, tipo struct c, ecc.

tipi di dati: 
(elementari, lunghezza fissa)
long
long long
float
double

(elementari, lunghezza variabile)
string (variable size)
void (variable size) (custom and complex type, like image formats, ecc.)

(complessi->lunghezza variabile)
record<type1, type2, ecc.> (ordered, unamed (no field names), not homogeneus)
map<recordtype1, type1> (a multimap is a map with several types as keys)
  a map can accept any possible values as recordkey, or only within a set of recordkeys
  or within any possible combination of sets of fields (es field1:<1,2,3,4,5>, field2:<aa, ab, ac>)
  es. an array of 5 elements is a map with keys as a recordset of int of values 1,2,3,4,5
multimatrix<dims, <size1,..., sizeNdims>, recordtype1> as convenience (map will create too much overhead) is a 
  multidimensional array of record (es. matrix=multimatrix<2,<5,9>,long>)

NB set is implemented as array of void* and not directly supported in vbuffer-dstruct



(containers) (omo-etero, ord-unord, named-unamed, num-of-dimensions, size-of-each-dimension)
es. 
array: omo, ord, unamed, 1-dim, size=num of elements
matrix: omo, ord, unamed, 2-dim, size=m*n (num of rows, cols)
record: etero, ord, named, 1-dim, size=num  of fields
map: omo, ord, unamed, 1-dim, size=undefined/unlimited/irrational (between two elements can fit any element)
set: etero, unord, unamed, 1-dim, size=undef

array/vector<type> (homogeneus)
set (container of any mixed type)
record<type1, type2, ecc.> (ordered and named, not homogeneus)
matrix (multidimensional) is it a particular map (map<int, int, int, ecc.>(typeX))?
map (multidimensional) (map==matrix???)

data element: object containing type (long, float, char*, void), size and stored value (buffer) -> <t,s,b>
record: array (ordered) of de (types are inside each de)
map: 2 arrays, one of recordtype1 or de (keys), one of recordtype2 or de (values), both of same size (must)
multiarray: array of arrays-of-same-size of arrays-of-same-size...etc. of recordtype1 or de
-> any aggregation can be represented by an aggregation of an array (of arrays or de) and its size where 
   any particularity is mapped onto checking the size and type of each array element 
   eg a record is an array of arr/de of any size/type, map is an array of size 2 where 
   elems are type arr each of any same size, matrix is an arr of arr-of-any-same-size of any arr/de of any size/type
-> probably array should be considered a data element as well

per me i tipi di dato basilari sono: Number, Text, Vector
io uso le mie codifiche ma supporto quelle migliori tipo unicode, ieee floating point, ecc.
anche per i numeri definisco la mia codifica che deve venire utilizzata per la de/serializzazione (streaming)

un servizio può partire come:
- remote loader -> solo iface-stub, service-loop, no loader-ipc-key, no caller-ipc-key
- applicazione/comando standalone -> no stub, no service-loop, solo loader-ipc-key
- servizio -> se c'è già un'istanza, viene avviato solo lo stub con caller-key, altrimenti avvio con service-loop
- libreria -> caricato direttamente (NB attenzione che ai srv nati come servizi, non deve in genere essere consentito)
- libreria remota -> servizio
- come iface...

interfaccia ipc
client lancia il srv wrapper solo se richiesto da linea di comando
ipc prevede un sottosistema di ipc (altro canale o indirizzo, ecc.) dove inviare ricevere richieste di srv-wrappers
così si implementa il sistema dei servizi
implementare anche i "listener" cioè ipc bilaterale
fare interfacce per ipcclient ed ipcserver, poi implementare ipc via stream così lo riutilizzo per tutto
ripensare però alle interfacce stream compatibilmente con i socket o simili dove non si torna indietro
quindi o si astrae un comportamento generale che prevede il rewind, altrimenti 2 tipi di stream 
ad es. composti da due interfacce come streaminput+positionablestream (in contrasto ai limited-size-full-access-stream)
i socket potrebbero essere associati a degli stream che in realtà sono dei buffer dinamici dove ad ogni read vengono 
rimossi i dati letti dalla testa del buffer e dove la fine del buffer coincide sempre con i dati ricevuti 
e non ancora letti

ipc, forse, lancia eventi on-connect, on-disconnect, on-data-change, ecc. per comunicare all'altro estremo 
del canale quello che succede dall'altra

i parametri di ogni metodo di interfaccia solo ora accettano e ritornano Data*, in futuro accettano e ritornano 
qualunque numero di argomenti (completa c++ compliance) con la sola condizione che derivino tutti da Data. 
così facendo garantisco la ipc, ma anche la completa verifica type safe a compile-time. in pratica ogni struttura 
dati è riconducibile ad un'opportuna combinazione di Number, Text, Vector dove quindi nella classe derivata ci sono 
solo dei metodi che fanno da wrapper verso getnum, gettext, getvec, ma avere dei singoli metodi garantisce la 
correttezza semantica e di tipo del dato richiesto

nella massima astrazione anche Number e Text sono riconducibili and un vettore di interi (char, int, long, long long)
NB anche gli operatori!!! ovviamente rivisitandone il significato standard

per i number definisco la mia codifica consentendo: interi, decimali, virgola mobile, razionali, irrazionali, 
complessi, n-vettori, ecc. insomma tutti i tipi matematicamente necessari...ovviamente, tenendo presente che 
alcune codifiche devono avere requisiti matematici puri per le necessità strettamente matematiche, altre invece, 
devono avere dei requisiti di performance (codifiche di default) in base al hw sottostante

le codifiche sono astratte e generali nel senso che definiscono implicitamente sia il tipo di dato, che la sua 
rappresentazione...ciò vuol dire che un numero esadecimale lo posso mettere in un oggetto Number (forse...verificare!). 
in particolare significa che la codifica astrae dal significato (numero/testo)...la distinzione tra i concetti 
"quantità" e "qualità", è definita dagli esseri umani...in realtà il concetto di quantità può essere ricondotto 
al concetto di qualità (un po' tipo i numeri romani)...analogamente al raffronto tra lingue con alfabeto e lingue 
con ideogrammi

considerato anche che numeri e testo sono la stessa cosa, che la codifica indica il tipo/rappresentazione, 
per i numeri/testi non è automatica la relazione di uguaglianza (=, !=, <, >, <=, >=), così come le operazioni 
basilari...quindi in puro stile matematico, le relazioni e gli operatori standard non sono a priori definiti, 
ma possono essere cambiati dinamicamente...ad es l'ordinamento del testo può essere in base al codice ascii, 
oppure in base al contesto a<b<c<... ed i numeri vengono comparati coe numeri e non come stringhe, oppure possono 
esserci altre relazioni di ordinamento arbitrarie (per specifiche esigenze...ad es un'analisi di contesto che 
interpreta anche i numeri romani, le formule matematiche, ecc.)

quindi posso pensare di definire tutti gli operatori standard del c++ che wrappano su delle generiche interfacce 
operatore/relazione (nel senso matematico), definendo degli operatori/relazioni standard che abbiano come subset 
almeno i principali operatori c++.
in generale operatori/relazioni vengono definiti tramite metodi e non mai tramite gli operatori c++ che vengono usati 
solo come wrapper per le cose più comuni, ma che sarebbe bene anche farne a meno.
a tal proposito ritorna ancora più evidente l'utilizzo dei vettori come container generale e come oggetto di 
passaggio parametri/risultato, superando quindi le limitazioni del c++ (e la maggiorparte dei linguaggi).
per i vettori (ma anche numeri/testi) ha senso invece l'utilizzo degli operatori []
una implementazione (lenta) degli op/rel potrebbe essere quella con un unico metodo "op(params)" dove in params 
codifico quale op/rel richiamo, altrimenti dovrei definire degli operatori/rel singleton (e non classi statiche 
perchè altrimenti non posso avere il puntatore) i cui puntatori li memorizzo negli oggetti num/txt.
NB op/rel agiscono in genere in maniera astratta sul singolo "carattere" se poi l'azione sul carattere/vettore 
opera nel contesto numerico o testuale o se tiene conto o non della codifica (solo codifiche testo e specializzata 
alla particolare codifica, oppure tutte le codifiche o solo un subset particolare, ecc.)

la differenza tra testo e numero è che il testo ammette un unico set di valori in qualunque posizione e la dimensione 
dell'oggetto è variabile, mentre il numero ammette diversi set di valori in determinate posizioni (assolute/relative). 
quindi per il momento li tratto diversamente per efficienza computazionale

nella de/serializzazione di chi deve essere la resposabilità di serializzare type, size, wide? idealmente dovrebbe 
essere l'oggetto stesso, ma poi vector come potrebbe fare correttamente la deserializzazione senza sapere in 
anticipo quale oggetto costruire sul quale poi fare il read? ...provare con il polimorfismo, cioè Streamable legge 
type, size, wide e demanda il resto ad un oggetto in base a type...non torna...
soluzione ridondare il tipo così: vector de/serializza anteponendo il tipo rtti cioè un id per la classe giusta 
per il tipo di dato => l'interfaccia Streamable deve supportare la rtti magari con metodi statici...pensare bene!!!
ma se io ho detto che tutto è riconducibile a vactor, number, text, allora basta fare come ora tipo=1,2,3

cercare c++ reflection...

- concetto filosofico discreto di carattere e linguaggio e altri concetti correlati:
un "carattere" è un elemento (uno stato) appartenente ad un insieme finito, dal punto di vista fisico un carattere 
è uno stato di un'entità fisica o fenomeno appartenete ad un sottoinsieme finito degli stati possibili (che 
potrebbero essere infiniti...). ciò significa che se un alieno comunica variando gli spin atomici o gli stati 
energetici dell'atomo, fotoni, muoni, orbita gravitazionale, ecc. insomma con questa definizione possiamo 
accomunare il suo linguaggio al nostro e prevedere delle regole di traduzione già definibili intrinsecamente 
in questa "matematica del linguaggio"...in pratica ogni fenomeno fisico o metafisico, ogni concetto astratto 
può essere utilizato per comunicare...NB anche tra umani incoscientemente la comunicazione avviene anche 
tramite linguaggi "non verbali" definirli o recepirli o interpretarli "matematicamente" è possibile con la 
"matematica del linguaggio" qui definita (pensare agli autistici, gli animali, le piante, gli alieni ed ogni 
altra forma di vita...anzi può essere definito anche il linguaggio delle entità non viventi o addirittura 
dell'universo o degli universi...che non è altro (quasi) che il linguaggio fisico che viene cercato di tradurre 
il più fedelmente possibile dagli umani tramite il linguaggio matematico).
NB la definizione di carattere fondamentale andrebbe associata ad un fenomeno fisico reale per avere senso 
chiamarlo "fondamentale"...
nella pratica quotidiana invece definisco "fondamentale" ciò che mi fa più comodo (come nelle migliori famiglie 
matematiche)

- concetto filosofico continuo di carattere e linguaggio e altri concetti correlati:
è possibile definire la "matematica del linguaggio" anche tramite concetti "fuzzy", ovvero il carattere non come 
"stato distinto" ma come "punto continuo" cioè come stato reale continuo cioè non più come stato orbitale 
di un atomo, ma ad es. come lunghezza d'onda di un fotone o una radiazione qualsiasi o suono...chiaramente il 
"linguaggio continuo" (o fuzzy) è poco pratico nella realtà umana odierna e troppo sforzo rispetto alla mia 
utilità, perciò per il momento mi focalizzo sul linguaggio discreto...

- esempio di carattere discreto fondamentale: valore di un byte...potrebbe essere anche il bit, ma la scelta sarebbe 
ottimale per le cpu ed un linguaggio macchina, per il c++ e linguaggi di alto livello ha più senso scegliere 
come carattere fondamentale il valore di un byte ovvero il valore di un tipo di dato "unsigned char". il tipo 
di dato "unsigned char" rappresenta l'insieme degli stati possibili ovvero dei caratteri possibili
"alfabeto" = tutti i possibili valori ammessi per un carattere, ovvero l'insieme degli stati considerati

- linguaggio discreto:
"carattere fondamentale": valore appartenente ad un unsigned char (typedef unsigned char charf)
"carattere complesso": valore appartenente all'insieme di tutte le combinazioni possibili di più caratteri fondamentali
(cioè "c" appartentente all'insieme dei valori possibili di charf[d] dove d è la dimensione "wide" del car.compl.)
es. unicode_character -> charf[2], ascii_character -> charf, o charf[1]
"complessità" (o larghezza o wideness): numero di caratteri fondamentali che compongono il carattere complesso
NB non utilizzare mai charf da solo, bensì charf[d] anche se d=1 per non perdere di generalità, cioè filosoficamente 
significa che l'elemento fondamentale viene considerato "teorico" o "mistico" e passare dal trattare lo stato 
"mistico" di limitata utilità pratica (cioè non serviva tutta 'sta manfrina se rimanevo chiuso in 8 fottutissimi bit) 
allo stato "complesso" cioè nello spazio dei caratteri complessi, dove complessità 1 è un caso come gli altri...
NB carattere complesso significa l'aver implicitamente introdotto il concetto di "insieme finito ed ordinato di 
elementi"...diamogli un nome!!!
"insieme finito ed ordinato di elementi (caratteri fondamentali)": sequenza finita (cioè sequence == charf[])
sequenza finita: ha un inizio ed una fine (stringa -> non mi piace come nome)
sequenza infinita (semi-infinita): ha un inizio ma non una fine (stream -> non mi piace questa ambiguità)
sequenza bi-infinita (infinita): non ha inizio e non ha una fine (stream -> non mi piace questa ambiguità)
rete (net): generalizzazione delle sequenze
rete finita: ha un nodo di inizio ed ogni possibile path termina (con una foglia)
rete infinita: ha un nodo di inizio ed ha almeno un path infinito
rete bi-infinita: rete infinita dove non esiste nemmeno il nodo iniziale, ovvero ogni path è una sequenza bi-infinita

cosa faccio definisco stream come sequence? oppure? ...

class Character represents complex characters finite sequences -> depending of the context it may represent
a text string or a number (bool, int, float, etc.).
Text and Number classes inherit this class to provide specific contextual functionalities and facilities.
Paradox: defining a language means using a predefined language for definition (tautology).
we assume the predefined languages to be c++ language and basic "numeric" language with "character" alphabet.
we don't care what happens inside methods, only the interface is important to behave as theory wants.
numeric language is not required, quantities (wideness, ordinal position) are conceptually "characters"
the important thing is to guarrantee to have enough "states" (size of number) to represent dynamically
any complexity.
complex characters are defined on behalf of fundamental characters.
we defined the fundamental character
we define an intermediate complex character to behave as a big enough number useful to easily define
complexier characters

ambito testo ed ambito numerico: se ho del testo unicode, ho 16bit per rappresentare caratteri che non hanno 
significato numerico per cui all'interno del testo uso alcuni caratteri (0-9) per rappresentare dei numeri... 
altrimenti dovrei cambiare contesto e passare dalla codifica unicode alla codifica "int16" e mi basterebbe 
un solo carattere per rapresentare in numero 32000, anzichè 5 caratteri 16bit in unicode...questa è traduzione 
alfabetica, cioè il mappare un alfabeto in un altro.
tale questione è di non poca rilevanza perchè mi pone delle domande su come trattare testo e numeri, considerando 
anche che vorrei utilizzare per entrambi le sequenze e che bisogna tenere presenti i problemi di allineamento 
di memoria.
credo di non avere problemi ad usare le sequenze per entrambi facendo attenzione all'alineamento affinchè possa 
tradurre da/verso i basic data types / sequenze tramite dei semplici c-cast dei puntatori alle sequenze/numeri. 
l'altro problema dovrebbe risolversi in parte (ma è un semplice rimandare il problema) memorizzando nella sequenza 
la codifica utilizzata...il che mi permette di sapere che cosa ho nella sequenza (testo ascii, numeri puri, ecc.)

che cosa posso fare con i caratteri da soli? niente (pensare a controindicazioni)
tutto quello che voglio fare lo devo fare sulle sequenze (eventualmente sequenze monocarattere)
come sto usando Character nella definizione di CharacterSequence, in pratica è come se fosse un numero altrimenti 
dovrei ricadere nel paradosso di usare CharacterSequence per definire CharacterSequence, l'alternativa sarebbe 
utilizzare i basic data types per definire CharacterSequence.
oppure potrei usare Character semanticamente come numero definendo in esso la sola relazione ordinale e nessuna 
operazione, quindi ai soli fini di ordinamento ed implicitamente di dimensionamento (cioè attribuire delle grandezze). 
CharacterSequence invece la uso per definire i numeri come li conosciamo noi, ovvero con le operaioni ed il resto.
NB mi devo interrogare sul perchè voglio veramente i numeri come sequenze anzichè come caratteri perchè la naturale 
associazione sarebbe Character = numeri, CharacterSequence = testo...ma io voglio uniformare soprattutto ai fini 
dello streaming/serializzazione, ma in realtà anche per un altro motivo: con le sequenze posso definire teoricamente 
numeri infiniti e le operazioni rimangono nello stesso spazio (delle sequenze semifinite) altrimenti n+m=k dove 
k ha complessità +1 rispetto ad n,m.
potrei prendere due piccioni con una fava così (pensare bene): uso Character come numeri veri cioè uniformo non più 
numeri con stringhe, ma numeri con caratteri e nello streaming uso le sequenze (generiche). in pratica devo memorizzare 
l'encoding nel singolo carattere (waste of memory for strings), le sequenze sono nient'altro che un wrapper...

devo definire classi diverse: "Sequence" come sostituto generale di "vector" e CharacterSequence come sostituto di 
testo e numeri. ciò vuol dire che anche se concettualmente simili, si utilizzano in modo diverso ovvero Sequence 
è un conteiner di oggetti Streamable, o un container per "net"? o altro? ...pensare...

cosa devo poter fare con le sequenze di caratteri:
- tipiche operazioni sulle stringhe (append, substring, ecc.) e sui numeri (+,-,*,/,%)
- relazioni generiche (unarie, binarie, n-arie, ecc.)
- operazioni generiche
- funzionali vari
- passare a spazi diversi (cambiare wideness) gestendo anche il passaggio di codifica
- passsare da una codifica all'altra nello stesso spazio

ho deciso:
- basic char: float
- big char?: se si allora è un double...intanto lo definisco, cerco di non utilizzarlo (deprecato) però se serve, c'è!
- complex chars: NO ARRAYS (character[])! se servono caratteri grossi allora uso la classe Character con tutte le 
operazioni definite tali e quali alle op definite dal c++ sui float/double...NB pensare bene ad un'implementazione 
veloce per la MIA rappresentazione floating point sui multicaratteri...NB definire una rappresentazione "numerica" 
significa definire la famosa relazione ordinale in base alla quale sono poi automaticamente definite le operazioni 
numeriche standard. per il momento implemento il minimo indispensabile, magari vedo se posso fare la furbata di 
definire Character come typedef di double...tutto dipende da come utilizzo Character in CharacterSequence...
- char seq: in pratica è l'estensione per le stringhe con caratteri di ampiezza qualunque...per il momento mappo 
tutto in puntatori a character[w][s] dove w=1 per tutti i casi pratici NB w=1character=sizeof(float)=word=4bytes...
più del necessario ma si guadagna in velocità "portabile" perchè tanto per allineamento anche char prende 4bytes 
e quando non lo fa, fa perdere velocità...perciò la mia decisione è giusta così.
ora devo decidere se char seq rispetto alle operazioni si deve comportare come stringa o come Character (cioè 
come un numero)...e qui è che si apre il mondo perchè se devo poter usare sia character che Character che 
CharacterSequence come numeri ci deve essere un senso...ed in effetti c'è: l'esistenza della relazione ordinale!
inoltre c'è anche un altro motivo: concettualmente caratteri complessi e sequenze di caratteri sono la stessa cosa, 
ma sono solo ambiti (spazi) diversi...perciò definisco le operazioni sulle seq di caratteri in base alla relazione 
ordinale..ergo devo prima definire bene la relazione ordinale STANDARD (poi altre custom le posso mettere comunque) 
magari in futuro per fare le cose fiche definisco l'interfaccia "relazione ordinale" di cui la rel.ord.standard è 
un'implementazione, poi definsco le op standard tramite l'interfaccia rel.ord.

problema: float o double? l'ideale per le performance, il range e l'utilizzo sarebbe double, ma sprecare 8bytes per 
un carattere quando di solito ne basta 1, è un po' troppo...a meno che...furbatona...uso le dimensioni frazionali!!! 
e perchè no? tanto i numeri possono essere con la virgola (double) (NB attenzione alla precisione e gli arrotondamenti 
dei numeri in virgola mobile...) avere sequenze di un alfabeto sottospazio aumenta anche la generalità...quindi, 
tutti contenti!!! deve solo essere arrotondato ad 1byte
...a questo punto potrei anche abbandonare Character (o rinominare character in Character) ed usare esclusivamente 
le sequenze sia come caratteri-complessi/grandi-numeri che come stringhe...dovrei solo fare attenzione a non 
incappare nuovamente nella dipendenza ciclica di una classe da se stessa...
domandona: ma che senso ha usare caratteri complessi quando il linguaggio prevede allocazioni di dimensione massima 
pari al maxvalue-of-size_t? -> devo definire un oggetto Memory (singleton) che alloca dealloca memoria di qualunque 
dimensione e ciò grazie all'uso dei caratteri complessi o sequenze come parametri...avere limitazioni dentro Memory 
ha molto senso perchè è un'interfaccia verso l'hardware disponibile che ha i suoi limiti fisici e quindi tutto va 
bene se non fosse per il fatto che Memory dovrebbe essere un srv? per il momento me ne frego ed uso Memory come 
un semplice componente della core library, ma poi dovrò pensare a come si deve interfacciare l'hardware con i 
srv e come gestire l'accesso simultaneo...per le periferiche secondarie/lente non è un problema, la cosa difficile 
è gestire componenti basilari come cpu/memoria soprattutto se voglio supportare ad es "memoria hot-plug"...

Character non ha encoding all'interno perchè per descrivere l'encoding mi servirebbe un Character (o sequenza) 
ma sarebbe una dipendenza ciclica, in realtà un carattere è uno stato che da solo non significa niente, l'encoding 
poi è una mappatura ad un altro alfabeto

relazione ordinale: per le sequenze (sia Character che CharacterSequence) a sinistra c'è il carattere meno 
significativo (cioè il contrario dei numeri), le sequenze più lunghe sono "maggiori di" (così come 20 è maggiore 
di 3) quindi da destra a sinistra è maggiore la sequenza col primo carattere (da destra) che sia "maggiore di", 
si arriva quindi alla comparazione tra carattere complessi che in genere hanno larghezza diversa e per i quali 
la comparazione si fa con lo stesso procedimento (in pratica sono array di double, dove quello di sinistra è 
"il meno significativo"...e rappresenta una cifra come se fosse il sistema arabico al contrario), si arriva 
quindi al carattere fondamentale che ha il suo ordinamento definito a priori.
operazioni fondamentali: da quanto sopra la somma si fa carattere a carattere da sinistra a destra con il riporto...
e l'equivalente dei numeri decimali? ...mi servono le sequenze ad indice negativo e quindi i numeri con indici 
negativi sono l'equivalente dei numeri dopo la virgola...mi sembra perfetto!!!
con questa estensione (seq negative), bisogna espandere anche "append": append left, right, centre; dove 
appleft mette la seq di sinistra alla estremità sinistra di quella di destra (es "asd.asd" al "qwe.qwe" = 
"asdasdqwe.qwe"), appright analogamente (es "asd.asdqweqwe"), appcentre pure (es "asdasd.qweqwe")

pensare se voglio le sequenze fast (anche se grosse) e le sequenze generali o solo quelle generali

nuove decisioni:
- utilizzo fast tramite "character" sia come carattere che soprattutto come numero (double) => massime performances 
(almeno su architetture 64bit, su 32bit sono al max doppie dei float...in ogni caso è inutile guardare al passato 
per ottimizzare, col passato al massimo si mantiene la compatibilità, ma solo se non compromette il futuro -> 
principio di carattere generale)
- rimane il problema che non posso rendere "character" intrinsecamente streamable, per cui potrei pensare 
al contrario, ovvero non rendere gli oggetti streamable, ma gli stream capaci di serializzare determinati 
oggetti...però questo vuol dire perdere di generalità...ma potrebbe essere anche un bene perchè così vincolo cosa 
può essere serializzato
- utilizzo di sequenze con il max della generalità, ma con il limite di essere finite <=> sono numerabili tramite 
character...matematicamente: <S,C,A> è uno spazio finito <=> l'insieme delle sequenze S e l'insieme dei caratteri C 
hanno cardinalità inferiore o uguale alla cardinalità di A, cioè <=> dato n il numero di elementi di A, le sequenze 
hanno al massimo n caratteri ed il numero degli elementi di C (caratteri) è al massimo n
NB A è un sottoinsieme di N
- in pratica fisso lo spazio massimo accettabile <S,C,A> pari a <S,double,double> (NB ascii=<S,char,double>)
dove per "double" intendo la parte intera del double
- le sequenze infinite sono matematicamente un'altra cosa, nella realtà non è detto che esistano, quindi 
è accettabile escluderle, ma devo comunque considerare delle cardinalità arbitrariamente grandi
- astraggo i limiti fisici tramite l'utilizzo di una classe "Memory", ma rimane il problema della cardinalità
- attualmente i limi me li impone il compilatore con i basic data type (double) perchè anche se astraggo con 
una classe (perdendo molta velocità) i limiti rimangono implicitamente dall'uso dei basic data types all'interno 
della classe (il problema è ricorsivo...alla fine arrivo sempre a double/long-long) anche se uso gli array e 
anche se uso i puntatori...per allocare la memoria arrivo sempre a funzioni o elementi del linguaggio che 
richiedono l'uso di basic data types...che fare? l'unica soluzione sembra l'utilizzo della ricorsione e dei 
puntatori (es tipo le liste) cioè gestisco blocchi con i bdt al massimo delle possibilità, poi i puntatori 
a tali blocchi li metto in un blocco...i puntatori a tali blocchi li metto in altri blocchi, ecc. insomma 
mi si viene a creare una struttura ad albero arbitrariamente ricorsiva che mi nasconde i limiti della memoria fisica. 
ci sarebbe il problema dell'accesso (indirizzamento) che può essere altresì risolto con la ricorsione (es 
root->getblockpointer()->getelempointertoblock(i)->getelempointertoblock(j)->getelempointertoblock(k)->...) 
in pratica un albero "arbitrariamente finito" che è l'esatto equivalente matematico che voglio ottenere...ora 
devo capire come renderlo pratico...uso Memory come albero che mi permette di avere un'allocazione di memoria 
arbitrariamente lunga (NB andrebbe ugualmente bene (o addirittura meglio?) utilizzare una classe Array), devo solo 
studiare l'interfaccia adatta che mi consenta di: sapere la dimensione lineare accedere ad un blocco tramite 
un'indirizzo ricorsivo e di lunghezza ricorsiva specificata, cioè del tipo 
"Memory* Memory::getBlock(Recursive address, Recursive size)" fregandosene ampiamente della sincronizzazione, 
thread safety ecc. un'interfaccia di quel tipo può rappresentare la base per array multidimensionali (tra le 
altre cose) di arbitrario numero di dimensioni e di arbitrarie dimensioni dove NB "Recursive" non può essere 
banalmente "Memory*" poichè concettualmente sono due cose diverse ed infatti le interfacce devono essere diverse. 
Recursive ha praticamente il significato di un carattere (o numero) arbitrariamente grande (NB al posto di 
size dovrei usare address2 per evitare di introdurre i concetto di numero che mi riporterebbe ricorsivamente 
ai problemi iniziali, quindi Recursive rappresentano "indirizzi" astratti/virtuali di memoria lineare, vabbè è 
inutile, si può lasciare size che sarebbe lìindirizzo virtuale (rispetto a se stesso) massimo che il sottoblocco 
avrebbe) Recursive in pratica è un carattere complesso (cioè Character) ovvero un array arbitrariamente lungo di 
caratteri base (character)...quindi dopo tutte queste considerazioni emerge che posso definire una classe 
CharacterSequence che lavora in due modalità: una fast con tutte le interfacce basate su character, quindi 
opero nell'ambito di una "foglia concettuale", l'altra modalità ricorsiva dove ci sono interfacce basate su 
Character per il quale vale lo stesso discorso...internamente sia CharacterSequence che Character usano Memory 
per il quale vale lo stesso discorso opera su character finchè può, poi passa a Recursive che però è un Character 
quindi ritorna il problema di ciclicità a meno che seppur concettualemente identici distinguo Character da 
indirizzi e dimensione utilizzando il concetto di ordinamento...insomma tutto sto casino per decidere che alla 
fine non è vero che tutto è un carattere ma tutto è un numero! ...è già, perchè posso pure dire che l'ordinamento 
è un concetto astratto e che lo costruisco ricorsivamente così come i caratteri, ma dietro il concetto di 
ordinamento ci sono i numeri che guardacaso si costruiscono ricorsivamente e quindi??!!! facciamo finta di niente 
definisco un altro nome che non sia "carattere" o "numero" ad es tipo "ordinalem/ordem/ore/etc." (ordinal element) 
così astraggo ulteriormente dicendo che un linguaggio deriva dalla definizione di una relazione base su un insieme 
(finito, infinito, discreto, continuo) di stati...ora bisogna capire se questa relazione deve essere per forza 
di ordinamento e/o che caratteristiche deve avere. sulla base di un linguaggio base posso definire delle regole 
ricorsive di espansione del linguaggio per incrementarne (e daje co' 'sti numeri) le possibilità.
NB comunicare vulo dire sparare sequenze di caratteri...sequenze appunto, quindi l'ordinamento lineare è 
il prerequisito per la definizione di un linguaggio.

alla fine sono troppe pippe mentali per il momento e forse è meglio continuare con number=double e text=wstring, 
oppure pensare di espandere text in modo che sia anche considerabile come sequenza di "number"...
a questo punto c'è il problema dei vettori/data: gli array/vettori sono insiemi ordinati che abbiamo stabilito 
essere alla base di qualunque cosa (linguaggi, numeri, caratteri), cioè l'ordinamento genera le sequenze/vettori 
le quali generano un linguaggio.
quindi partiamo dall'ordinamento implicito nei "double del c++" definito a priori, su questo definiamo le 
sequenze (generiche sia per caratteri, oggetti, ecc.), qui c'è un solo problema: sequenze omogenee ok, eterogenee 
non banali per via del fatto che non sono direttamente supportate dal linguaggio posso utilizzare i puntatori e 
l'allocazione dinamica, ma non so cosa c'è dentro, per le sequenze generiche forse mi può andare bene ma non 
sono streamable...
ecco la paraculata: number è l'elemento base, tutto il resto è una sequenza di number e sequenze (implica un gran 
spreco sulle stringhe a parte che posso rimappare l'array...) quindi è la sequenza che si occupa di serializzare 
i double, le sequenze richiama i loro read/write...rimane il problema di come faccio a sapere se in una posizione 
della sequenza c'è un double o un'altra sequenza (NB queste sequenze sono in realtà delle reti...)...posso imporre 
di passare al concetto di rete e tenere due liste distinte una per i double, una per i puntatori ad altre sequenze 
(NB nel concetto originario, avevo considerato i record al posto dell'array di double, o un solo elemento...ma 
qui siamo andati oltre astraendo da tutto abbiamo ricondotto tutto ai numeri) così ho definito delle sequenze 
semiomogenee sulle quali posso derivare un'altra classe per implementare il concetto generale delle sequenze 
eterogenee base semplicemente introducendo una sequenza di indirizzi dove mischio puntatori a double e puntatori 
ad altre sequenze nell'ordine che preferisco in pratica una mappatura! se poi voglio introdurre dei tipi complessi 
come i record, le matrici, le mappe, ecc. basta che riconduco tutto a double e sequenze e creo una classe wrapper 
che offre i metodi per offrire le funzionalità tipiche di quel tipo complesso. ovviamente le sequenze devono 
implementare tutte le operazioni e funzionalità che si possono inventare sulle sequenze (considerando anche che 
ho un due array in ogni sequenza)

il risultato di quanto sopra è l'avere una base che mi permette di generare qualunque cosa e che basilarmente mi 
offre le funzionalità richieste dalla mia infrastruttura, ovvero la serializzazione ed in futuro chissà cosa...

problema: ownership dei dati e puntatori contenuti nelle sequenze ad es se deleto un nodo, deleto in cascata 
tutti i path? se fosse un grafo ciclico sarebbe l'autodistruzione perchè cancellare un nodo, cacellerebbe tutto 
il grafo...probabilmente lo lascio come opzione di creazione del root node e come metodo richiamabile, gli altri 
nodi possono essere creati sono tramite il nodo padre...pensare anche se sembra ok così...

riorganizzare: template base uguale a std::vector con le mie funzionalità e basta, poi sequence implementa 
Streamable ed offre solo due metodi: miovector<number>* getnumbers() e miovector<Sequence*>* getsequences() 
così evito di duplicare i metodi e le implementazioni ed è molto più razionale

riorganizzare: template base uguale a std::vector con le mie funzionalità + l'accesso raw tramite puntatore al 
array per consentire di memorizzare il puntatore ed avere poi l'accesso alla massima velocità e basta. quindi 
ora ho una classe per manipolare le sequenze omogenee ma anche un accesso velocissimo ed una manipolazione 
diretta dei dati senza overhead. il limite è la memoria contigua, cosa di cui me ne frego perchè se ho una 
quantità spropositata di dati e l'hardware è pietoso, non è un mio problema! casomai è un problema del compilatore 
...ma nemmeno!
dunque, a me servono le sequenze di sequenze, le sequenze di number e le sequenze raw di ampiezza che decido io 
e cioè sequenze di ascii, sequenze di unicode, ecc. il problema è che usando i template non posso definire 
direttamente le seq di seq perchè devo specificare il tipo, quindi potrei usare le seq di streamable ma non 
va bene perchè dovrei fare i dycast, l'alternativa sarebbe le seq mutevoli cioè come i template, ma a runtime!
NB approfondire come il c++ gestisce l'accesso agli array multidimensionali (se fa somme, moltiplicazioni, ecc. 
con i puntatori, indici ecc.)
potrei usare dei metodi reshapeas... che cambiano l'ampiezza del singolo elemento dell'array, quindi il raw deve 
essere void* ed uso i metodi get... per avere il tipo voluto, questo implica che non posso più usare l'operatore [].

ho una seq dentro ci posso mettere puntatori ad altre seq, oppure elementi number, oppure elementi generici di 
ampiezza (in bytes) non definita a priori, oppure definite le sottodimensioni di number, ovvero num8-16-32-64. 
in questi sottotipi ci posso mettere quello che mi pare numeri piccoli, interi, float, stringhe ascii, stringhe 
unicode, ecc. cioè number è il tipo naturale che mi consente tutto alla max velocità, gli altri sono tipi di 
ampiezze esatte e predefinite per particolari esigenze (spazio, interfacciamento, ecc.) mettendo la velocità 
in secondo piano, fare il reshape è deprecabile perchè altero il tipo originale che ci ho messo dentro, quindi 
è preferibile usare i templates, perchè tanto alla fine devo sempre gestire i diversi tipi suddetti. quindi 
ho 5 tipi ed una seq template che mi genera altrettante 5 seq, poi ho una seq di puntatori che mi ritorna seq
dei vari tipi (5+1) il problema è che la seq di seq non la posso fare...o faccio la seq di streamable e poi 
l'utente fa il dycast, oppure faccio una derivata di questa ed aggiungo dei metodi che wrappano il dycast. 
l'uso del template mi serve anche per mantenere il raw array del tipo specificato.

faccio seq tale che nel costruttore decido cosa conterrà (no templates) ha metodi che ritornano tutti i tipi 
previsti (seq, number, num8-16-32) che lanciano un eccezione se il tipo non è corrretto
---
Sequence& s;

char8seq c8s = s.get(0);
number n = s.get(1).get(0);
c8s.append("asd");

Sequence s1; // sequence of sequences
Sequence s2((number) 2); // sequence of char16
Sequence s3(0); // sequence of numbers

number n = s3[0];
s3[s3.size()] = 0;
Sequence s = s1[0]; // reference

non è possibile perchè l'operatore [] ritorna lo stesso tipo, si potrebbe fare solo con i templates...quindi diventa:
number n = s3.getnumber(0); // reference
s3.getnumber(s3.size()) = 0; // reference
Sequence s = s1.getsequence(0); // reference
s3.subsequence(6, 9); // tipo in base alla costruzione

s.number().get(0); s fa un dycast di se stessa a seq di numbers

+++

come ottenere ciò?:
number[] n = s.get(0);
text t = s.get(1);
sequence* sq = s.get(2);

tengo un void* (in realtà char o num8) usando realloc che mantiene il contenuto che posso castare ad array di 
qualunque cosa (number, num8-16-32, seq, ecc.) devo fare attenzione ai num16-32 perchè sono array e devo vedere 
che succedo se li casto a int, long ecc. 
che operazioni consentire? resize (basato su num bytes == realloc), le assegnazioni le faccio tramite array ottenuto 
da get(). 
in realtà potrei memorizzare qualunque dato come se fosse una struct immaginaria dove l'utente accede specificando 
indice (numero di byte) e tipo da ritornare (number, num8-16-32, void* pointer) dove gli indici potrebbero anche 
essere dei define per esplicitare una singola struct immaginaria. 
potrei anche pensare le seq come seq di number assicurandomi che sizeof(number) possa contenere i puntatori (cioè 
puntatori a sequence*), ma come gestisco il problema dei sottotipi?
allora creo diversi get che mi ritornano array del tipo che mi serve (reshaping) ed internamente impostano il wide 
appropriato così tutte le successive operazioni si basano su questo, cioè il get fa il reshaping implicito, oppure 
prevedo il reshape esplicito e se uso il get sbagliato lancia un'eccezione. posso anche imporre il wide in fase di 
costruzione ed impedire il reshape...
in pratica i number li accedo direttamente il testo e le seq no lo uso implicitamente e ci faccio operazioni sopra... 

numeri, sequenze di dati (numeri, testo, ecc.), sequenze di puntatori a sequenze. 
posso decidere che le sequenze siano omogenee, il che significa che i dati (numeri) sono solo sulle foglie, altrimenti 
ho sequenze di numeri in ogni nodo, mi sembra più ragionevole la prima ipotesi...
usando i templates avrei data=seq<streamable*> per cui poi dovrei fare un dycast da streamable* a seq<number>

number n = dynamic_cast<numseq>(params.get()[0])[0]; // un vero casino
sequence s = dynamic_cast<sequence>(params.get(0));
numseq sn = dynamic_cast<sequence>(s.get(0));

ritorniamo al discorso che data=params=seqseq dove get ritorna numseq o seqseq, quindi seq potrebbe avere un array 
di puntatori a sequenze di vario tipo quindi se seq è numseq allora avrà un array di un elemento che punta ad array di 
numeri se 

number[] n = s.get(0).raw();
sequence* sn = s.get(0);
number m = sn.raw()[0];
text t = s.get(1);
sequence* sq = s.get(2);

number n = (number) p.buf[0]; // multimatrix
string s = (num8) p.buf[0];
sequence sq = dynamic_cast<sequence>(p.buf[0]);
number n = (number) sq.buf[0];
number n = p.getseq
number n = (number) p.buf[0][0];

pensiamo tutto in termini di seqseq...è impossibile in termini di template, solo classe! così facendo si arriva a delle 
seq che in realtà non contengono altre seq, ma dati, qui posso fare il raw, ottengo un num8* (num8[]) che posso castare 
a number* o number[] o num16* (num16[])

sequence s = p.get(0);
string str = p.get(1).raw();
wstring ws = (num16) p.get(2).raw();
number[] n = (number*) p.get(3).raw();

i puntatori DEVONO essere trattati diversamente perchè nello streaming non devono comparire ma essere rimpiazzati dagli 
oggetti a cui puntano...per cui forse devo riprendere i discorsi teorici e fare il passaggio da seq a net. 

---


UNIVERSO:
partiamo dall'inizio...
esistente: concetto assiomatico primario e non definibile. 

universo: è l'insieme dell'esistente (o degli universi nella comune accezione) per il quale è sempre valida la legge 
di causa-effetto.

legge di causa-effetto: transizione/trasformazione/funzione continua dell'esistente da uno stato x ad uno stato 
x+dx sulla linea del tempo.

tempo: particolare linea a cui è stato attribuito questo nome sulla quale sembra basarsi ogni transizione/fenomeno 
dell'esistente comunemente chiamato multiverso (NB multiverso è sottoinsieme dell'universo definito da me).

NB <esistente, trasformazione/funzione, linea> sono i concetti assiomatici primari e non definibili che consistono 
nella massima astrazione umanamente possibile della realtà esistente confidando che permetta eventuali ulteriori 
astrazioni nel caso se ne dimostri la possibilità...

universo: <esistente, causa-effetto, tempo>

sequenza: ...

NB la sequenza eterogenea è il concetto più naturale basato sui concetti assiomatici...
NB sequenza è un concetto anche più astratto del concetto di universo

vediamo quindi di ricondurre il concetto di rete, grafo, ipergrafo al concetto di sequenza...
ipergrafo è un insieme di sottoinsiemi di elementi di un insieme X = sequenza di sequenze di elementi di X... dove 
l'ordinamento delle sequenze è teoricamente matematicamente superfluo, ma nella pratica è alla fine il concetto 
che permette l'accesso agli elementi...visto dal punto di vista del principio di heisenberg, sebbene esista la 
indeterminazione tra una coppia di variabili canoniche (non dipendenti) comunque ogni sottoinsieme dell'esistente 
ha un luogo ed un tempo ben preciso anche se non precisamente misurabile, anche per oggetti appartenenti allo stesso 
tempo io per accedervi o farvi riferimento, ho bisogno di coordinate, che per l'indeterminazione non posso conoscere 
e quindi usare nella pratica devo (o comunque posso) operare un'astratta mappatura di coordinate, per cui per la 
massima semplicità mappo le coordinate universali (non identificabili) nel più semplice sistema di coordinate...quello 
lineare...quindi se sono riuscito a mappare il concetto di ipergrafo (il più astratto) a sequenze, ho raggiunto il mio 
scopo! ...quindi devo usare solo sequenze!

elemento: porzione spazio-tempo dell'universo. NB qui ritorna l'indeterminazione perchè oltre al utilizzare 
concetti primitivi come "porzione", "sottoinsieme", ecc. porzione -> volume -> insieme di punti -> insieme denso di 
coordinate universali -> sequenza di coordinate universali -> sequenza di punti

ora un problema è che se considero una seq eterogenea che a sua volta può contenere altre sequenze, in teoria sarebbe 
un oggetto molto grosso, io invece devo usare i puntatori per le seq (cioè coordinata lineare consecutiva per gli 
elementi non seq e riferimenti per le seq), cioè internamente due sistemi di coordinate, che devo nascondere. 
poi c'è un altro problema che sarebbe quello che a priori dovrei (in teoria) poter accedere a qualunque tipo di 
oggetto

---

sequence params;
number n = params(0);
num8 n8 = params(1);
sequence* seq = params(2);
potrei fare che op() ritorna una sequence e poi uso "op number()" per fare il cast implicito
se penso sequence come "omogeneussequence<streamable*>" op() ritorna il cast di uno streamable* a 
omogeneussequence<streamable*>

number n << params(0);
potrei fare che seq ritorna void* e ci metto dentro qualunque cosa, poi io che mi sono costruito il tipo X mi creo 
l'operatore <<(X, void*) che mi fa il cast trasparentemente...forse al posto dovrei usare Streamable*, ma poi non ci 
posso mettere gli integral types, oppure per i tipi integral forzo la conversione (reinterpret_cast) a void* e poi al 
tipo richiesto...NB non serve dichiarare "friend" gli op globali dentro seq (la quale non ne sa proprio l'esistenza) 
perchè non devo accedere ai dati interni faccio solo casting...

quindi:
sequence = omogeneussequence<streamable*>
sequence* sequence::operator()(number n);
number& operator<<(number& n, streamable*);

oppure:
sequence = omogeneussequence<streamable*>:sequencestreamable:streamable
omogeneussequence::operator[](int i); // trovare un sostituto all'operatore [] perchè mi impone int
sequence* sequence::operator()(number n);
T* omogeneussequence<T*>::operator()(number n);
numseq = omogeneussequence<number>
number& operator<<(number& n, streamable*);
numseq& operator<<(numseq& n, streamable*);

cioè:
number n = (ns << params(0))[0]; // quasi accettabile

anzi:
numseq ns << params(0);
number n = ns(0);
num8seq n8 << params(1);
string s = (char*) n8.raw();

così facendo le seq di streamable possono accettare puntatori di ogni tipo e posso convertire implicitamente a tutti i 
tipi...

---

problema: risolvere il problema dello streaming di sequenze quando il contenuto non è integral, cioè puntatori ed 
oggetti...posso accettare elementi integral, oggetti sequenze e puntatori a sequenze e ciò mi risolve il problema 
di sapere a priori il tipo di oggetto da leggere (Sequence è una classe Streamable non astratta e non template), ma 
devo ancora saper distinguere fra i tre casi...

forse la cosa migliore è limitarsi a tipi integral e puntatori a sequenze, sia per semplicità di allocazione di memoria 
che per flessibilità, che per evitare problemi di blocchi troppo grandi, ecc. tanto posso wrappare qualche metodo ed 
operatore per gestire come input/output sia i puntatori che gli oggetti (reference ad oggetti) nella de/serializzazione 
invece includo tutto ricorsivamente, sia perchè è più semplice da gestire, sia perchè è più naturale...

problemi: inserire/prendere elementi nelle/dalle sequenze, upcastare una sequence a numseq, num8seq, ecc.
upcast: ho un oggetto sequence e mi serve un operatore/funzione e specificare il tipo a cui upcastare...per far ciò 
mi serve anche un oggetto d'arrivo col tipo richiesto (ad es numseq), ma tutto questo ha un prezzo che consiste 
nell'avere una variabile ed un'assegnazione in più e complica inutilmente le cose, forse è meglio abolire le
sequenceomogeneus<T> ed utilizzare solo le sequence con l'aggiunta di funzioni template per inserire/prendere elementi 
dalla seq già castati così mi risparmio molti passaggi tra cui la definizione di ulteriori tipi (numseq, ecc.) e se 
definisco bene ed in maniera non ambigua le funzioni template, non ho bisogno di specificare il tipo nella chiamata.

inserire:
seqseq params;
const char* text;
const wchar_t* wtext;
params << num8seq(text); // aggiunge una sequenza di caratteri
params << num16seq(wtext);
params << numseq(20); // aggiunge una sequenza di un numero
params << numseq({20, 30, 40}); // aggiunge una sequenza di tre numeri
quindi mi serve un costruttore che prende puntatori ad array e li inserisce nella sequenza (problema: come determino 
la lunghezza da leggere? catcho un'eccezione? null terminator? pensare...)

prendere:
seqseq res;
const char* text = res(0).raw(); // buffer della sequenza alla posizione 0 di res
num16seq wtext = res(1); // sequenza di caratteri unicode usando = definito da seqomo
wstring ws = (const wchar_t*) wtext.raw();
number n = *(number*) res(2)(0); // rischioso perchè op() di sequence mi ritorna il puntatore e poi è troppo casino
number n = (*res(2))(0); // funzione template overloading sul op*...probabilmente non funziona...
number n = res(2) | 0; T operator|(sequence seq, number num)
number n = dynamic_cast<numseq>(res(2))(0); // troppo casino se non aggiungo qualcosa che semplifichi
numseq ns = res(3); // sequenza di numeri usando = definito da seqomo
*((number*) res(3).raw() + i) con il check su width può essere un modo per le funztempl
il discorso è che seqseq ritorna oggetti seq, seq ritorna void*, quindi mi servono template (classi e funzioni) che 
mi permettano a partire da una seq o void* di ottenere oggetti di tipo T.

decisioni:
per inserire uso il template operator<< dentro la classe (non template) sequence il che vuol dire che posso fare: 
sequence seq << n << text; 
rimane poi da definire come si comporta...potrebbe inserire come puntatore (facendo new, store address, copy) 
comportandosi come una vera sequenza eterogenea al prezzo di un doppio consumo di memoria per i numeri ed ininfluente 
per le stringhe, ciò avrebbe senso solo se accompagnato da intelligenti seqomo...ok, allora facciamo così: quando 
ho seq << elem, se elem è un puntatore a seq o derivate, ne prendo il puntatore e memorizzo (copio), se elem è 
qualsiasi altra cosa, costruisco (new) una nuova seqomo, ci metto dentro elem e memorizzo il puntatore in seq. 
gestita intelligentemente seq avrebbe diverse seqomo (seqomo<num8>, seqomo<num16>, seqomo<number>), cioè tante 
seqomo quante sono le stringhe, più una seqomo per tutti i number, più una seomo di seq per tutte le strutture 
complesse (record, matrici, mappe, ecc.). 
per prendere la questione è più delicata perchè potrei definire dei miei integral types (number, num8, numseq, ecc.) e 
memorizzare dentro ogni sequence il tipo contenuto e scrivere esplicitamente operatori overloaded per ogni tipo 
integral e lanciare eccezioni se uso il tipo non corrispondente...altrimenti uso operatori o funzioni template e spero 
che chi li usa lo faccia con cognizione di causa. in ogni caso ho il problema che non posso overloadare sul return type 
per cui probabilmente dovrò usare il sistema di mettere il reference della variabile risultato tra gli argomenti 
del metodo/operatore.
in breve mi serve un sistema sicuro e controllato per prendere oggetti/puntatori/numeri.
se usassi un buffer interno dove serializzo più un buffer di indirizzi, tramite la differenza tra indirizzi contigui 
conosco la dimensione del tipo memorizzato e quindi risalire al integral memorizzato (num8, num16, number, ecc.) e 
dato che nella mia concezione tutto è un numero e il cosa c'è dentro dipende dal contesto che non è affar mio, il tutto 
mi quadra...

params << string1
params << string2
params << new sequence << number1 << number2 << ecc.

cioè con i puntatori a char e wchar creo automaticamente delle sequenze ed aggiungo queste, per i numeri no aggiungo 
i numeri castati a "number"

const char* string1 << params|0
const wchar_t* string2 << params|1
sequence seq << params|2
number1 << seq|0
number2 << seq|1

number1 << params|0|0
number2 << params|0|1

number3 << params|0|0|1|3(2)
string3 << params|0|0|1|3(0) // sempre 0 finale perchè è l'array di caratteri, oppure...
string3 << params|0|0|1|3 // con opportuno overload di << con una sequenza come rvalue e char* come lvalue
number3 << params-0-0-1-3+2 ...meglio di no!

cioè operator|(number) ritorna un reference a sequenze assumendo che la seq di ingresso contenga puntatori a seq, 
operator()(number) ritorna una copia del contenuto...poi rimane il problema dell'operatore template, quindi potrei 
usare un metodo, ad es number3 << params|0|0|1|3.get<number>(2) oppure op() non è template e ritorna un puntatore 
a num8* e << viene overloadato per ogni integral type prendendo il num8* lo traduce in number (no puntatore) e lo 
casta al tipo richiesto

string1 << seq1 | i;
non va bene per via della precedenza degli operatori quindi devo trovare un'alternativa per cui al posto di | ho un 
operatore con alta priorità ed al posto di << ho un operatore con bassa priorità, non è = perchè deve essere membro, 
non può essere <<= o simili perchè implicano l'assegnazione su oggetti già esistenti...cioè...
char* string1 <<= seq1 | 1; <=> string1 = string1 << seq1 | 1;
cioè sarebbe ricorsivo...

faccio che le seq con width  negativo, hanno width pari al maggiore tra il sizeof double e il sizeof void* così ho 
ottenuto le seq eterogenee perchè possono contenere sia puntatori ad altre seq, che numeri...se invece ho bisogno di 
dimensioni esatte (come per le stringhe) fisso il width, cioè se non specifico, sono eterogenee...

nel designer delle iface sarebbe bene fornire uno strumento nel quale definisci una struttura dati e lui ti fornisce 
il sample code per riempirla e per prenderla assegnando a variabili elementari...giusto per sopperire all'eliminazione 
del compile time type safe...che in ogni caso è il prezzo accettabile da pagare per ottenere un rpc/rmi universale e 
strutture dati dinamiche...è l'analogo degli xml o degli alberi dove la struttura dati non è definita a compile time...

definizione iface basilari:
StorageMemory: memoria lineare...tipo file, ram, ecc. NB il hd non è lineare, per cui un srv HDStorageMemory lo nasconde
StorageFileSystem: basato su StorageMemory, offre un basilare supporto ai "file"
Encryption: pensare una iface basata su input/output generici che vada bene per ogni tipo di storage, stream, ecc.
Storage: basato sui suddetti, offre "user access control", tab, alberi, grafi, ecc. strutture dati di altissimo livello
Log: basato su Storage e non su StorageFileSystem o StorageMemory perchè i log devono poter essere altamente strutturati
Configuration: basato su Storage e non su StorageFileSystem o StorageMemory
BootSequence: basato sui precedenti?
UserInput: basato sui driver di periferiche, offre segnali di alto livello discreti, fuzzy, multidimensionali, ecc.
UserInterface: basato su UserInterface e driver di periferiche offre generiche funzionalità per creare "applicazioni"
SecurityManager: basato su Configuration mappa le azioni o i parametri che gli utenti, srv, iface possono fare...

Log: data-ora (timestamp), luogo (classe, metodo, pc, os, città, ecc.), oggetti (nomi e valori delle variabili), tipo di 
informazione loggata (loglevel), azione e parametri, chi (user, system, service, ecc.), status (del contesto in cui il 
log esiste e non più ampio perchè eventualmente quelle info se servono si ottengono dal merging nel contesto di una 
log analisys) NB per "time" deve essere creato uno standard universale astratto (cfr discorso sul linguaggio...)...
la log analisys la si ottiene dalle feature avanzate di Storage o al limite da un iface "ReportAnalisys"...la cosa 
importante è che venga definito un standard universale di memorizzazione dei log in Storage...NB Log scrive soltanto!!!

Configuration: similarmente a Log, è un'interfaccia ad uno standard di memorizzazione dati in Storage, più delle 
classificazioni concettuali...config ha un nometipo univoco ed una versione che identificano la sua struttura 
immodificabile nel tempo (cioè se aggiungo o rimuovo o rinomino un campo, DEVO cambiare almeno versione). ogni config 
può avere diverse sottoconfig ad es fsconfig_v1=<fsc_v1, fsprefs_v2>, storageconfig_v1=<fsprefs_v2, userprofile_v1> 
cioè posso comporre sezioni di conf diverse per ottenere una nuova conf, oppure semplicemente per avere il profili, 
cioè imposto una sezione base con info relative al pc, e poi una sezione preferenze, così di volta in volta carico 
il profilo che l'utente desidera senza replicare le info comuni (cosa che potrebbe creare casino), altro vantaggio è 
che se il sistema di sicurezza lo consente, posso ottenere che le mie preferenze di una app si riflettono su ogni 
altra app collegata, cioè massima flessibilità...

come procedere:
- skippo StorageMemory
- definisco StorageFileSystem
- implemento un StorageFileSystem che wrappa sul file system locale mappando una sottodirectory
- veloce ragionamento su Encryption e definizione
- definizione Log
- definizione Storage (lavoro impegnativo!!!)
- implementazione semplice di Storage basato sul file system locale (lavoro lungo!!!) ed eventualmente sqlite
- implementazione di Log
- definizione di Configuration
- impementazione di Configuration
- definizione di UserInput
- definizione di UserInterface
- implementazione UserInput
- implementazione UserInterface (GUI)

NB IMPORTANTE!!! attualmente ogni metodo di ogni iface può ritornare solo oggetti Sequence, il che implica un framework 
di tipo C (con handle ecc.) nel contesto C++ cioè i metodi mi danno degli handle/id/ecc. tramite i quali mi riferisco 
a degli "oggetti" concettuali...in futuro si potrà ritornare degli oggetti ma solo quelli appartenenti ad una delle 
iface già definite dove i wrapper si occupano di creare degli opportuni wrapper degli oggetti ritornati...attenzione 
però!!! così l'architettura introduce notevoli e subdole complicazioni...deve essere pensata molto attentamente...anzi 
deve essere deciso se si vuole veramente andare in questa direzione...

NB modifica: nelle funzioni delle dll dei srv far si che la funzione "create" accetti anche un oggetto Sequence oltre 
che il puntatore a Loader, così posso passare dei parametri pure al costruttore dei srv...pensare se è possibile 
farlo! se non è possibile, vedere se si può introdurre un metodo init per tutti i srv che viene chiamato invisibilmente 
da tutti i vari loader...

dipendenze:
hw-bootsequence -> il bios gli dice da dove prendere il kernel da caricare in memoria ed eseguire (kernel è il loader)
kernel-bootsequence -> avvia storage sullo stesso device da quale il bios ha caricato il kernel
                    -> prende da storage il srv configuration, lo carica in memoria e lo esegue
                    -> prende da storage il srv securitymanager, lo carica in memoria e lo esegue
                       (securitymanager richiede ed usa configuration)
                    -> prende da storage il srv bootsequence, lo carica in memoria e lo esegue
NB il nome dei srv di storage, securitymanager, configuration e bootsequence sono hardcoded nel kernel e sono random 
e sono scelti/calcolati in fase di installazione come contromisura per i virus/cracker
bootsequence -> avvia un hardcoded configuration ed in base a questa decide se, cosa, in che ordine avviare e termina

NB la precedente sequenza di avvio funziona solo se storage non dipende da configuration, cioè storage deve poter 
essere operativo almeno a livello base anche senza config, poi magari attiva la modalità full che carica config, 
altrimenti bisogna far precedere storage da basicstorage e basicconfiguration e quindi storage dipende da 
basicconfiguration che non è il massimo...

quindi:
hwboot
kernelboot
  basicstorage
    bootsequence
      basicconfiguration
      storage
      configuration
      (start securitymanager and set secureloader as default)
=> quindi:
-hwboot
--kernelboot -> instantiate basicloader: last srv instantiated per each iface, become the defaul fot such iface...
---storagememory (ram) -> il kernel viene mappato in memoria con codice e dati, storage memory mappa la parte dati
---basicconfiguration (storagememory) -> "sequence"...c'è solo la config di storage...
---basicbootsequence
----storage (basicconfiguration) -> loader uses this srv as default
----configuration (storage) -> loader uses this srv as default
----bootsequence (configuration)

NB in storage è presente il sistema con i dati, le iface, i srv, ecc.
(storage > configuration > securitymanager > bootsequence > tutto)

StorageFileSystem:
- setstoragememory -> nome del particolare srv che implementa l'iface storagememory sul quale sfs va a gestire i file 
che sono a loro volta dei storagememory...NB nel caso che il particolare sfs faccia solo da wrapper verso il fs 
sottostante, questo metodo non fa nulla...anzi ritorna sempre errore (non eccezioni)
- filecreate
- filedelete
- filerename
- getfile -> ritorna un oggetto file/stream...il problema è che non può essere offerto con l'attuale architettura...
oppure inserisco qui le funzioni sul singolo file in stile c con gli handle...
- fileopen -> secondo me open/close vanno tolte perchè è roba da medioevo...al max serve una getid per avere l'handle...
- fileclose -> come sopra
- fileid -> ritorna la seq file a partire dal nome...
- filesize
- filesetposition -> no! la posizione DEVE essere fornita a read/write dal chiamante sempre ed è lui che ne deve 
tenere traccia...
- fileread
- filewrite
- listfiles
- openedfiles -> ritorna sia gli handle che i nomi
- closeall
NB anche se non è una soluzione pulitissima, io posso strutturare bene una seq params che vada bene per tutti i 
metodi sopra e che quindi è quasi come un oggetto file...
tutto ciò in realtà ha anche un senso visto che il device sul quale c'è il fs è lo stesso, quindi sia i primi tre 
metodi che gli altri operano sullo stesso hw, avere due oggetti non collegati implicherebbe problemi di 
sincronizzazione...

Storage:
consente di memorizzare qualunque tipo di struttura dati (record, file, tabelle, alberi, mappe, grafi, sequenze, ecc.) 
(che abbiamo stabilito derivare tutte da "sequence"), modificarle, crearle, cancellarle, interrogarle, importarle, 
esportarle...
ho due strade...o definire a priori le cose suddette nel tentativo di ottimizzare al massimo le performance, oppure 
permettere di definire dei nuovi tipi in base a composizioni di sequence e vincoli su di esse (cfr riflessioni a 
proposito)... la seconda strada mi piace molto di più e la mia prima impressione è che potrebbe avere comunque delle 
performance al top, ma è tutto da verificare...in ogni caso moltissimo dipende da come memorizzo le sequence in base 
ai vincoli di composizione...
- setstoragememory -> nome del srv che implementa l'iface storagememory sul quale storage va a gestire i dati
- createtype -> metodo semplice che opera su sequence e vincoli (va usato più volte per tipi complessi)
- deletetype -> controlla che i tipi non siano in uso o abbiano dipendenze
- modifytype -> controlla che i tipi non siano in uso o abbiano dipendenze
- copytype
- listtypes -> può essere inclusa in searchtypes
- searchtypes
- create -> crea un oggetto di un determinato tipo
- insert -> aggiunge un elemento di un certo tipo all'interno di una struttura
- get
- set
- delete
- modify
- copy
- search
il punto cruciale è definire un generico algoritmo di ricerca/parsing, cioè come navigare nei path, cioè devo 
specificare cosa fare ad ogni seq, es tabelle: ho una seq (tab) di seq di numeri (cols), il mio search devo specificare 
una seq di index che indica quali colonne prendere (se null le prendo tutte), poi per ogni index (col) specificato, 
do un insieme di criteri sul contenuto della seq-colonna...
in pratica: i criteri di search, si riconducono ad un agglomerato di seq-criteria, dove si distingue in base al 
contenuto che ci si aspetta, ovvero i criteri su oggetti possono essere gli indici da prendere, oppure il risultato 
di una delle relazioni definite su number o sequence. 
altra cosa importante è che in base al search, io individuo un sub-oggetto/sotto-grafo/ecc. ed una sottostruttura, 
quindi io DEVO POTER modificare un sub-oggetto oppure specificare una sottostruttura che riempio e poi dico a 
storage di sovrascriverla alla sottostruttura dell'oggetto specificato. siccome ho progettato BENE le sequenze (cioè 
realmente sequenziali), un sub-oggetto potrebbe essere rappresentato semplicemente dagli indici/sub-indici una volta 
che l'algoritmo di search ha individuato la sottostruttura corrispodente ai criteri (NB i criteri/relazioni potrebbero 
essere anche degli algoritmi molto complessi e quindi...lenti!). 
quindi tutto il problema delle performance risiede negli algoritmi relazionali su number/seq che potrebbero essere 
velocizzati con delle strutture aggiuntive di supporto che vengono calcolate una-tantum (all'inserimento, modifica, 
ecc.) e quindi si arriva anche alla crucialità del metodo di memorizzazione delle strutture dati...questi discorsi 
mi sembrano ulteriori indizi nel proseguire nella strada generica...
Nota: probabilmente una buona strategia di memorizzazione potrebbe essere che ogni sequenza la spacchetto in linked 
files, così quando apporto modifiche non devo riscrivere file molto grandi (file molto grande = colonna con 
tantissimi elementi)
il servizio storage prevede anche la gestione di seq in memoria sia localizzate (la copia originale) nel srv storage 
che nel srv utilizzatore (a richiesta)...e deve essere possibile spostare la localizzazione a run-time...tutto ciò 
fa si che l'utilizzo delle seq nella core-library rientrino in un contesto più generale dove le seq e lo storage 
sono strettamente legate l'uno all'altro...d'altronde le seq in core utilizzano la ram come storage ma senza le 
funzionalità dell'iface storage...vuol dire che anche le seq in ram hanno una classe di id e possono essere cercate 
ed il fatto di essere in ram (volatili) o su disco (persistenti) è solo un attributo scelto dal creatore/utilizzatore 

ora veniamo al come implementare la prima e più semplice versione cercando di garantire che i classici file possano 
essere memorizzati come se stessi (a meno che io non voglia spacchettare gli stream come nel caso dei video...). 
nella soluzione finale dovrò sicuramente (forse) avere una storagememory basata su un device hw o similare ed al di 
sopra uno storagefilesystem (devo cambiare questi nomi) e sopra questo storage, ma ora implemento storage direttamente 
sul filesystem locale fornito dal sistema operativo...
nuovi nomi:
StorageSequence (storagememory) -> mappa una memoria lineare (ram, hd, file) in una sequenza e viceversa (iface molto 
  simile a sequence)
StorageSequenceSpace (storagefilesystem) -> mappa/memorizza diverse sequenze in uno StorageSequence, può farlo 
  automaticamente oppure può essere specificata la posizione...può essere importante...i nomi delle seq sono 
  degli id di tipo number, se voglio nomi, attributi, permissions, ecc. devo implementarlo con una iface derivata 
  che memorizzi queste info in seq apposite, per i miei propositi sono superflue, ma in generale è giusto così per 
  separare le funzionalità ed una maggiore flessibilità

rivediamo quindi l'iface di...
Storage:
storagesequencespace -> imposta e/o ritorna lo stoseqspc sul quale opera...NB è sss ad impostare storagesequence, 
  quindi se voglio cambiare device, devo chiedere al loader o chi per lui l'istanza di sss che sta usando il mio 
  storage e poi a quell'istanza gli dico quale storagesequence utilizzare...magari ci metto un metodo per semplicità...
storagesequence -> fa quello detto sopra...
create -> crea una struttura specificando i vincoli (di struttura e/o di contenuto) su di essa, in pratica crea due 
  strutture, una è la struttura dati e l'altra contiene i vincoli/criteri...poi se queste vengono messe insieme in una 
  seq di sue elementi, o se le seq dati le metto tutte da una parte e quelle vincoli da un altra, dipende 
  dall'implementazione, l'importante è che esista un collegamento che associ ad ogni struttura dati, la propria 
  struttura vincoli. questi vincoli sono controllati in fase di "set" ed "ins". NB una stessa struct vincoli può 
  essere utilizzata da più struct dati...
modify -> modifica la struttura vincoli SE possibile E rende consistente la struttura dati con i nuovi vincoli 
get -> ritorna una substruct a partire da una struct dati ed una struc vincoli/criteri di ricerca (NB in genere è 
  una struct con criteri più restrittivi dei vincoli associati alla struct dati all'atto della creazione). 
  NB come per i db i la ricerca ed i criteri possono fare riferimento a molte struct dati, cioè il campo non è 
  ristretto ad una struct, posso fare join, mix, union ecc. tutto e di più!!!
set -> a partire da una struct dati ed una vincoli che ne individui una substruct, rimpiazza i valori...in pratica 
  copia i valori di una struct in una struct/substruct (anche frutto di get) controllando i criteri di quest'ultima
ins -> simile a set, ma non individua una substruct, ma una "posizione" nel quale mettere i dati previo rispetto 
  della struttura e dei vincoli, spostando gli altri elementi...se la pos non è specificata, fa un add...
del -> cancella una struttura frutto di get (NB per cancellare una struct dati ED anche i vincoli, devo fare due del 
  a meno che non facciano parte di una stessa rootseq, ma come abbiamo detto questo dipende dall'implementazione...)

NB in realtà potrei astrarre ulteriormente la faccenda dei vincoli, ma potrebbe essere molto lungo e complicato o 
potrei perdere in sicurezza dei dati...rimandiamo il discorso ad una eventuale vers 2 della iface...

NB come criteri/vincoli devo supportare almeno le rel base <>=, più tutti i criteri supportati dai vari database per 
le ricerche, più quelle eventuali della teoria dei grafi, più le regular expressions...questa è tosta, ma va fatta! 
inoltre devo trovare unificante, potente e veloce (nel senso che è direttamente interpretabile dall'implementazione 
di storage e non come sql/regexp/xml/ecc. che mi obbligano a fare il parsing di testo...il mio equivalente sarà 
ovviamente un agglomerato di sequenze che poi posso rappresentare come testo, ma è solo una facility di 
import/export delle ricerche...)

StorageOSFS:
è il srv che implementa l'iface Storage basandosi sul file system fornito dal sistema operativo su cui gira. 
tenendo presente che il sss sottostante tiene l'elenco di tutte le seq memorizzate io devo definire una regola sugli 
id (nomi) per distinguere le seq di sistema da quelle user-created -> da 1 a 1.000.000 sono di sistema (mi sono tenuto 
basso perchè questa è un'implementazione che verrà superata da quella basata su sss e ss che a sua volta verrà 
migliorata col tempo ecc. per cui qui non vado troppo per il sottile...0 è not-used (potrebbe essere un utile valore 
di test per gli errori) da 1.000.001 a 2.000.000 sono per le struct vincoli, da 2.000.001 in poi sono per le struct 
dati. la seq 100 contiene gli id delle seq-struct-rules, la seq 200 contiene gli id delle seq-struct-data, la 
seq 300 (di lunghezza sempre pari alla 200) contiene gli id dei vincoli associati alle seq dati (anche qui vincoli?). 
le seq data potrebbero essere create senza vincoli associati (pericolose!!! potrebbero crescere a dismisura o creare 
casini!!!), però facciamo che se non viene specificato alcun vincolo, viene impostata una seq-struct-rules di default 
con id 1.000.001...ora emerge il problema delle seq eterogenee...tanto per cominciare esiste anche nelle seq 
implementate nella core library perchè teoricamente posso inserire un numero che casualmente coincide con il 
puntatore di una qualche sequenza...insomma il problema è come distinguere tra number e link a seq...in ogni caso il 
problema lo risolvo al momento solo qui in storage e poi con l'esperienza lo risolvo anche in core che comunque 
dovevo reimplementare perchè non mi piaceva la soluzione adottata...
consideriamo ad esempio che io voglia creare una tab con una lista di file ed associati dei flag booleani, allora 
faccio una seq di due seq (vincolo) di uguale lunghezza (vincolo) di cui la prima accetta solo 0/1 (vincolo) e la 
seconda accetta solo link (id) a sequenze esistenti...quindi devo poter esprimere i seguenti vincoli...

numero di elementi (esatto, range, set di possibili valori)
tipo di elementi (number/seq-id)
valori elementi (range/set/etc.)

NB ciascun vincolo può essere un valore predeterminato, ma può anche essere il risultato di una get (search)!!!

NB potrei anche fregarmene del tipo di elementi perchè in fondo i seq-id sono dei number...poi sono io che li 
interpreto come tali!!! il punto cruciale è che poi non avrei delle relazioni esplicite e quindi nessuna garanzia che 
gli id siano validi...insomma è la stessa differenza tra un db relazionale ed uno no...devo riflettere bene, anche 
se sono abbastanza convinto di imporre le relazioni...
allora se io prendo da storage posso scegliere se voglio gli id in chiaro oppure che le seq vengano mappate 
trasparentemente (modo naturale di procedere), ma se io faccio un set come faccio a specificare se una sub-seq deve 
sovrascrivere quella già esistente (se si è richiesto che mantenga lo stesso id?) o se ne creo una nuova e rimpiazzo 
solo l'id? diciamo che per il momento sono per il sovrascrivere perchè i link/id sono degli artifici implementativi 
in realtà, concettualmente parlando, una sub-seq sta dentro la struttura, poi il fatto che un stessa sub-seq possa 
essere condivisa da più struct, è un problema a parte e porta il discorso ai loop, ricorsioni, ecc. dei grafi oltre 
al discorso delle relazioni e relazioni inverse (se cancello una seq devo poter sapere dove è stata referenziata se 
voglio poter adottare contromisure, altrimenti mi ritrovo id relativi a seq non esistenti o peggio relativi a nuove 
seq che non hanno niente a che vedere con quelle cancellate e referenziate...)

come implementare ins...
pensando ad una tabella è come se io dessi una replica di una struct con solo alcuni elem (con valori diversi) 
i quali vanno ad inserirsi opportunamente...ins è molto complicato, meglio pensare prima a set...

come implementare set...
devo specificare una get che mi ritorna una substruct S e poi fornisco una struct O, le strutture devono essere 
identiche rispetto alle lunghezze, tipo del contenuto ed alla struttura in generale...ora basta un algoritmo 
di navigazione esaustiva e faccio il replace uno ad uno...il che mi rimanda a...

come implementare get...
a partire dalla seq radice, posso specificare un vincolo, questo mi ritorna una seq ridotta con possibili link ad altre 
subseq sulle quali applicare altri vincoli...la vera domanda è questa...devo sapere a priori come è fatta la seq 
ridotta per poter specificare ed applicare vincoli alle subseq, oppure posso limitarmi a specificare delle regole? 
sicuramente la seconda ipotesi mi può essere utilissima quando si arriva alle "foglie" o giù di lì, ma è molto 
complicato per cui per il momento mi limito al fatto che nelle ricerche per poter applicare dei sottovincoli 
devo necessariamente specificare con esattezza la seq ridotta che mi deve arrivare dal vincolo precedente...



piccolo riepilogo:

set è il più semplice di tutti, prende due struct uguali e sovrascrive una dentro l'altra, dopodichè salva 
quest'ultima che in realtà era un raggruppamento di link ad elementi di determinati file...

get parte da una struct vincoli/filtri ed una struct dati, applica a quest'ultima i filtri e ritorna dei 
link/puntatori ad elementi...da ciò si deduce che serve una classe analoga (forse derivata) a sequence, ma che 
internamente ha dei riferimenti/puntatori al file che la contiene...in pratica due passi, uno mappare una seq in un 
file distinguendo tra numeri e link ad altre sequenze/file, due una perfetta sincornizzazione e thread-safety 
magari mediante eventi, mutex, lock, transactions, ecc. insomma meccanismo di mappatura in real-time almeno per il 
read dei dati, eventualmente flush+trasactions per il write...forse basta un singleton per ogni file che supporti 
il lock/mutex in scrittura ed il flush su file è gestito internamente analogamente al journaling dei file systems 
cioè in pratica in base al compromesso safety/performances posso scrivere subito il file ( quello che farò nella 
prima implementazione) ad ogni scrittura nella classe, oppure ogni tot elementi cambiati e/o ogni tot secondi/minuti 
o secondo altri criteri...comunque bisogna tener conto che tutte le suddette modalità prevedono degli eventi, 
quindi conviene tenere presente che in futuro dovrò supportare gli eventi...
NB quanto detto sopra è pari pari quello che deve/dovrà fare l'iface StorageSequence, quindi è meglio che non uso 
gli stessi nomi per evitare problemi di compilazione, comunque mi ritroverò il grosso dell'implementazione...
ANZI NO!!! è fondamentalmente diverso, perchè StorageSequence fa rifarimento ad un device a se stante e la mappatura 
è riferita ad una sola seq...no link ad altre seq sullo stesso device!!! NB anche StorageSequenceSpace non 
prevede link tra seq, la relazione di linking tra seq è una peculiarità stretta di Storage e basta!!! per cui 
le classi che devo definire sono diverse...
mi serve una classe con interfaccia uguale a sequence più dei metodi per gestire la sincronizzazione con lo storage 
fisico, oppure posso inserire dentro un policy manager e poi di volta in volta specifico quale policy bisogna 
adottare...
la prima domanda è se posso trovare un modo semplice per rendere Sequence sufficientemente virtuale da permettermi di 
derivare la classe di cui sopra da seq...ma lo rimando, per ora la copio e basta...
NB una cosa importante, magari non immediatamente ma quasi, è la possibilità per le subseq di essere "inline" ovvero 
memorizzate insieme alla seq parent questo per evitare che le stringhe vengano memorizzate come file a parte...
ovviamente deve essere opzionale e consentito solo alle seq foglie? ...se lo imposto a delle subseq non foglie la 
cosa non si propaga automaticamente su tutte le seq child (ma devo prevedere un metodo per la propagazione ricorsiva). 

ins rimane il più complicato, pensare dopo...

Nota: espandere il Loader mettendo un metodo template che fa il dynamic_cast automaticamente...

Nota: implementare il lock in SequencePersistent in put e write (cioè non puoi inserire mentre scrive...) o forse 
devo implementare delle SequenceLockable in core...

ragionamenti per arrivare ai search...
per fare riferimento ad un elemento (numero) io scrivo così -> seq(2)(3)[4], questa espressione vuol dire che ho 
una sequenza seq a cui applico ricorsivamente gli indici 2,3,4...in pratica l'array {2,3,4} rappresenta le coordinate 
dell'elemento in seq, quindi per accedere ad ogni elem basta una sequenza di coordinate!!! ...per accedere 
a n elementi, mi serviranno quindi una sequenza di n subsequenze...potrei ottimizzare quensto discorso potrei 
vederlo "per righe" (approfondisco il livello per ogni elem contemporaneamente) anzichè "per colonne" (arrivo ad un 
elem per volta), ma fondamentalmente ci siamo per il caso più semplice, quindi devo trovare un metodo per mappare 
questo ragionamento in un algoritmo che mi ritorni una seq di puntatori ad elem...NB questo dettaglio è importante!!! 
perchè non solo devo avere una seq ridotta, ma le modifiche su questa DEVONO riversarsi in real-time sulla seq di 
partenza!!!
supponendo di fare un search che su una seq dice di prendere gli indici da 2 a 9, la seq risultante...è e deve essere 
una seq...ciò vuol dire che i criteri mi servono solo in fase di generazione della seq, ma il risultato è una "seq" 
la differenza sta nel fatto che le seq frutto di search apparentemente sono uguali all'origine (come se avessero 
tutti gli elementi), ma nella pratica hanno solo gli elem richiesti...per far ciò ho bisogno di una diversa classe 
derivata da sequence dove anzichè un solo buffer con i dati, ho due buffer uno con gli indici originali, uno con i 
puntatori agli oggetti nella seq di origine...ciò mi permette tre cose uno di accedervi tramite gli indici originali 
(anche se è molto più lento perchè faccio usa di una mappa e quindi l'indice è in realtà una chiave da cercare alla 
quale è associato un indice nel secondo buffer => triplo passaggio) due di accedere con i nuovi indici e tre di 
modificare direttamente l'origine...NB questa classe però mi deve fornire anche due possibilità uno di avere un 
oggetto copia (cioè ho ancora la possibilità di accedere con gli indici originali, ma le modifiche non si riflettono 
sull'originale) e due di esportare in una seq classica (cioè perdo ogni collegamento con l'origine)...
stabilito ciò...il get è immediato, il set diventa una semplice facility che effettua cicli e ricorsioni per copiare 
tutti i dati previa verifica della congruenza tra le due strutture...rimangono ins e del che sono i più complicati...
ins di un "record" fornisco una seq di seq-coordinates più una seq di elementi (le due seq devono essere lunghe 
uguali), ins di più "record" semplicemente la seconda seq diventa una seq di seq-record...
del ha la seq di coordinate più una seq di numeri che indicano quanti elem eliminare...

Nota: modificare sequence aggiungendo i metodi ins e del, facendo si che alla fine abbia get, set, ins, del, add...
creare una classe sequenceiterator o simile che contenga il riferimento (o puntatore) ad una sequence ed un indice 
valido per questa, più una serie di overload di >> sui vari integral types di modo che sia possibile fare così...
seq >> string1 >> pchararray1 >> integer1 >> float2 >> ecc. dove [sequence >> integral] ritorna seqiter& con i=0 e 
dove [seqiter >> integral] ritorna seqiter& con i=i+1...
l'unico problema potrebbe essere la thread safety perchè tra un'istruzione e l'altra un altro thread potrebbe aver 
aggiunto/modificato/rimosso un elem, ma tale problema esiste anche per << ...quindi potrei rendere sequence lockable 
dove i metodi lock/unlock ritornano il rif alla seq così posso scrivere così...
(seq.lock >> string1 >> integer1).unlock ... (seq.lock << string1 << integer1).unlock o magari se definisco 
opportunamente un operatore potrei scrivere così... seq.lock << string1 << integer1 & seq.unlock; ...no, è ridicolo 
perchè è sufficiente scrivere così... seq.lock << string1 << integer1; seq.unlock;
inoltre elimino il trylock sostituendolo da un opportuno overload di lock che deve permettere di attendere 
indefinitamente, attendere fino ad un timeout, adottare un comportamento correntemente definito come default, inoltre 
serve anche un metodo per specificare la modalità di default...
rendere seq equivalente a storage, nel senso che fa i search e genera ogni tipo di struttura...così alla fine storage 
diventa un wrapper di seq più un sistema di memorizzazione su un device (virtuale o fisico)...mi sembra la cosa 
migliore, così rendo seq molto potenti l'unico problema potrebbe esserci per le strutture enormi (più della ram) 
quindi faccio così: seq offrono tutte le funzionalità di storage ma l'implementazione è ottimizzata per il runtime e 
con le seq tutte in mem, più il supporto alle seq generate da search e che mantengono i rif agli indici originali 
(quelle con gli indici ricalcolati sono seq normali), il senso è che io in una app uso solo una parte di tabelle 
anche enormi e nel db ci sono tutti i record...analogamente con storage, solo che nel mio caso avere la stessa 
interfaccia per storage e sequence è un'importante astrazione oltre al fatto che seq comunque non possono essere 
solo dei banali vector...altra differenza è che sequence ha tutto interno, mentre storagea seconda delle policy e/o 
della particolare config di una particolare seq, può memorizzare tutto insieme (stesso file, ecc.) o separare parti 
e collegarle tramite id (come le relazioni nei db)...
aggiungere il supporto ai flag per tracciare gli elementi modificati e l'eventuale supporto al de/serialize parziale...
operazioni elementari sulle seq...concatenate, compare ==, substring, contains/find->NO, replace->NO...le ultime due 
sono riconducibili ai metodi get/set di storage...
operazioni elementari sui vettori, matrici, ecc. somma, prodotto scalare, prodotto vettoriale, gradiente, divergenza, 
prodotto, somma, ecc. di uno scalare, norma

Nota: idea per la dynamic-lifetime/scope degli oggetti...ho un singleton che mi crea gli oggetti ritornandomi sia 
un puntatore che un reference (a scelta) ritornandomi come intermediario un altro oggetto inizializzato col puntatore 
che una volta uscito dallo scope farà o no il delete di quell'oggetto a seconda di quale metodo ho usato per crearlo...
così ho il vantaggio di usare reference e non puntatori, ma se mi fermo qui non ho vantaggi rispetto ai banali 
new e delete, però se ragiono meglio magari posso trovare dei meccanismi per decidere a quanti livelli di upscope 
posso far sopravvivere l'oggetto...in realtà tutta questa faccenda non mi piace, ma in taluni casi forse potrebbe 
tornarmi utile...

vincoli, constraint, rules, filter, criteria:
numero di elementi (esatto, range, set di possibili valori) -> lunghezza, size, width
indici
tipo di elementi (number/seq-id) -> number, seq
valori elementi (range/set/etc.) -> boolean operations on number (other operands as parameters)

riepilogando (criteria):
criteria sulla sequenza (prendo o no tutta la seq in blocco) -> size, width, result of a search inside the seq
criteria sugli elementi (prendo o no uno specifico elemento) -> type (number, seq), index criteria, value criteria

quindi value-criteria (index, value, seq-size, seq-width), type-criteria (number, seq), search-result-criteria
quindi number-value-criteria (index, value, seq-size, seq-width, search-result), boolean-value-criteria (elem-type) 
quindi tutto è riconducibile a number-value-criteria (esatto, range (combinations of <,=,>), set) con valori 
forniti da metodi che ritornano: index, value, seq-size, seq-width, elem-type, search e che operano su una seq o su 
un elem e che hanno un numero non specificato di parametri...

number-value-criteria -> criteria = match + source
match = number (exact), set (possible values), set of intervals (seq of 2-elem-seq) 
-> number è un caso particolare di set, set è un caso particolare di set-intervals...pensare se e quali unificare... 
source = funzione applicata ad uno specifico elemento (di indice "i") di uno specifico tipo -> index(i), value(i), 
type(i), size(i), width(i), search(i, criteria)...ognuna di queste si applica ad un solo tipo (number o seq), se il 
tipo fornito è sbagliato, cosa devo fare ritornare "false" o lanciare un'eccezione? per il momento decido "false"... 

risistemiamo:
criteria = match + source
match = number (exact), set (possible values), set of intervals (seq of 2-elem-seq) 
source = func(number) -> value... func(seq) -> size, width, search... func(number/seq) -> type, index
source = all<type, index> number<value> sequence<size, width>
ora il problema è che tutte le funzioni ritornano un number eccetto search che in realtà non c'entra niente perchè 
anzichè indicarlo qui lo indico nella catena dei search sulla singola seq...cioè quell descritto sopra è un semplice 
criteria-search su una seq, ovvero il controllo sugli elem della seq...il seq-criteria è una composizione di 
elem-criteria...quindi composizione-elem-criteria -> single-seq-criteria, composizione-single-seq-criteria -> 
complex-seq-criteria...

tutto parte da una search su una seq, quindi la prima ed unica cosa che posso fare è l'applicazione di uno 
comp-single-seq-criteria, se questo è true, si passa alla comp-elem-criteria sugli elem di quella seq, se anche 
questo è true, si passa ricorsivamente a dei criteria sulle subseq, questa ricorsione può essere molto complessa se 
non prevedo una struttura fissa perchè posso avere dei criteria condizionali, opzionali, ricorrenti, ecc. (discorso 
da approfondire più avanti) la seq risultato del search è quella composta da tutti gli elem/subseq sui quali i 
criteria hanno avuto risultato "true" mantenendo la struttura originaria con il troncamento di qualche ramo...
NB quando una subseq è false, tutto quanto sta sotto viene rimosso e se ci stanno loop su nodi che già abbiamo 
considerato, vuol dire che prendo parte di un loop che non sarà più tale...
NB mi serve pure un criteria sul numero di ricorsioni/rami/ecc. che sto facendo...

quindi mi rimane da stabilire come fare le composizioni sugli elem-criteria (type, index, value), come fare le 
composizioni sulle seq-criteria (size, width) e come scendere nella ricorsione (è implicito nella composizione dei 
criteria)...posso comporre con gli operatori logici (not, and, or, xor)

riepilogando:
seq-criteria (size intervals, width intervals), index intervals, number -> value(i), subseq -> recursion...
rimane da stabilire come gestire il match sui valori e la ricorsione in maniera dinamica, per il momento stabilisco 
che la struttura è fissa e nota a priori...

criteria:
- width intervals
- size intervals
- index intervals
- value criteria -> seq of pairs <index-intervals, value-intervals>
- recursion criteria -> seq of pairs <index-intervals, criteria>

NB oltre al metodo "get" che opera un filtro, mi serve un metodo "check" che ritorna un boolean che verifichi il 
rispetto di tutti i criteri sulla seq...indispensabile nelle ins quando voglio stabilire delle strutture dati 
integre (cioè struttura che decido a priori nella sua rigidità/flessibilità con valori controllati)

rimane da stabilire come sono fatte le seq "intervals":
sono seq di seq di due elementi (a, b) per cui a<=x<=b...come definire gli estremi +/- infinito? o un solo estremo? 
facciamo come seq di seq di quattro elementi (a, au, b, bu) dove au e bu assumono tre valori (-1, 0, 1) che indicano 
non considerato (infinito), estremo non compreso (solo < e >) estremo compreso (<= e >=)...forse è meglio la prima 
definizione con solo gli estremi, poi il infinito e l'estremo escluso, li posso simulare con dei valori appositi 
(MAX_VALUE, MIN_VALUE, a+MIN_DECIMAL, b-MIN_DECIMAL)...comunque devo rifletterci su...

quindi mi serve una func o metodo per il check di un valore in una seq-intervals e due func o metodi per fare il for 
negli index-intervals sia per il value-check che per la recursion...

NB criteria è composta di seq-intervals...sia per criteria che per ogni isolata seq-intervals devo fare il cotrollo di 
struttura...

NB ripensare i criteria in modo da permettere tutte le ricerche/query possibili con i db vedi ricerche LIKE e 
wildcards sulle stringhe (pattern comparison), clausola IN (cerca sequenza o parte in un ramo o set di seq), 
permettere che i "value" non siano statici ma possano provenire da altre search...quindi...
value: risultato di search
value-criteria: sia per righe che per colonne, ovvero elem by elem (per colonne) oppure pattern matching su tutta la 
seq (per righe)...tutto è riconducibile al pattern matching...

pattern matching:
sequenza di matches -> single value (exact, intervals, set), spacing (none, intervals, set), ecc.

criteria:
- width intervals (only check by design, reduction of width must occur by mean of a conversion algorithm)
- size intervals (only check by design, reduction of size must occur via filtering)
- pattern matching (anche index-intervals incluso qui dentro, quindi sia pattern match stretto che index filtering)
- recursion criteria

pattern matching (trovare altro nome) vuol dire che da una seq opero una specie di regex cioè verifico sia il 
rispetto di determinati pattern (anche il pattern della presenza di subseq), sia il filtro sugli elem...in pratica 
faccio filter+match contemporanei...NB potrei metterci anche il size match...anzi c'è e potrei rimuoverlo da sopra, 
ma preferisco tenerlo esplicitato sopra anche se è una ridondanza...
in pratica la seq viene segmentata dinamicamente (individuo il primo seg e processo, poi passo al prox) ed ogni 
segmento posso flaggarlo come true/false e se true posso prenderlo o no...anzi ragioniamo diversamente...
un pattern matching and filtering può essere suddiviso in un insieme di operazioni booleane il cui confronto 
elementare si riduce al cercare una seq dentro la seq originaria e se trovata a che indice ed eventualmente 
controllo se l'indice appartiene ad un certo "intervals" questo controllo elementare è alla base sia del filtering 
(cioè ho trovato un pattern, quindi relativamente ad esso estraggo/filtro una parte di seq) che del matching...da 
quanto detto si evince che concettualmente anche per fare filtering serve un pattern matching, quindi la catena 
è pattern-matching+filtering eventualmente ricorsivo...NB il pmf può essere applicato sia agli elem che alle subseq...
ad es posso decidere di prendere o no una seq solo se determinate sue subseq ritornano true ai loro criteria...così 
posso anche comporre dei criteria che dipendono unicamente dai valori foglia...insomma è più generico e potente!!!
NB anche l'applicazione dei criteria alle subseq passa per un pattern matching perchè sia a pos fisse che dinamiche 
devo comunque avere delle regole per scegliere gli elem da considerare subseq e quindi passargli gli appropriati 
criteria, inoltre il pmf deve ritornare gli indici presi sui quali in una seq parallela posso fare il pmf...quindi...

criteria:
- width intervals (only check by design, reduction of width must occur by mean of a conversion algorithm)
- size intervals (only check by design, reduction of size must occur via filtering)
- pmf -> ritorna true/false (se procedere oltre), se true ritorna una subseq (eventualmente vuota)
NB recursion criteria fa parte del pmf in genere come ultimo passo, ma anche come criterio di valutazione (faccio un 
peek nel livello più in basso, questo se poi a sua volta fa altri peek, si innesca la ricorsione...)

elementary match: cerco un pattern-segment (una seq) nella seq su cui sto operando, la ricerca può essere fatta in 
un index-intervals, ma io preferisco la ricerca in una pos esatta oppure la ricerca di tutte le occorrenze e poi 
valuto gli indici ritornati...è tutto troppo complicato senza neanche raggiungere la generalità che vorrei...forse 
è meglio che mi limito fare due tipi di pmf, uno controllo ogni val che sia in un intervals, due faccio il pmf con 
le wildcards % e _ come per i LIKE in sql...nel primo caso skippo le subseq, nel secondo skippo le subseq che ricadono 
nelle wildcards, mentre per i segmenti ci devono essere solo valori, cioè nel criteria non posso mettere subseq 
by design e nella seq su cui opero se trovo una subseq nel confronto con un seg ritorno false...in pratica il criterio 
da applicare alla seq può essere di due tipi: val by val (numeri), o pattern matching (stringhe)...
il primo è molto semplice e fa automaticamente anche da filtro, nel secondo si potrebbe prevedere il filtraggio, ma 
per il momento per semplicità impongo che il filtro ritorni sempre tutta la seq...NB in ambedue i casi il criterio 
ritorna una seq di indici che hanno passato il criterio, i quali possono essere gli indici di input per la prox 
subseq della seq parent (metodo per simulare le ricerche nelle tabelle dei db), quindi ritorna il index filtering...

criteria:
- width intervals (only check by design, reduction of width must occur by mean of a conversion algorithm)
- size intervals (only check by design, reduction of size must occur via filtering)
- indexes-seq (simple seq, no intervals)
- value intervals -> this criteria returns indexes-seq (if empty, the whole criteria returns an empty seq -> discard!)
- pmf -> this criteria returns indexes-seq
NB if all (AND) of the above return a no-empty indexes-seq, then the whole criteria returns the intersection of all 
indexes...if empty the whole seq is discarded! actually for better performance, sequentially each indexes-seq returned 
by a sub-criteria is the input of the following sub-criteria (less computation)
NB rimane il recursion criteria che non è altro che una seq che mi associa agli index dove sono le subseq a dei 
sub-criteria e dove l'indice -1 rappresenta la seq stessa così facendo posso scegliere l'ordine di applicazione dei 
criteria e quindi posso far dipendere i criteria di una seq dai risultati dei criteria su alcune subseq (cfr discorso 
fatto prima) per ciascuno di questi criteria gli devo poter specificare dove prendere i vari parametri (width, size, 
values, pmf) e cioè possono essere fissi o derivanti da searches su altre seq completamente scollegate dal presente 
grafo di seq in esame...NB potrei pensare di espandere il discorso del riutilizzo degli indexes di un ramo in un altro 
pensando non solo ad una lista di indexes ma ad un grafo di indexes, cioè prendo gli indexes di un ramo con la sua 
struttura e li applico ricorsivamente ad un altro ramo con la stessa struttura...

pmf è fatto così: è una seq dove se trovo un number=0 significa %, se number=1 significa _, se ho una subseq 
significa che devo cercare quella seq in quella in cui sto operando...

NB uno dei prerequisiti per poter prendere i parametri da altre searches è quello di poter manipolare la struttura 
risultato di una search...proprio come avviene nei db che trmite il rename delle colonne nel select, i count, group, 
join ecc. da una query ottengono una tab virtuale che può non aver niente a che vedere con quelle da cui ha tratto 
i dati...DEVO prevedere anche io questi strumenti di manipolazione...

decisione: no più reference seq, basta avere la possibilità di ritornare gli indici originali (o struttura di indici) 
con i quali posso manualmente mappare verso la seq di origine...poi successivamente mi creerò in core delle classi 
helper per fare la mappatura tra indici-seq e la tracciatura delle modifiche e queste classi mi offriranno dei metodi 
che mi ritornano direttamente i parametri costruiti per fare direttamente i set, ins, del...

riepilogo:
criteria fa dei "match", "filtering", "get con specifici criteria" sulle subseq, "get con specifici criteria" su seq 
esterne...
quindi un criteria tra i vari parametri indica anche a quale seq deve essere applicato 
(current, subseq(i), extern(name))...il problema che nasce qui è che a runtime extern dovrebbe avere un puntatore, 
in storage dovrebbe avere un nome di una seq in quello storage...como lo risolvo?

NB in un mondo perfetto, mi piacerebbe avere delle strutture dati frutto di query per le quali storage tiene traccia 
e se c'è stato un cambiamento di un qualche dato nell'origine, mi notifica che c'è un update e se voglio faccio il 
refresh...sembra semplice a parole, ma è molto complicato soprattutto per le implicazioni strutturali, due su tutte 
il doppio link nella ipc (implementare i listener...) ed una struttura con interfaccia uguale a sequence ma diversa 
in grado di fare il listener (e da event dispatcher) e l'autoupdate solo dei dati cambiati...questa ultima può 
essere superflua, ma ha un impatto sulle performance...pensare...

criteria:
seq di criterion (subseq) fatte cosi...
<type, who, ref, params, reshape>
type = width-check, size-check, index-filter, value-filter, value-check, pattern-filter, pattern-match, seq-criteria 
who = this, subseq(i), extern(name)
ref = i/name (depending on "who")
params = parametri fissati, derivanti da un altro criterion, o derivanti da un'altra "get"
reshape = rules for changing the structure...
NB non tutte le possibili combinazioni sono valide ovviamente...
NB params sono fissati perchè ho già il who che mi dice se devo applicarlo su una seq-extern...
NB reshape forse è un type

criteria: return-type (indexes, indexes-struct, seq, all) + seq (ordinata) di criterion
criterion: <who, ref, type, params>
who = this, subseq(i), extern(object), storage(name)
ref = i/object/name (depending on "who") NB i/name means index/id-number object means putting the extern seq as subseq 
type = wd-check, sz-check, index-filt, value-filt, value-check, pattern-filt, pattern-match, seq-criteria, reshape 
params = seq con valori fissati 

NB devo trovare un modo per unificare object/name perchè altrimenti i criteria dipendono dal contesto (runtime/storage) 
NB criterion ritorna cose diverse a seconda del "type"

type->input / return->input for next criterion:
wd-check = this / boolean -> this
sz-check = this / boolean -> this
value-check = this / boolean -> this
pattern-match = this / boolean -> this
index-filt = indexes / this-seq-reduced -> this-seq-reduced
value-filt = indexes / this-seq-reduced -> this-seq-reduced
pattern-filt = indexes / this-seq-reduced -> this-seq-reduced
seq-criteria = indexes, indexes-struct, seq -> seq
reshape = seq -> seq

criteria: returns indexes-struct-seq + filtered-reshaped-seq
width-check
size-check
value-check
pattern-match-check
filter-seq (combination of value/pattern filtering) -> returns indexes-seq + filtered-seq
recursion-seq -> returns indexes-seqs filtered-subseqs
reshape-seq (group, count, etc.)
NB filter/recursion/reshape may access/search to other unrelated seqs

NB se io avessi una seq filtrata che mappa direttamente nell'oggetto origine, mi basterebbe get e poi set e del 
sarebbero automatici...rimarrebbe ins che può essere ricondotto al get della pos in cui voglio inserire...ma 
diventa troppo complicato...lasciamo perdere...

NB per ovviare al problema del contesto da cui prendere le seq esterne, posso prevedere che ai metodi che fanno dei 
search oltre ai criteria gli passo anche il rif all'oggetto storage a cui chiedere...poi esplicito anche che 
sequence implementa l'interfaccia storage così posso passare una seq che fa da runtime-storage...non mi torna...
se impongo che questi metodi sono solo di storage e non di seq avrei risolto il problema, ma non potrei più fare le 
ricerche su oggetti runtime...a meno che non implemento in core una classe derivata da storage che wrappa un altro 
storage e che mi fornisce sia oggetti persistenti che oggetti runtime e potrebbe fare ricerche incrociate...sembra 
la soluzione più pulita...

criteria -> <indexes-struct-seq, filtered-reshaped-seq>:
check: width, size, values, pattern -> boolean
filter: seq of several value/pattern filters -> indexes-seq + filtered-seq
recursion-criteria: seq of rules
reshape-seq: seq of rules

check = seq of number (wd), number(sz), "value-filter", "pattern-filter"
filter = seq of 2: filter(0) = types (0 = value, 1 = pattern), filter(1) = seq of filters
value-filter = seq of seq of 2 numbers or extern criteria seq of 2 (first=seqid-number, second=criteria-seq)
pattern-filter = seq of values for exact match and subseq of 1 for a wildcard (0 = any number of elems, 1 = one elem) 
                 and a subseq of 2 for an extern criteria (first=seqid-number, second=criteria-seq)
recursion = seq of 3: first = seq of indexes of subseq, second = seq of criteria NB unspecified subseq are taken whole 
            third = extern...
reshape = ...

semplifichiamo il linguaggio, lo perfezioneremo in seguito...

criteria(indexes-struct-seq, filtered-reshaped-seq):
fast-check = s-2(n-width, n-size)
value-check = s(s-2(n-a, n-b), ...) OR di intervalli...
pattern-check = s(n-exact | s(n-wildcard(0 = any number of elems, 1 = one elem)), ...)
index-filter = s(n-index, ...)
value-filter = s(s-2(n-a, n-b), ...) OR di intervalli...
pattern-filter = ...not currently implemented...
recursion-filter = ...not currently implemented...
complex-reshape-recursion-filter+check = ...not currently implemented...sarà il mio equivalente delle regex+sql!!!



criteria(indexes-struct-seq, filtered-reshaped-seq):
type = n(0=query-width, 1=query-size, 2=match-width, 3=match-size, 
         10=query-indexes, 11=query-index-filtered, 12=index-struct, 13=index-struct-filtered, 
         20=seq, 21=seq-filtered, 22=seq+recursion, 23=seq-filtered+recursion)
params = depends on type
---
type-case:
0 -> n-width
1 -> n-size
2,3 -> n-boolean
  params:
  value = n-number-to-match
  OR criteria = s(criteria for querying value)
10 -> indexes-seq (filtered of subseqs)
11 -> indexes-seq (filtered of subseqs and by custom criteria)
   params:
   filter = s(criteria for filtering NO recursion and NO reshape because of no meaning for indexes)
12 -> index-struct-seq (subseqs index also recursively)
13 -> index-struct-seq (filtered of subseqs and by custom criteria)
   params:
   filter-recursion = s(criteria for filtering-recursion and NO reshape because of no meaning for indexes)
20 -> seq (filtered of subseqs)
21 -> seq (filtered of subseqs and by custom criteria)
   params:
   filter = s(criteria for filtering NO recursion and NO reshape because of no meaning for indexes)
22 -> seq and subseqs recursively (all struct)
23 -> seq+struct filtered and reshaped
   params:
   filter-recursion-reshape = s(criteria for filtering-recursion-reshape)
---
filters:
index = s(n-index, ...)
value = s(s-2(n-a, n-b), ...) OR di intervalli...
pattern = s(n-exact | s(n-wildcard(0 = any number of elems, 1 = one elem)), ...)
recursion-filter = ...not currently implemented...
complex-reshape-recursion-filter+check = ...not currently implemented...sarà il mio equivalente delle regex+sql!!!

NB mi mancano due cose, uno uno standard per indicare per ciascun filter i parametri da ottenere tramite 
extern-search, due come passare alle subsearch (recursion) risultati ottenuti da altri subsearch o dalla seq parent...

facciamo così...
filters:
number = 0=static filter params, 1=dynamic filter params
seq = if 0 is directly the params to pass to the filter, if 1 is a criteria to launch and obtain as a filter-params as 
      result
recursion:
...todo...

riepilogo...
ogni operazione sullo storage anche se espressa con get/set/ins/del, grazie alla complessità dei criteria in realtà 
complessivamente rappresentano delle operazioni molto complesse che passano per step intermedi esprimibili in termini 
elementari, detto ciò ogni operazione sullo storage va vista come una "trasformazione" NB anche se non si alterano i 
dati originali e quindi si fa una semplice query/vista, io opero una trasforamzione su come vedere i dati, quindi in 
generale parlerò di trasformazione, morphing, o altro termine da decidere...

criteria...lo rimpiazziamo con "storage-op" o "morph" o "metamorph" o "mmorph" o "transform" o "tform":
number id = sequence id
number op = 0, 1, 2, 3 (get, set, ins, del)
seq params = depends on "op"

  if get then params = seq criteria
  if set then params = 
                       seq criteria
                       (resulting seq can only contain link to data, no queried values like width, size, indexes, etc.)
                       seq replacing
  if ins then params = 
                       seq criteria
                       (resulting seq can only contain link to data, no queried values like width, size, indexes, etc.)
                       seq inserts
  if del then params = seq criteria
                       (resulting seq can only contain link to data, no queried values like width, size, indexes, etc.)
quindi:
tform = <id, op, criteria, data (for set or ins only)>
criteria = <type, filter, recursion, reshape>
filter = <seq-static-chained-dynamic, rule1, rule2, ...>
recursion = <seq-static-chained-dynamic, rule1, rule2, ...>
reshape = <...>

NB filter modifica i numbers della seq, recursion modifica le subseq, reshape modifica l'insieme di numbers+subseqs...
NB chained filter vuol dire che prende il params dalla seq parent che glielo passa, chained recursion vuol dire che 
prende il params dal risultato della recursion rule precedente

---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del
- sequence criteria:
  - type: ...
          0=query-width, 1=query-size, 2=match-width, 3=match-size, 
          10=query-indexes, 11=query-index-filtered, 12=index-struct, 13=index-struct-filtered, 
          20=seq, 21=seq-filtered, 22=seq+recursion, 23=seq-filtered+recursion
  - filter:
    - static-dynamic-chained: seq of number specifing the type of each following rule
                              0=static, 1=dynamic, 2=chained
    - rules: sequence of number specifing the type of each following rule
                  0=index , 1=value , 2=pattern
    - param: sequence specifing the filtering rule param according to static-chained-dynamic
    ...
    - param-n:
  - recursion:
  - reshape:
- sequence data: the sequence to set from or to insert, for get/del data is not present
---
es. tabella 4col: 1 match size (num colonne) 2 (prima colonna) query size 3 (seconda col) query-index-filtered + 
filtra-ottieni valori < val derivante dalla chain filter sulla prima colonna (size prima colonna) 4 query-index-filt + 
filtra-ottieni any subseq che match un pattern 5 (quarta col) index-filter...
in pratica sulla seq madre controllo che la lunghezza sia 4 e che abbia solo subseq, sulla prima subseq non opero 
filtraggio ma chiedo un valore (solo query senza seq) che uso per filtrare sulla seconda colonna dalla quale ottengo 
sia la colonna filtrata che gli indici degli elem+suseqs buoni con questi (passaggio erroneamente mancante 
nell'esempio) filtro la prima colonna e richiedo ancora gli indici buoni (uguali a prima ovviamente) che passo poi 
alla terza colonna (colonna di stringhe) sulla quale prima filtra sugli indici, poi filtro imponendo che abbia solo 
subseqs (stringhe) e ricorsivamente prendo solo le subseqs che matchano un certo pattern con gli indici della terza 
colonna filtro semplicemente la quarta colonna...così ho ottenuto l'equivalente di una query su tabella con where 
sulla seconda colonna con x < val (dove val è una subquery) e dove sulla terza colonna è fatta di stringhe che 
rispettino un like...per simulare una clausola IN subquery basta che uso una subquery che ritorni un intervallo con 
i vari a=b (cioè un set anzichè un intervallo)
detto ciò, appare evidente che filter e recursion devono poter essere mischiati nella catena di operazioni elementari 
che queste operazioni ritornano dei risultati che possono essere utilizzati da una o più operazioni successive...
quindi utilizzo una seq "global" che raccoglie tutti i risultati delle operazioni nell'ordine di esecuzione poi nella 
descrizione della catena di operazioni ad ogni op come input specifico semplicemente la mappatura in global dove 
prendere i params...tale mappatura è al solito un path rappresentato come sequenza di indici...
riflessioni:
i filtri index-value-pattern ritornano tutti la seq filtrata dove NB pattern ritorna tutta la seq se il pattern matcha 
altrimenti seq vuota...cerco di riportare tutto a "filtri" onde unificare...quindi: filtro "numseq" ha come input 
0/1 a seconda del quale ritorna solo i num di una seq o solo le subseq...così semplificato il type, se poi riporto 
i query/match width/size nel reshape (concettualmente corretto per i query, no per i match) ho semplificato molto...
i filtri ed i recursion devo essere unificati, il reshape per il momento lo lasciamo a parte ed indefinito...poi ci 
sono le query ed i check...i check possono essere ricondotti ai filtri facendogli ritornare l'intera seq proprio come 
pattern, le query potrebbero funzionare come i filtri, ma il problema è che non fanno parte della seq o subseq, quindi 
sarebbero casomai opportune nei reshape...quindi la catena di filtri vanno associati ad una seq (0=master, 1,2,3,... 
alle subseq) ogni catena si occupa della sua seq, poi ci sono le query interne ed esterne da usare come params dei 
filtri o nei reshape...query=tform, sulle subseq sono criteria...

NB idea XDB = XML°DataBase un wrapper da xml verso storage...

---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del
- sequence criteria:
  - params: sequence of static-fixed params (expanded at runtime with results of each step of the chain)
  - seq: sequence of indexes where to pick the subseq to operate with (-1 for master seq, -2 for every subseq)
  - type: sequence of numbers specifing the chain of filter types
          0=match-width, 1=match-size, 2=width, 3=size, 4=indexes
          10=check-values, 11=check pattern, 12=check-numseq
          20=filter-index, 21=filter-values, 22=filter-pattern, 23=filter-numseq
  - params-index: sequence of indexes relative to params sequence where to pick the sub-params
  - replace: sequence of flags telling if the result must replace the seq on which operated
  - reshape: create empty seq, get(path), set(path,seq), ins(path,seq), del(path)
- sequence data: the sequence to set from or to insert, for get/del data is not present
---
allora, io specifico i criteri per "this" e i criteri per ogni subseq oppure una lista di criteri per ogni subseq...
in pratica io devo definire un path dove su ogni nodo faccio filtraggio, in più definisco altri path di filtraggi...
---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del, 4=create
- sequence criteria:
  - this-seq filter chain: sequence of filters...filter=
    - type: sequence of numbers specifing the chain of filter types
            0=match-width, 1=match-size, 2=width, 3=size, 4=indexes
            10=check-values, 11=check pattern, 12=check-numseq
            20=filter-index, 21=filter-values, 22=filter-pattern, 23=filter-numseq
    - params index: index of params seq where to get the params for this filter
  - all-subseq criteria (eventually empty)
  - specific subseq criteria (eventually empty): seq of criteria...one for each subseq present 
                                                 each result expands params
  - params: sequence of static-fixed params (expanded at runtime with results of each sub-tforms)
  - subtforms: sequence of transformations used to fill dynamic params
  - reshape: create empty seq, get(path), set(path,seq), ins(path,seq), del(path) using this seq and params as input 
             values from this seq are stored by pointers so that modifications are mad on original, values from 
             params are copied because it may be difficult to maintain integrity
- sequence data: the sequence to set from or to insert, for get/del data is not present
---
avendo appena rivisto il srv storage esteso anche alle seq nei processi ed in ram, ma anche da un punto di vista 
teorico, il concetto di constraint per le seq/storage DEVE essere considerato in modo ampio e probabilmente 
dovrò scegliere di includere le seq constraint dentro la seq di riferimento e non fare come ho detto sopra un 
raggruppamento per i vincoli ed uno per le seq dati, anche perchè spostando le seq da un processo ad un altro, 
cambiandone la persistenza, delocalizzarle su un altro pc ecc. sarebbe molto più complesso ed error-prone, 
gestirle separatamente...inoltre un vincolo può propagarsi direttamente alle subseq o prevedere che determinate 
subseq abbiano un certo tipo di vincolo ecc. insomma le possibilità sono infinite!!! per cui mi conviene affrontare 
il problema vincoli in un secondo momento ed addirittura rimandare la completa implementazione alla versione 2 di 
storage perchè dipende strettamente dalle potenzialità delle tform...quindi prima devo definire per bene le tform...
inltre un vincolo può essere relativo ai dati direttamente (set/ins) oppure alla seq risultante dalla op...ad es 
i dati rispettano tutti i vincoli per cui posso aggiungere una subseq alla seq madre, ma se questa può avere un 
numero di subseq tra 0 ed n, il non rispetto del vincolo in questo caso dipende dalla seq madre NON dai dati!!!

NB criteria = op-params...
NB i filtri check/filter-values possono essere uno per tutti indistintamente gli elem oppure può essere specificato 
un filtro/check diversi per elem specifici a determinati indici...
---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del, 4=create
- sequence params:
  - params: sequence of static-fixed params
  - filter-results: filled with results of specific filters used as dynamic params
  - subtforms: sequence of transformations used as dynamic params
  - this-seq filter chain: sequence of filters...filter=
    - id: -1=this, -2=all subseqs, 0,...,this-size=index of specific subseq
    - type: sequence of numbers specifing the chain of filter types
            0=match-width, 1=match-size, 2=width, 3=size, 4=indexes
            10=check-values, 11=check pattern, 12=check-numseq
            20=filter-index, 21=filter-values, 22=filter-pattern, 23=filter-numseq
    - static params index: index of params seq where to get the params for this filter
    - filter res params index:
    - subtforms params index:
  - reshape: create empty seq, get(path), set(path,seq), ins(path,seq), del(path) using this seq and params as input 
             values from this seq are stored by pointers so that modifications are mad on original, values from 
             params are copied because it may be difficult to maintain integrity
  - sequence data: the sequence to set from or to insert, for get/del data is not present
---
NB il reshape viene fatto sempre dopo il filtering...se per qualche motivo mi serve prima del filtering, non faccio 
altro che usare due tform separatamente con la prima che fa solo il reshape e la seconda fa il filtering...
---
TFORM:
- number id: id of the sequence object of the transformation
             (any number>0, or 0="this" depending on the context)
- number op: kind of transformation
             0=get, 1=set, 2=ins, 3=del, 4=create
- sequence params: same definition for every op except that "data" is present only for "set" and "ins"
  - sequence filter: seq of filters...filter and check this seq and subseqs recursively to get only
    - sequence filter:
      - number id: -1=this, -2=all subseqs, 0,...,this-size=index of specific subseq
                   (how to specify a sequence resulted by a filter or its indexes sequence???!!!)
      - number op: 0=match-width, 1=match-size, 2=width, 3=size, 4=indexes
                   10=check-values, 11=check pattern, 12=check-numseq
                   20=filter-index, 21=filter-values, 22=filter-pattern, 23=filter-numseq
                   30=sub-tform with filtered sequences context
                   40=sub-tform with filtered sequences indexes context
      - number result: 0=filtered sequence + sequence of filtered indexes,
                       1=filtered sequence, 2=sequence of filtered indexes
      - sequence filter-params: reshape algorithm based on static data, results from previuos filters and 
                                defined tforms acting on other sequences
  - sequence reshape: create empty seq, get(path), set(path,seq), ins(path,seq), del(path) using this seq and 
                      params as input values from this seq are stored by pointers so that modifications are made 
                      on original, values from params are copied because it may be difficult to maintain integrity
  - sequence data: the sequence to set from or to insert, for get/del data is not present
---
pensare alle notifiche delle variazioni delle sequenze, ovvero un elemento di una sequenza quando viene modificato 
lancia un evento verso i listeners subscribed a quella seq...ora il fulcro sta nel come viene gestita la 
sottoscrizione dei listeners...cioè posso far si che ogni qualvolta una seq viene aggiunta ad un'altra seq, la master 
viene aggiunta come listener alla child, impostando che la notifica di un child viene propagata gerarchicamente in 
alto fa si che gli eventi arrivino alla root seq, la quale poi la inoltra a servizi di altro tipo (es. gui) oppure si 
può far si che la sottoscrizione propagazione derivi da una gestione custom caso per caso da parte di chi utilizza le 
seq, permettendo così che ascolto solo gli eventi di una particolare subseq...questa è la soluzione più efficiente...



USER INTERFACE...
ci sono tre tipi di device: solo input, solo output, sia input che output...
una user interface ha bisogno di una o più device in grado complessivamente di fornire sia input che output...
una user interface deve fornire (anche filtrato) un completo feedback dell'input sull'output, ovvero ad ogni input 
deve corrispondere un output...in realtà non è così stretta...meglio: per ogni device di input deve esistere almeno 
un segnale che abbia un feedback in almeno un device di output...questa è la definizione corretta!!! il che vuol dire 
che se ho un mouse del quale non so niente, non fa parte della user interface...mentre, se ho un mouse che risponde 
attraverso a video solo al click di un pulsante oppure quando lo muovo di almeno una soglia...quello ne fa parte! 
...in realtà non è così, il feedback non è indispensabile poichè io potrei voler mandare dei comandi segnali 
"nascosti"!!! o comunque in generale non serve il costraint...

una delle prime cose è individuare delle interfacce raw sia per l'input che per l'output per generalizzare il più 
possibile i vari device utilizzati o utilizzabili per la user interface...NB anche le cose più impensabili!!!

ad esempio posso astrarre diverse interfacce per l'output a seconda delle dimensioni (1D, 2D, 3D, 4D, ecc.) ma 
magari se riesco ad unificarle sarebbe un successone!!! ...comunque già bisogna verificare se è fattibile l'esempio 
di prima...

altra questione da tenere presente è lo "scope" degli input e degli output...ad esempio ho una ui composta da mouse 
e parte dello schermo, in tale situazione il mouse in generale va fuori lo "scope" della mia porzione facente parte 
della ui...posso anche permetterlo, ma devo prevedere comportamenti diversi configurabili, tipo: unmanaged, 
autofocus, capture/release, ecc.

altra questione riguarda le device non strettamente di "user interface" ovvero...mentre mouse, tastiera, e simili 
hanno una evidente connotazione di user interface, ci sono poi i device di input/output generico tipo la scheda di 
rete, hd sata ed usb, ecc. come li tratto questi? forse mi serve fare una distinzione tra "user interface" (mouse, 
tastiera e simili), "stream" (rete, video, audio, hdmi, ecc.) "storage" (hd, dvd, ecc.) o forse una distinzione 
ancora più specifica...

DUNQUE...
una ui è un qualcosa che riceve dei flussi di input in base ai quali vengono generati dei flussi di output in maniera 
costante (questa è la differenza tra ui e "funzione")...ora forse varrebbe la pena estendere il concetto di ui, 
poichè posso contemplare degli input ed output dove non ci sia lo zampino dello user, ma siano solo dati...quindi, 
diciamo stp (stream processor) anzichè ui...da pensare, per il momento continuiamo a dire ui per non fare confusione...
quindi tra i segnali di input, oltre a tastiera e mouse, possiamo trovare anche i dati che confluiscono nella gui...
cioè come un tasto è bindato al click del mouse nella sua area, una listbox può essere bindata ad una tab (seq di seq) 
trasmessa insieme agli altri segnali...bisogna solo fare attenzione a come gestire il binding di strutture non 
elementari come ad esempio la listbox dove può variare indipendentemente la lista ed il singolo elemento...verificare 
in relazione agli eventi di variazioni di sequenze complesse...

esempio di controverifica concettuale: la gui...gui è un stp che quando parte gli vengono automaticamente connessi 
mouse e tastiera come input e video ed audio come output...una volta avviata la gui elabora dei segnali che oltre a 
generare un feedback audio/video, generano anche dei comandi che possono dinamicamente connettere disconnettere altri 
input/output...es. se apro un file browser questo mi genera un comando di connessione di un stream da storage a gui 
dove parallelamente il file browser invia comandi allo storage che gli dice cosa inviare alla gui (da quale dir 
prendere la lista dei files), quindi gui+mouse+kb -> avvio app "file browser" -> si connette a gui come input 
(comandi gui + dati) e come output(riceve da gui comandi)...quindi è un po' diverso, ma è ok...
in pratica un'app fornisce a gui come input dati che si traducono in gui, ovvero struttura dell'app e gui come output 
genera comandi per l'app...per cui il tutto si riduce a trovare un modo uniforme per generare comandi (deriva gratis 
dalla struttura remota dei metodi e dei parametri) ed un modo uniforme ed astratto per definire le strutture delle 
apps cioè un modo per definire menu, bottoni e caselle di testo e distribuzione logica in maniera indipendente dal 
fatto che la ui abbia un output 1D, 2D, 3D, audio, video, ecc. poi le particolarizzazioni tipo le skin, il layout, 
ecc. vengono implementati come dei profili associati al raggruppamento <app=browser, ui=gui, user=admin, skin=...ecc.> 
in pratica applicazione è un algoritmo/metodologia/funzione/ecc. indipendente dalla user interface, ma dipendente solo 
dai dati che tratta specificamente

esempi...listbox ha associato una seq che rappresenta la lista e sotto di se come child ha dei sottocontrolli textbox 
che listbox binda a ciascuna sottoseq che rappresenta un elemento della lista, listbox lancia comandi a storage 
chiedendo la lista file di una cartella, i vari textbox possono lanciare comandi tipo rinomina, cancella, ecc., (NB i 
comandi implicano il memorizzare in una cache interna di selezione)...questo approccio non mi piace...proviamo così...
listbox è un oggetto che ascolta asincronamente (su comando e refresh esterno) una seq dati (lista) ed una seq 
id-comandi ed invia asincronamente una comando tra gli id disponibili ed una sottolista (selezione) su cui agire...
così mi piace: un elemento ui è un oggetto associabile ad un srv da cui riceve una seq id-comandi, una seq dati ed 
ed una seq config/params (del controllo ui) ed invia un id comando ed una sottoseq dati...tutto asincronamente...
NB seq comandi e dati sono forniti dal srv bindato, mentre config/params e comandi ui sono forniti da altri elementi 
ui...questo permette di astrarre e separare totalmente i srv dalle ui...poi è responsabilità dei progettisti ui fare 
in modo che i controlli ui supportino la completezza dei dati offerti dai srv e l'architettura dell'app...quindi una 
app è un'architettura dove (dinamicamente) raggruppo elementi ui e bindo srv ad alcuni di essi, mentre ad altri bindo 
altri elementi ui della stessa app (sia per motivi di sicurezza che per robustezza, non consento di controllare ui 
al di fuori della app)...ciò significa che alcuni controlli gestiscono la ui, che vuol dire che per loro il srv è in 
realtà un elemento ui...qui la cosa importante è che gli elementi ui offrano un'interfaccia uguale ai srv-ui...ciò 
significa che la iface ui_elem deriva dalla iface srv_ui, poi i controlli gui, remote-controller-ui, ecc. implementano 
la iface ui_elem, o altre iface da questa derivate (es. ui_list, ui_command, ui_menu, ui_tree, ui_tab, ui_layout, ecc.)
...cioè effettivamente astraggo tutte le ui...tutto sta nell'intelligenza con cui definisco le iface derivate da 
ui_elem...piccolo esempio progetto un'app per una gui con layout, list e tab...quando anzichè una gui gli associo una 
ui 1D, magari questa ui usa uno stesso controllo per layout e per tab...cioè in fondo entrambi mi servono per 
separare degli elementi solo che nella gui posso averne alcuni visibili contemporaneamente, in un ambiente 1D no!!!
ora rimane solo da progettare come definisco le app in tutta la loro dinamicità...non è difficile, ma solo un po' 
complicato dovrebbe bastare un file xml o simili...stesso file per ogni ui (sia gui, che remote-controller-ui, ecc.)
quindi lanciare un'app significa lanciare un srv ui con parametro la ui che si vuole lanciare...
es: <gui, file_browser>, <remote-controller-ui, file_browser> (NB notare che il "file" della ui è sempre lo stesso!!!)
NB la skin è una configurazione associata a <gui, app> (utente, profilo, ecc.) e non ad app in generale...in altre ui 
la stessa app avrà altre configurazioni analoghe alle skin per la gui...
Nota: un ui_elem per creare/distruggere un altro ui_elem invia comandi al relativo parent che supporti tali comandi 
come ad es un layout può creare/distruggere altri ui_elem child, un ui_button, no! cioè creare/distruggere altri 
ui_elem è semplicemente un particolare comando offerto da taluni ui_elem

altro possibile approccio (forse molto meglio)...tutti i controlli ecc. li riporto e racchiudo nella iface della ui, 
cioè anzichè avere una ui_elem ed altre da questa derivate (ui_list, ui_command, ui_menu, ui_tab, ui_layout, ecc.), 
ho solo la iface ui con metodi specifici per gestire gli ui_list, ui_command, ui_menu, ui_tab, ui_layout, ecc.
...NO! così è troppo rigido da espandere, cioè per aggiungere un controllo devo ricompilare tutta la ui!!!

al limite posso fare così: una ui con integrato/i uno o pochi controlli elementari (es. ui_textbutton, ui_layout) e 
poi gli altri controlli li derivo utilizzando i file di def delle app, cioè facendo si che le app possono essere 
considerati controlli e viceversa, per espandere i controlli mi basta un "file xml" o simile...la differenza rispetto 
alla prima soluzione è che prima i controlli essendo compilati possono (se progetto bene la gerarchia di ifaces) 
essere vincolati alla particolare implementazione della ui, nel terzo caso sicuramente no...quale scegliere??!!!

scelgo la terza soluzione!

rimane il problema che nelle app ho controlli che agiscono su altri elementi della ui e finchè sono parametri banali 
potrebbe anche andare bene, ma in generale sono parametri specifici di quella ui (ad es un bottone per il testo 
giustificato)...in realtà è solo un problema di usabilità perchè per come ho definito gli ui_elem, non entro nello 
specifico di cosa vado a controllare, cioè in una app dico solo che in un punto c'è il controllo x che controlla il 
controllo y e basta poi in gui magari x agisce sulla giustificazione del testo in y, in una aui magari controlla la 
velocità della voce che parla...risolto così...

ora come gestire il binding tra input e comandi_ui accettati dagli ui_elem? ad es gli ui_elem possono supportare i 
comandi highlight (mouse hover), execute/select (mouse click), clear selection (middle cick), context command menu 
(right click) (comandi del srv bindato), ecc. tale binding fa parte della config della ui e grazie al profiling lo 
posso specializzare e differenziare anche a livello di app e/o controllo (ad es. in generale uso il mouse, ma per 
taluni controlli di una certa app uso il telecomando...)

controllo UI:
- oggetto che supporta comandi ui
- oggetto che può controllare se stesso ed altri controlli in base al binding tra "eventi" rilevati da uno o più 
  stream e comandi ui (la variabilità sta nel destinari/o del comando e dai parametri)
- oggetto che gestisce dati provenienti da stream connessi
- oggetto che può inviare comandi ad uno o più stream connessi (i quali a loro volta possono essere connessi a dei srv)
- oggetto che può essere creato o distrutto in base ad eventi su dati provenienti da stream connessi alla ui

in pratica ci sono stream connessi dinamicamente in base a comandi inviati alla ui (es capture mouse/kb, editing della 
catena di elaborazione segnali, ecc.), stream generalmente connessi alla ui (user input classico) che questa traduce 
in comandi inviati ai vari controlli ui sulla base delle varie configurazioni/profili (ui, app, controlli, eser, ecc.) 
stream dati connessi direttamente ad un controllo (es statusbar) NB poi ci sono degli operatori sugli stream che 
possono fare diverse cose (splitters, triggers, event detectors, ecc.) come ad esempio splittare una seq, generare 
degli eventi di creazione/distruzione controlli in base al num di elementi nella seq...in pratica...connettendo ad uno 
stream un seq processor che genera eventi sulla base della seq (num elems, elem, subseq, ecc.) e questi eventi li 
bindo a comandi ui di uno specifico controllo...il problema è che questa configurazione dovrebbe far parte della ui...

un controllo accetta comandi ui in base ai quali:
- cambia il suo stato
- crea/distrugge controlli child (per i non child invia comandi al parent e poi ci pensa lui...)
- invia altri comandi ui ad altri controlli (pensare se conviene ricondurlo al caso successivo...NO separare la ui!!!)
- comandi a srv

lo stato di un controllo dipende da:
- risorse esterne (testo e immagini) particolari per l'app date da <skin, lang> riferite tramite id e fornite tramite 
  stream dati dalla ui al controllo che le memorizza come seq asincrone (quindi possono essere cambiate in real time)
- dati derivanti da srv (testo, immagini e stream video)
- config del controllo (definita nel file app) giustificazione testo, adattamento immagine e video (no audio)
- il controllo base può avere un qualunque numero di stati (pure zero?)

NB il primo caso è una particolarizzazione del secondo dove il srv è la ui, ma li tengo separati proprio per 
evidenziare ciò che è legato alla ui e ciò che è applicazione...NB posso anche usare solo gli stream dati anche per 
le risorse, ma avrei la controindicazione che quando cambio ui, l'app usa ancora quelle risorse e potrebbe non avere 
molto senso...sarebbe cioè un uso improprio, ma mi consentirebbe la massima flessibilità qualora ne avessi bisogno...
riepilogando, in ogni caso è meglio permettere la separazione tra dati ui e dati app...

ora lasciamo perdere i casi complicati che ricordano ad es applicazioni flash (transizioni di stato, ecc.) che 
prenderò in esame con ui più avanzate

quindi in questo caso un controllo è definito dal numero di stati e per ogni stato ho un "link" ad un dato associato...
questo "link" è un'associazione o ad un id risorsa o ad un srv -> <ui_id, ui_type, <states>, <srv>, <data_actions>, ...> 
state=<bind_type, <res>> in realtà <states> sta fuori dall'app, fa parte di skin+lang...al suo posto ci metto 
"n_states" che mi dice quanti stati ha (a ciascuno dei quali corrisponde un comando ui) poi mi serve il binding coi 
dati ed il binding con i comandi...NB anche per skin+lang basta n_states...quindi...
<ui_id, ui_type, n_states, <state_actions>, <srv>, <data_actions>, <commands>>
con data_actions = <on_null, on_not_null, elems_action, seq_action, index_actions_seq> 
NB azioni basate su struct dati non sul contenuto, inoltre le ui così pensate si fermano al primo livello di struttura 
a meno di non pensare di avere azioni che reiterano il data_actions...
le azioni...possono essere sulla ui (cambia stato = esegui comando, crea, distruggi) o sui srv (esegui comando)...il 
problema sono i parametri (da e come li prendo, come li estrapolo da elaborazioni)

rielaboriamo:
<ui_id, ui_type, n_states, <ui_commands>, <srv>, <data_actions>, <commands>>
ui_command: <actions> paramteri o non parametri?
srv: specifiche per ottenere dal loader i srv-command i cui out stream vengono bindati
data_action: <on_null, on_not_null, elems_action, seq_action, index_actions_seq> azioni per ciascuno stream
command: comandi offerti dal controllo senza parametri che vengono poi tradotti in comandi per i srv con parametri

NB sembra che command ed ui_command siano ridondanti, ma potrebbe essere sempre utile mantenere la separazione tra ui 
ed app...

parametri: i parametri con cui vengono chiamati i srv-command, vengono generati a partire da: la combinazione degli 
stream provenienti dai vari srv-command, dagli user input stream e dalle variabili interne al controllo (es. selezione)

quindi rimane da progettare le azioni, le variabili interne al controllo e le regole di combinazione dei parametri...
in pratica un controllo è una composizione di srv-command, quindi è un metalinguaggio di programmazione data-driven, 
con l'aggiunta della parte ui...pensare se mi conviene ridurre tutto ad un srv...

semplificazione: riduco tutto ad un srv (che sarà un srv di comodo per le ui e che racchiude tutta la logica) dove lui 
manda una seq asincronamente e riceve comandi con unico parametro l'index complesso riferito alla seq ultima che ha 
fornito (attenzione alla sicronizzazione!!!)...es. addselection(index), clearselection(), increasecounter(), ecc...
in pratica ongi metodo (comando) è bindabile quasi direttamente ad eventi ui...questi index è facile ottenerli perchè 
(ancora devo ragionare come) vengono specificati nelle data action per generare dei sottocontrolli ed associarli a 
questi, poi questi invieranno comandi al parent il quale ha la mappa <sottocontrollo, index>...un controllo espone 
comandi (con index complesso) e questi vengono mappati (da config nell'app) nei comandi del srv oppure a comandi ad 
altri controlli...quindi:
<ui_id, ui_type, n_states, <ui_command>, <srv>, <data_action>>
ui_command: <ui_id, command, param> se ui_id = -1 allora è riferito a srv..."command" se è un comando ui allora è uno 
dei comandi supportati dai controlli (create/destroy/change_state/etc.) e param va pensato bene...
srv: specifiche per ottenere dal loader i srv-command il cui out stream viene bindato
data_action: <on_null, on_not_null, elems_action, seq_action, index_actions_seq> azioni ui per ciascuno stream
questo va pensato bene...in pratica sono descrizioni di comandi parametrici dove il parametro implicito è l'index 
complesso e gli altri parametri sono la descrizione dei controlli...cioè action può essere "crea child" o "distruggi 
tutti i child" (sugli eventi dati permetto solo il destroy all altrimenti è troppo complicato...magari se serve, lo 
espando in una futura versione)...posso permettere un "update"? seq_action può essere uguale ad una data_action e così 
ricorsivamente

iface UI:
- start (forse superfluo)
- stop (forse superfluo)
- getParameters: per questi due metodi va usato lo standard dettato dalla iface config
- setParameters
- setIOConnection: dis/connette uno stream in input o output compatibili con la particolare implementazione della ui
- loadUI: accetta come argomento la seq che rappresenta la ui (app, controllo, ecc.) da eseguire...da dove arrivi 
tale seq non interessa la ui...può arrivare da un db, da un file serializzato, un file di testo, dalla rete...
cioè caricare i file non è più cura delle app, ma se ne occupa l'utente dall'esterno creando un flusso di stream...
cioè uniformando tutto il os con le seq il flusso di dove arrivano/vanno i dati è estremamente flessibile!!!
la seq ha una struttura tutta relativa a come progetterò la iface ui fatta eccezione ai srv da bindare: per questi 
viene specificato il nome da richiedere al loader, la iface è per tutti la iface "command" che ha un unico metodo 
"execute" per cui "params" è fatta così: id-command ed una seq params
insieme alla iface si definisce il formato di ui_seq e gli ui_type consentiti
ui_type: ui_layout (solo lui può avere dei child), ui_data (se data=1elem, allora rappresenta numero, se data=seq, 
allora rappresenta testo, se data=seq-complessa, allora può essere immagine, audio, ecc.)

NB pensata così ui può uniformare tutte le possibili ui, quindi un unico srv implementerà ui...gui, aui, ecc. 
deriveranno semplicemente da come connetto input ed output alla ui, ma è molto complicato adesso e bisognerebbe 
astrarre molto bene gli input e gli output (1D, 2D, ecc.) per il momento lasciamo perdere ed implemento una ui 
come gui richiedendo obbligatoriamente un output 2D più uno o due facoltativi 1D (audio)

rimane da definire il formato della ui_seq:
- struct_seq: seq di id_obj, se c' una subseq allora tutti gli obj riferiti in questa sono child dell'elem che 
  precede la subseq
- obj_seq: seq di seq rappresentanti gli oggetti (sia srv che controlli) usati NB index=id_obj
  - obj: seq <ui_type, binded_type, ui_id/ui_name/command_srv_name, actions_seq> NB obj_params sono specifici della ui 
    e per lo stesso obj che è presente più volte nella stessa app, possono essere diversi (due file browser con 
    dimensioni e visualizzazione diverse)...riguardo al binded_type io posso bindare altri ui_elem presenti nella 
    stessa app, posso richiamare delle app come ui_elem tramite ui_name ed infine dei command_srv tramite nome...ora, 
    mentre richiamare i srv tramite nome mi può (mi deve) andare bene, per le app lo posso accettare? per il momento 
    si, ma poi mi devo slegare dal particolare storage (il file system in questo caso)
NB come prevedere la creazione/distruzione dinamica (dipendente dai dati) degli ui_elem?
casistiche: partendo da una seq posso fare le seguenti distinzioni: azioni omogenee per tutti gli elem ed altre azioni 
per tutte le seq, oppure azioni distinte per index, poi posso avere azioni per seq null ed azioni per seq not-null
actions_seq: <on_null, on_not_null, elems_action, seq_action, index_actions_seq> dove ognuno di questi è un'azione 
eccetto index_actions_seq che è una sequenza di coppie <index, action> NB per tutti gli elem/seq non presenti nella 
index_actions_seq, vengono eseguite le actions elems_action e seq_action rispettivamente...
rimane da definire action e poi le action da bindare agli input

dunque, da una parte c'è il "device manager" o "iom" (i/o manager) che è un srv ad istanza unica che gestisce 
tutto l'hw di input/output dall'altra c'è il "uim" (user interface manager) che gestisce l'i/o di interfaccia utente, 
ovvero mouse, tastiera, video, audio, ecc. che astrae dal particolare hw gli basta solo che gli hw a cui viene 
associato abbiano determinate iface...in pratica uim si occupa solo di sw cioè non fa altro che fare conversioni, 
filtraggi, trattamenti di dati e dispatching di i/o da/per apps/srvs...anzi rivediamo così i nomi: "dem" (device 
manager), "iom" (gestisce l'i/o di uim + tutto il resto del i/o) iom oltre a fare i servizi specifici di uim, 
gestisce tutto l'i/o accedendo direttamente alle iface del hw potendo quindi sfruttare le eventuali capacità hw come 
ad es. se devo fare un resize di uno stream video posso vedere se la destinazione dello stream è verso una scheda 
grafica che supporta questo tipo di funzione via hw...naturalmente il discorso è più generale: iom elabora, rimappa e 
dispaccia segnali avvalendosi di tutto l'hw a disposizione per ottimizzare ed accelerare tali operazioni anche quando 
l'hw in questione non è direttamente coinvolto...questa possibilità di iom deriva direttamente dall'accedere 
direttamente alle iface del hw al contrario de uim come avevo ipotizzato inizialmente...naturalmente la possibilità 
di sfruttare l'accelerazione hw è consentita potenzialmente ad ogni srv tramite l'accesso alle iface hw...
in pratica il dem include i driver hw con i quali offre diverse iface hw ai srv richiedenti...queste iface devono 
avere un alto grado di astrazione tipo "parallel stream" (hdmi, rete), "parallel sequence" (mouse, tastiera, 
telecomando, ecc.), "finite storage" (hd sata/usb, sdhc, cd/dvd/bd, ecc.) per il momento anche se non piace diciamo 
che in linea di principio sono consentiti hw compositi (tipo sceda grafica con audio incorporato)...in ogni caso, 
ogni hw (anche semplice) può offrire più di una iface hw (ad es rete può offrire sia parallel stream che parallel 
sequence), inoltre da una iface hw posso richiedere l'hw associato cioè il srv specifico di quel particolare hw 
tramite il quale posso accedere alle funzionalità di accelerazione o impostare delle proprietà specifiche...

NB ritorna il problema di ritornare oggetti (iface, srv) anzichè solo sequence...potrei pensare di utilizzare il 
loader ed usare degli id ritornati nelle sequence, ma sarebbe una soluzione intrinsecamente lenta in ogni situazione 
per cui devo pensare ad una soluzione integrata in CommandListener ed IPC/IPCServer/IPCClient...

RIEPILOGANDO...
IOI (Input/Output Interface): ifaces di alto livello che astraggono l'input e l'output sia da/per hw che da/per 
apps/srvs...

DEM (DEvice Manager): gestisce ogni hardware e fornisce dei iface-srv-driver che accedono alle funzionalità ed alle 
proprietà/configurazione, tali iface devono essere pensate per raggruppare tipologie di hw omogenee, poi le config 
sono specifiche del particolare hw. alcuni di questi hw possono fornire delle iface di i/o di alto livello (ioi) che 
consentano di effettuare i/o da/per l'hw in modo generico ed efficiente...

IOM (I/O Manager): è il srv a cui chiedere le ioi, quando chiedo una ioi al loader questo la ritorna/istanzia 
tramite iom...NB in base alle policy di sistema (cioè come gestire le istanziazioni di loader) loader ritornerà una 
certa ioi, ma indipendentemente da ciò a runtime posso modificarle/rimapparle/ecc. (naturalmente in base alle policy)
NB ripensare bene a iom, loader e policy...

UI (User Interface): una ui è un srv che utilizza alcune ioi tramite le quali inviare comandi a determinate 
apps/srvs...

IOS (I/O Signal): è una sequenza con particolari formati, ovvero uno stream parallelo di più sequenze elementari...
qui non mi interessa il wiring/channel/ecc. ma il multiplexing e/o encoding...in pratica un ios è una sequenza che 
racchiude un "qualunque" numero di segnali con una "qualunque" possibile codifica in modo molto simile (ma più 
avanzato) del hdmi, la cosa importante è che il formato di impacchettamento/multiplexing di ios sia agevole e 
flessibile in merito ai wiring/channel fisici possibili ovvero rispetto al trasporto fisico (cavo hdmi, fibra ottica, 
radiofrequenza, infrarosso, ecc.)...quindi...
ios rappresenta dei segnali nel tempo potenzialmente campionati a diverse frequenze non multiple tra di loro...ios 
deve consentire una base tempo variabile a seconda delle esigenze dei segnali che trasporta...quindi le proprietà:
- num canali: num segnali distinti
  per ogni canale:
  - freq o intervallo di campionamento
  - dimensione del singolo campione in bit
  - standard di codifica utilizzato

NB nel singolo campione ci metterò generalemente tutto quello che riguarda quel flusso, ad es. nei segnali video ci 
metterò 3*8 bit relativi ai tre sottocanali rgb...potrei metterci anche l'audio a patto di definire uno standard di 
codifica audio/video, in realtà in genere l'audio lo metterò a parte...multichannel ovviamente, poi penserò anche 
a dei segnali "di campo" cioè audio e video "3d" cioè che consentono di ricreare il campo 3d audio/video...

NB ricordiamoci che fin dall'inizio dei discorsi teorici abbiamo deciso di fissarci sul mondo digitale ed anche qui 
sebbene trattare segnali puramente analogici avrebbe senso, lasciamo stare perchè nella pratica ormai ogni segnale 
viene digitalizzato!!! ...in futuro pensando a futuri device avanzati ed analogici o fuzzy il tutto dovrà essere 
rivisto...ma finchè non ci saranno elaboratori analogici o fuzzy, non ha senso (praticamente)...

ora rimane da decidere come comunicare le "info" dello stream...con un altro canale (il primo) ma bisogna 
dimensionarlo staticamente a priori o può essere dinamico? ...cioè fisso a priori un range di valori per le info o 
massima generalità?

il problema ora si sposta a come le sequenze e gli stream si correlano tra loro, in quanto i segnali sono stream...
e qui viene il bello poichè anche dei comandi possono essere considerati impacchettati in stream da cui è nata l'idea 
di rendere le chiamate di metodi (comandi) standardizzate e decentralizzate...ora il trasporto fisico può essere 
qualunque (seriale o parallelo), io devo cercare di astrarne e pensare allo stream come una sequenza infinita nella 
quale siano state muxate altre sequenze...così il problema si riduce a come entrare in synch con lo stream nel caso 
più generale possibile...

riepilogando:
ios deve permettere una comunicazione asincrona nel qual caso i pacchetti così come arrivano vengono processati, oltre 
ad una comunicazione sincrona dove ogni pacchetto arriva asincronamente ma con le info di "sincronizzazione" che li 
collocano in un punto preciso...sarà poi il gestore che li scarterà, li metterà in coda o li processa subito in base 
alle sue policy (se arrivati tardi allora scarta o introduci un delay, ecc.)...
NB questa synch è diversa dal synch del canale (vediamo dopo)!!!
ogni pacchetto afferisce ad un canale diverso così ogni canale può avere una base tempo qualunque e anche non 
correlata con gli altri canali...
ATTENZIONE!!! la velocità di trasferimento dello stream deve essere scelta tale da consentire che tutti i canali 
vengano trasmessi almeno alla propria velocità ed inoltre deve consentire un mux che anche se dinamico quando i 
canali hanno velocità non multiple tra loro, che in ogni momento non metta in competizione due canali (ad es se 
alcuni canali hanno campioni con un gran numero di bit potrebbe facilmente capitare che se metto un pacchetto di 
un certo canale poi un altro canale arriva in ritardo o viceversa), inoltre la velocità di trasferimento implica 
anche il delay minimo che impone il primo campione...
ios quindi dovrebbe essere legato al trasporto fisico il quale deve poter garantire una velocità minima, una certezza 
ed una correttezza del trasferimento...attualmente nei pc non esiste tutto ciò...è tutto asincrono e si spera che 
arrivi in tempo...per questo nacquero gli os real-time...ora è vero che io non posso garantire niente perchè in genere 
non starò su os real-time, ma lo gestisco lo stesso perchè sarà una parte importante che si riflette sul hw e sulle 
semplificazioni e standardizzazioni che implicherebbe in hw compliant con gli standard sunaptos...

quindi...
ios è una iface che connette uno o più srv che riceve o trasmette pacchetti tramite dei metodi appositi e viene 
gestita (velocità ecc.) con altri metodi...i pacchetti poi hanno le info specifiche al loro interno...NB ios può 
avere un buffer interno...
è chiaro che il modello è simile alle socket...va bene così!
il passo successivo è il networking di ios (nios)...cioè, ios rimane un flusso ma da dove arriva ed dove va, lo decido 
io trasparentemente...però devo considerare a più basso livello un qualcosa che può contenere diversi ios, cioè il 
trasporto (cavo, socket, rf, ecc.) ciò presuppone l'aggiunta in rx e tx di demux/mux per inserire pacchetti di diversi 
ios qui adotto una soluzione diversa dalle socket le quali sono caratterizzate da start-endpoint se invece do il 
nome al ios e poi decido indipendentemente chi possono essere connessi ho maggiore grado di libertà...cioè in tx/rx 
assegno degli ios-id locali a quel nios poi in rx/tx è il nios che associa agli id i corretti start-endpoint...simile 
al nat...NB un nios è anche un ios...il che significa che posso unire diversi nios in una nios di nios...questo 
permette delle reti grandi quanto mi pare, non c'è il limite del numero di indirizzi ip, ci sono solo i limiti del 
singolo trasporto fisico o virtuale che per sua natura potrà permettere solo un tot di ios contemporanei...ovviamente 
i nios prima di rimetterli in altri nios vanno spacchettati...qualcosa non torna nei nios di nios...verificare...
no torna tutto semplicemente nel passaggio da un nios ad un altro chi gestisce ciò rimappa gli id bilateralmente...
è ovvio che ad ogni start-endpoint ci sono dei controller hw o virtuali...l'unico vero problema è che questi id in 
genere dovrebbero essere riutilizzati quindi potenzialmente se i gestori non si comunicano correttamente sempre 
potrebbero esserci dei flussi indirizzati a destinatari sbagliati!!! ...risolvere...

signal o stream: flusso di dati unidirezionale asincrono o sincrono con caratteristiche (temporizzazione, dimensione 
campione e codifica) prefissate sul quale viaggiano sia pacchetti dati che pacchetti info su richiesta (???) o 
temporizzati...per i segnali sincroni serve la freq di campionamento mentre per i segnali asincroni il max-delay 
accettabile...lo stream si occupa di impacchettare e ricostruire l'informazione durante la trasmissione (tipo il tcp) 
ovvero che i pacchetti arrivino nell'ordine giusto (quando richiesto), mentre nel caso asincrono (oggetti di 
dimensioni anche molto variabili) è sicuramente richiesto che i pacchetti siano riordinati quando un oggetto è 
suddiviso in più pacchetti...
in pratica sullo stream passano "oggetti" che possono venire o meno raggruppati ed ordinati ogni oggetto viene 
impacchettato (anche se un oggetto entra in un pacchetto, mentre se ad un oggetto corrispondono più pacchetti il 
raggruppamento ed ordinamento è obbligato!) l'header del pacchetto contiene info sul pacchetto indispensabili allo 
spacchettamento, una volta spacchettato l'oggetto ha come header la codifica (cioè che cosa è, e come è memorizzato...
ad es. campione video rgb, campione audio pcm16, buffer di sequenza complessa, ecc.)...
NB queste codifiche devono essere più generiche possibile...pensare bene!!! ...ad esempio potrebbero essere: sequenza 
(ovvero ogni tipo di oggetto), update di substruttura di sequenza (ovvero pezzo di sequenza che è cambiato con 
associato un id per sapere a quale root seq fa riferimento...), campione completo di un flusso continuo (sincrono o 
asincrono es. audio/video/mouse/tastiera/ecc.) questo non è altro che una seq con dentro anche la codifica del 
campione...

ios: flusso di signal eventualmente bufferizzato generalmente full-duplex (i/o) dove ci possono essere più 
trasmittenti e più ricevitori connessi con mux e demux gestiti tali da consentire connessioni multi-tx vs multi-rx...
NB un ios è pronto così com'è per essere messo su un trasporto fisico tramite opportuni adc/dac senza alcuna 
gestione a livello fisico tranne per il transfer-rate/banda-passante che devono essere uguali o multipli del più 
veloce segnale che viaggia su ios (cioè il più veloce tra campionamento più rapido dei segnali sincroni ed il minimo 
tra i max-delay consentiti per i segnali asincroni...

un rx o tx può essere un nodo di una rete...in tal caso da una parte fa il demux e ogni signal lo muxa in altri ios...
quindi al di fuori ci sarà qualcuno che gli dice come fare queste mappature...un insieme di mappature costituisce un 
ios-path o instradamento o routing è chiaro che se qualcuno di questi ios ha come destinatario un nodo questo può 
servire a controllare il nodo cioè la rete viene utilizzata per gestire se stessa...ad es mi connetto al primo nodo 
e gli dico come conettersi ad altri nodi contigui, ora mi posso connettere a ciscuno di questi e così via...va 
solo pensato bene come fare per la sicurezza...
